<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Anatomy of a "Memory Leak"</Title>
<Body>&lt;p&gt;In .NET perspective:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;What is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_leak&quot; rel=&quot;noreferrer&quot;&gt;memory leak&lt;/a&gt;?&lt;/li&gt;&lt;li&gt;How can you determine whether your application leaks? What are the effects?&lt;/li&gt;&lt;li&gt;How can you prevent a memory leak?&lt;/li&gt;&lt;li&gt;If your application has memory leak, does it go away when the process exits or is killed? Or do memory leaks in your application affect other processes on the system even after process completion?&lt;/li&gt;&lt;li&gt;And what about unmanaged code accessed via COM Interop and/or P/Invoke?&lt;/li&gt;&lt;/ul&gt;</Body>
<Tags>.net,performance,memory-leaks,com-interop</Tags>
</question>
<answer>
<Body>&lt;p&gt;I guess in a managed environment, a leak would be you keeping an unnecessary reference to a large chunk of memory around.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I will concur with Bernard as to in .net what a mem leak would be.&lt;/p&gt;&lt;p&gt;You could profile your application to see its memory use, and determine that if its managing a lot of memory when it should not be you could say it has a leak.&lt;/p&gt;&lt;p&gt;In managed terms I will put my neck on the line to say it does go away once the process is killed/removed.&lt;/p&gt;&lt;p&gt;Unmanaged code is its own beast and if a leak exists within it, it will follow a standard mem. leak definition.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The best explanation I&#x27;ve seen is in Chapter 7 of the free &lt;a href=&quot;http://codebetter.com/karlseguin/2008/06/25/foundations-of-programming-ebook/&quot; rel=&quot;noreferrer&quot;&gt;Foundations of Programming e-book&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Basically, in &lt;strong&gt;.NET&lt;/strong&gt; a memory leak occurs when referenced objects are rooted and thus cannot be garbage collected. This occurs accidentally when you hold on to references beyond the intended scope.&lt;/p&gt;&lt;p&gt;You&#x27;ll know that you have leaks when you start getting OutOfMemoryExceptions or your memory usage goes up beyond what you&#x27;d expect (&lt;strong&gt;PerfMon&lt;/strong&gt; has nice memory counters). &lt;/p&gt;&lt;p&gt;Understanding &lt;strong&gt;.NET&lt;/strong&gt;&#x27;s memory model is your best way of avoiding it. Specifically, understanding how the garbage collector works and how references work â€” again, I refer you to chapter 7 of the e-book. Also, be mindful of common pitfalls, probably the most common being events. If object &lt;strong&gt;A&lt;/strong&gt; is registered to an event on object &lt;strong&gt;B&lt;/strong&gt;, then object &lt;strong&gt;A&lt;/strong&gt; will stick around until object &lt;strong&gt;B&lt;/strong&gt; disappears because &lt;strong&gt;B&lt;/strong&gt; holds a reference to &lt;strong&gt;A&lt;/strong&gt;. The solution is to unregister your events when you&#x27;re done. &lt;/p&gt;&lt;p&gt;Of course, a good memory profile will let you see your object graphs and explore the nesting/referencing of your objects to see where references are coming from and what root object is responsible (&lt;a href=&quot;http://www.red-gate.com/products/ants_memory_profiler/index.htm&quot; rel=&quot;noreferrer&quot;&gt;red-gate ants profile&lt;/a&gt;, JetBrains dotMemory, &lt;a href=&quot;http://memprofiler.com/&quot; rel=&quot;noreferrer&quot;&gt;memprofiler&lt;/a&gt; are really good choices, or you can use the text-only &lt;strong&gt;WinDbg&lt;/strong&gt; and &lt;strong&gt;SOS&lt;/strong&gt;, but I&#x27;d strongly recommend a commercial/visual product unless you&#x27;re a real guru).&lt;/p&gt;&lt;p&gt;I believe unmanaged code is subject to its typical memory leaks, except that shared references are managed by the garbage collector. I could be wrong about this last point.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Strictly speaking, a memory leak is consuming memory that is &quot;no longer used&quot; by the program.&lt;/p&gt;&lt;p&gt;&quot;No longer used&quot; has more than one meaning, it could mean &quot;no more reference to it&quot;, that is, totally unrecoverable, or it could mean, referenced, recoverable, unused but the program keeps the references anyway. Only the later applies to .Net for &lt;strong&gt;perfectly managed objects&lt;/strong&gt;. However, not all classes are perfect and at some point an underlying unmanaged implementation could leak resources permanently for that process.&lt;/p&gt;&lt;p&gt;In all cases, the application consumes more memory than strictly needed. The sides effects, depending on the ammount leaked, could go from none, to slowdown caused by excessive collection, to a series of memory exceptions and finally a fatal error followed by forced process termination.&lt;/p&gt;&lt;p&gt;You know an application has a memory problem when monitoring shows that more and more memory is allocated to your process &lt;strong&gt;after each garbage collection cycle&lt;/strong&gt;. In such case, you are either keeping too much in memory, or some underlying unmanaged implementation is leaking.&lt;/p&gt;&lt;p&gt;For most leaks, resources are recovered when the process is terminated, however some resources are not always recovered in some precise cases, GDI cursor handles are notorious for that. Of course, if you have an interprocess communication mechanism, memory allocated in the other process would not be freed until that process frees it or terminates.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I would define memory leaks as an object not freeing up all the memory allocated after it has completed. I have found this can happen in your application if you are using Windows API and COM (i.e. unmanaged code that has a bug in it or is not being managed correctly), in the framework and in third party components. I have also found not tiding up after using certain objects like pens can cause the issue.&lt;/p&gt;&lt;p&gt;I personally have suffered Out of Memory Exceptions which can be caused but are not exclusive to memory leaks in dot net applications. (OOM can also come from pinning see &lt;a href=&quot;https://blogs.msdn.com/yunjin/archive/2004/01/27/63642.aspx&quot; rel=&quot;noreferrer&quot;&gt;Pinning Artical&lt;/a&gt;). If you are not getting OOM errors or need to confirm if it is a memory leak causing it then the only way is to profile your application.&lt;/p&gt;&lt;p&gt;I would also try and ensure the following:&lt;/p&gt;&lt;p&gt;a) Everything that implements Idisposable is disposed either using a finally block or the using statement these include brushes, pens etc.(some people argue to set everything to nothing in addition) &lt;/p&gt;&lt;p&gt;b)Anything that has a close method is closed again using finally or the using statement (although I have found using does not always close depending if you declared the object outside the using statement)&lt;/p&gt;&lt;p&gt;c)If you are using unmanaged code/windows API&#x27;s that these are dealt with correctly after. (some have clean up methods to release resources)&lt;/p&gt;&lt;p&gt;Hope this helps.&lt;/p&gt;</Body>
</answer>
</qroot>
