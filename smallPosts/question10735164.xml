<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Modeling types and subtypes with strongly typed enums?</Title>
<Body>&lt;p&gt;I want to define a &lt;a href=&quot;http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Header&quot; rel=&quot;nofollow&quot;&gt;ICMP header&lt;/a&gt; as a pod type:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct ICMPHeader{    uint8_t   Type;         // ICMP type    uint8_t   Code;         // Subtype, value is dependent on ICMP type.    uint16_t  Checksum;     // Error checking data. See RFC 1071    uint32_t  RestOfHeader; // Varies based on ICMP type and code.};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For the &lt;code&gt;ICMPType&lt;/code&gt; field I can use strongly typed enums to make it a bit nicer:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;enum class ICMPType : uint8_t{    EchoReply              = 0,    Reserved1              = 1,    Reserved2              = 2,    DestinationUnreachable = 3,    SourceQuench           = 4    // etc...};struct ICMPHeader{    ICMPType  Type;         // ICMP type    uint8_t   Code;         // Subtype, value is dependent on ICMP type.    uint16_t  Checksum;     // Error checking data. See RFC 1071    uint32_t  RestOfHeader; // Varies based on ICMP type and code.};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, I naturally also want to specify the &lt;code&gt;Code&lt;/code&gt; field as an enum. It would be nice if I could use template specialization syntax, but a quick test reveals that it doesn&#x27;t work:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Compiler errortemplate&amp;lt;ICMPType&amp;gt;enum class ICMPCode;    template&amp;lt;&amp;gt;enum class ICMPCode&amp;lt;ICMPType::DestinationUnreachable&amp;gt;{    DestinationNetworkUnreachable  = 0,    DestinationHostUnreachable     = 1,    DestinationProtocolUnreachable = 2};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One option would be to wrap them in structs:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Meaning of ICMP code is dependent on ICMP type.template&amp;lt;ICMPType&amp;gt;struct ICMPCode;// Subcodes for DestinationUnreachabletemplate&amp;lt;&amp;gt; struct ICMPCode&amp;lt;ICMPType::DestinationUnreachable&amp;gt;{    enum class Code : uint8_t    {        DestinationNetworkUnreachable  = 0,        DestinationHostUnreachable     = 1,        DestinationProtocolUnreachable = 2        // etc...    };};// Access: ICMPCode&amp;lt;ICMPType::DestinationUnreachable&amp;gt;::Code::DestinationHostUnreachable&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But doing it like this makes me feel that I&#x27;m just messing around and making things too complex..&lt;/p&gt;&lt;p&gt;I guess this is a specific example of a more general question: How to setup a system of types and subtypes? Any suggestions?&lt;/p&gt;&lt;p&gt;Ps:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;See also: &lt;a href=&quot;http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Header&quot; rel=&quot;nofollow&quot;&gt;http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Header&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Sample code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;// Trying to model ICMP types and codes with strongly typed enums// See also http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Headerenum class ICMPType : uint8_t{    EchoReply              = 0,    Reserved1              = 1,    Reserved2              = 2,    DestinationUnreachable = 3,    SourceQuench           = 4    // etc...};// Meaning of ICMP code is dependent on ICMP type.template&amp;lt;ICMPType&amp;gt;struct ICMPCode;// Subcodes for DestinationUnreachabletemplate&amp;lt;&amp;gt; struct ICMPCode&amp;lt;ICMPType::DestinationUnreachable&amp;gt;{    enum class Code : uint8_t    {        DestinationNetworkUnreachable  = 0,        DestinationHostUnreachable     = 1,        DestinationProtocolUnreachable = 2        // etc...    };};ICMPCode&amp;lt;ICMPType::DestinationUnreachable&amp;gt;::Code GetReasonWhyDestinationIsUnreachable(){    return ICMPCode&amp;lt;ICMPType::DestinationUnreachable&amp;gt;::Code::DestinationHostUnreachable;}int main(){    std::cout &amp;lt;&amp;lt; static_cast&amp;lt;int&amp;gt;(GetReasonWhyDestinationIsUnreachable()) &amp;lt;&amp;lt; std::endl;}&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++</Tags>
</question>
<answer>
<Body>&lt;p&gt;I don&#x27;t think you can do this statically at compile time because you&#x27;re changing the &lt;code&gt;ICMPType&lt;/code&gt; at run time.&lt;/p&gt;&lt;p&gt;I would suggest:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Make an enum for each of the &lt;code&gt;code&lt;/code&gt; ranges you want to represent.&lt;/li&gt;&lt;li&gt;Create a container for each type (i.e. multiple &lt;code&gt;ICMPHeader&lt;/code&gt; types specific to each type and lose the type variable there).&lt;/li&gt;&lt;li&gt;Create a factory which takes your original ICMP header and produces one of the specialised types with the appropriate &lt;code&gt;ICMPType&lt;/code&gt; enum.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;That should be a pretty flexible approach, but simply casting the value of the code depending on the type would probably be enough and much easier to handle.&lt;/p&gt;&lt;p&gt;In your example you just cast back to an int though which strips everything you just set out to achieve.. ?&lt;/p&gt;&lt;p&gt;&lt;em&gt;Edit - if all your containers inherited from a common base class you could gave a generic GetDescription() method which the children could then populate. Abstracting the details away like this makes for a nice clean design...&lt;/em&gt;&lt;/p&gt;</Body>
</answer>
</qroot>
