<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Implementation of getline ( istream&amp; is, string&amp; str )</Title>
<Body>&lt;p&gt;My Question is very simple, how is getline(istream, string) implemented?How can you solve the problem of having fixed size char arrays like with getline (char* s, streamsize n ) ?Are they using temporary buffers and many calls to new char[length] or another neat structure?&lt;/p&gt;</Body>
<Tags>c++,string</Tags>
</question>
<answer>
<Body>&lt;p&gt;&lt;code&gt;getline(istream&amp;amp;, string&amp;amp;)&lt;/code&gt; is implemented in a way that it reads a line. There is no definitive implementation for it; each library probably differs from one another.&lt;/p&gt;&lt;p&gt;Possible implementation:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;istream&amp;amp; getline(istream&amp;amp; stream, string&amp;amp; str){  char ch;  str.clear();  while (stream.get(ch) &amp;amp;&amp;amp; ch != &#x27;\n&#x27;)    str.push_back(ch);  return stream;}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;@SethCarnegie is right:  more than one implementation is possible.  The C++ standard does not say which should be used.&lt;/p&gt;&lt;p&gt;However, the question is still interesting.  It&#x27;s a classic computer-science problem.  Where, and how, does one allocate memory when one does not know in advance how much memory to allocate?&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;One solution is to record the string&#x27;s characters as a &lt;em&gt;linked list&lt;/em&gt; of individual characters.  This is neither memory-efficient nor fast, but it works, is robust, and is relatively simple to program.  However, a standard library is unlikely to be implemented this way.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A second solution is to allocate a buffer of some fixed length, such as 128 characters.  When the buffer overflows, you allocate a new buffer of double length, 256 characters, then copy the old characters over to the new storage, then release the old.  When the new buffer overflows, you allocate an even newer buffer of double length again, 512 characters, then repeat the process; and so on.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A third solution combines the first two.  A linked list of character arrays is maintained.  The first two members of the list store (say) 128 characters each.  The third stores 256.  The fourth stores 512, and so on.  This requires more programming than the others, but may be preferable to either, depending on the application.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;And the list of possible implementations goes on.&lt;/p&gt;&lt;p&gt;Regarding standard-library implementations, @SteveJessop adds that &quot;[a] standard library&#x27;s string isn&#x27;t permitted to be implemented as (1), because of the complexity requirement of &lt;code&gt;operator[]&lt;/code&gt; for strings. In C++11 it&#x27;s not permitted to be implemented as (3) either, because of the contiguity requirement for strings. The C++ committee expressed the belief that no active C++ implementation did (3) at the time they added the contiguity requirement. Of course, &lt;code&gt;getline&lt;/code&gt; can do what it likes temporarily with the characters before adding them all to the string, but the standard does say a lot about what string can do.&quot;&lt;/p&gt;&lt;p&gt;The addition is relevant because, although &lt;code&gt;getline&lt;/code&gt; could temporarily store its data in any of several ways, if the data&#x27;s ultimate target is a string, this may be relevant to &lt;code&gt;getline&lt;/code&gt;&#x27;s implementation.  @SteveJessop further adds, &quot;For string itself, implementations are pretty much required to be (2) except that they can choose their own rate of expansion; they don&#x27;t have to double each time as long as they multiply by some constant.&quot;&lt;/p&gt;</Body>
</answer>
</qroot>
