<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>command line arg parsing through introspection</Title>
<Body>&lt;p&gt;I&#x27;m developing a management script that does a fairly large amount of work via a plethora of command-line options. The first few iterations of the script have used optparse to collect user input and then just run down the page, testing the value of each option in the appropriate order, and doing the action if necessary. This has resulted in a jungle of code that&#x27;s really hard to read and maintain.&lt;/p&gt;&lt;p&gt;I&#x27;m looking for something better.&lt;/p&gt;&lt;p&gt;My hope is to have a system where I can write functions in more or less normal python fashion, and then when the script is run, have options (and help text) generated from my functions, parsed, and executed in the appropriate order. Additionally, I&#x27;d REALLY like to be able to build django-style sub-command interfaces, where &lt;code&gt;myscript.py install&lt;/code&gt; works completely separately from &lt;code&gt;myscript.py remove&lt;/code&gt; (separate options, help, etc.)&lt;/p&gt;&lt;p&gt;I&#x27;ve found &lt;a href=&quot;http://github.com/simonw/optfunc/tree/master&quot; rel=&quot;nofollow noreferrer&quot;&gt;simon willison&#x27;s optfunc&lt;/a&gt; and it does a lot of this, but seems to just miss the mark â€” I want to write each OPTION as a function, rather than try to compress the whole option set into a huge string of options. &lt;/p&gt;&lt;p&gt;I imagine an architecture involving a set of classes for major functions, and each defined method of the class corresponding to a particular option in the command line. This structure provides the advantage of having each option reside near the functional code it modifies, easing maintenance. The thing I don&#x27;t know quite how to deal with is the ordering of the commands, since the ordering of class methods is not deterministic.&lt;/p&gt;&lt;p&gt;Before I go reinventing the wheel: Are there any other existing bits of code that behave similarly? Other things that would be easy to modify? Asking the question has clarified my own thinking on what would be nice, but feedback on why this is a terrible idea, or how it should work would be welcome.&lt;/p&gt;</Body>
<Tags>python,command-line,parsing</Tags>
</question>
<answer>
<Body>&lt;p&gt;Don&#x27;t waste time on &quot;introspection&quot;.  &lt;/p&gt;&lt;p&gt;Each &quot;Command&quot; or &quot;Option&quot; is an object with two sets of method functions or attributes.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Provide setup information to optparse.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Actually do the work.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Here&#x27;s the superclass for all commands&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Command( object ):    name= &quot;name&quot;    def setup_opts( self, parser ):        &quot;&quot;&quot;Add any options to the parser that this command needs.&quot;&quot;&quot;        pass    def execute( self, context, options, args ):        &quot;&quot;&quot;Execute the command in some application context with some options and args.&quot;&quot;&quot;        raise NotImplemented&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You create sublcasses for &lt;code&gt;Install&lt;/code&gt; and &lt;code&gt;Remove&lt;/code&gt; and every other command you need.&lt;/p&gt;&lt;p&gt;Your overall application looks something like this.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;commands = [     Install(),    Remove(),]def main():    parser= optparse.OptionParser()    for c in commands:        c.setup_opts( parser )    options, args = parser.parse()    command= None    for c in commands:        if c.name.startswith(args[0].lower()):            command= c            break    if command:        status= command.execute( context, options, args[1:] )    else:        logger.error( &quot;Command %r is unknown&quot;, args[0] )        status= 2    sys.exit( status )&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The WSGI library werkzeug provides &lt;strong&gt;&lt;a href=&quot;http://werkzeug.pocoo.org/documentation/dev/script.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Management Script Utilities&lt;/a&gt;&lt;/strong&gt; which may do what you want, or at least give you a hint how to do the introspection yourself.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;from werkzeug import script# actions go heredef action_test():    &quot;sample with no args&quot;    passdef action_foo(name=2, value=&quot;test&quot;):    &quot;do some foo&quot;    passif __name__ == &#x27;__main__&#x27;:    script.run()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Which will generate the following help message:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ python /tmp/test.py --helpusage: test.py &amp;lt;action&amp;gt; [&amp;lt;options&amp;gt;]       test.py --helpactions:  foo:    do some foo    --name                        integer   2    --value                       string    test  test:    sample with no args&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An action is a function in the same module starting with &quot;action_&quot; which takes a number of arguments where every argument has a default. The type of the default value specifies the type of the argument.&lt;/p&gt;&lt;p&gt;Arguments can then be passed by position or using --name=value from the shell.&lt;/p&gt;</Body>
</answer>
</qroot>
