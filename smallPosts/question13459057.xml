<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>std::initializer_list variations</Title>
<Body>&lt;p&gt;What are the differences between the following three initializations with &lt;code&gt;std::initializer_list&lt;/code&gt;s?&lt;/p&gt;&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;int&amp;gt; a{ 2, 3, 5, 7};std::vector&amp;lt;int&amp;gt; b( { 2, 3, 5, 7} );std::vector&amp;lt;int&amp;gt; c = { 2, 3, 5, 7};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the above example, &lt;code&gt;std::vector&lt;/code&gt; is just a placeholder, but I am interested in a general answer.&lt;/p&gt;</Body>
<Tags>c++,syntax,c++11,initialization,initializer-list</Tags>
</question>
<answer>
<Body>&lt;p&gt;I played a bit on gcc 4.7.2 with a custom class taking &lt;code&gt;std::initializer_list&lt;/code&gt; in a constructor. I tried all those scenarios and more. It seems there is really no difference in observable results on that compiler for those 3 statements.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt; This is exact code I used for testing:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;initializer_list&amp;gt;class A {public:  A()                    { std::cout &amp;lt;&amp;lt; &quot;A::ctr\n&quot;; }  A(const A&amp;amp;)            { std::cout &amp;lt;&amp;lt; &quot;A::ctr_copy\n&quot;; }  A(A&amp;amp;&amp;amp;)                 { std::cout &amp;lt;&amp;lt; &quot;A::ctr_move\n&quot;; }  A &amp;amp;operator=(const A&amp;amp;) { std::cout &amp;lt;&amp;lt; &quot;A::=_copy\n&quot;; return *this; }  A &amp;amp;operator=(A&amp;amp;&amp;amp;)      { std::cout &amp;lt;&amp;lt; &quot;A::=_move\n&quot;; return *this; }  ~A()                   { std::cout &amp;lt;&amp;lt; &quot;A::dstr\n&quot;; }};class B {  B(const B&amp;amp;)            { std::cout &amp;lt;&amp;lt; &quot;B::ctr_copy\n&quot;; }  B(B&amp;amp;&amp;amp;)                 { std::cout &amp;lt;&amp;lt; &quot;B::ctr_move\n&quot;; }  B &amp;amp;operator=(const B&amp;amp;) { std::cout &amp;lt;&amp;lt; &quot;B::=copy\n&quot;; return *this; }  B &amp;amp;operator=(B&amp;amp;&amp;amp;)      { std::cout &amp;lt;&amp;lt; &quot;B::=move\n&quot;; return *this; }public:  B(std::initializer_list&amp;lt;A&amp;gt; init) { std::cout &amp;lt;&amp;lt; &quot;B::ctr_ user\n&quot;; }  ~B()                             { std::cout &amp;lt;&amp;lt; &quot;B::dstr\n&quot;; }};int main(){  B a1{ {}, {}, {} };  B a2({ {}, {}, {} });  B a3 = { {}, {}, {} };  // B a4 = B{ {}, {}, {} }; // does not compile on gcc 4.7.2, gcc 4.8 and clang (top version)  std::cout &amp;lt;&amp;lt; &quot;--------------------\n&quot;;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;a1&lt;/code&gt;, &lt;code&gt;a2&lt;/code&gt; and &lt;code&gt;a3&lt;/code&gt; compiles fine on gcc 4.7.2, gcc 4.8 and the latest clang. I also do not see any observable results between the number of operations done on list members for all 3 cases. The last case (not from question) does not compile if I make &lt;code&gt;B&lt;/code&gt; copy/move constructor private/deleted.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;In the above example, std::vector is just a placeholder, I am interested in a general answer.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;How &quot;general&quot; of an answer do you want? Because what that means &lt;em&gt;really&lt;/em&gt; depends on what the type you&#x27;re initializing is and what constructors they have.&lt;/p&gt;&lt;p&gt;For example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;T a{ 2, 3, 5, 7};T b( { 2, 3, 5, 7} );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These &lt;em&gt;may&lt;/em&gt; be two different things. Or they may not. It depends on what constructors &lt;code&gt;T&lt;/code&gt; has. If &lt;code&gt;T&lt;/code&gt; has a constructor that takes a single &lt;code&gt;initializer_list&amp;lt;int&amp;gt;&lt;/code&gt; (or some other &lt;code&gt;initializer_list&amp;lt;U&amp;gt;&lt;/code&gt;, where &lt;code&gt;U&lt;/code&gt; is an integral type), then both of these will call that constructor.&lt;/p&gt;&lt;p&gt;However, if it doesn&#x27;t have that, then these two will do different things. The first, will attempt to call a constructor that takes 4 arguments that can be generated by integer literals. The second will attempt to call a constructor that takes &lt;em&gt;one argument&lt;/em&gt;, which it will try to initialize with &lt;code&gt;{2, 3, 5, 7}&lt;/code&gt;. This means that it will go through each one-argument constructor, figure out what the type for that argument is, and attempt to construct it with &lt;code&gt;R{2, 3, 5, 7}&lt;/code&gt; If none of those work, then it will attempt to pass it as an &lt;code&gt;initializer_list&amp;lt;int&amp;gt;&lt;/code&gt;. And if that doesn&#x27;t work, then it fails.&lt;/p&gt;&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt; constructors always have priority.&lt;/p&gt;&lt;p&gt;Note that the &lt;code&gt;initializer_list&lt;/code&gt; constructors are only in play because &lt;code&gt;{2, 3, 5, 7}&lt;/code&gt; is a braced-init-list where every element has the same type. If you had &lt;code&gt;{2, 3, 5.3, 7.9}&lt;/code&gt;, then it wouldn&#x27;t check &lt;code&gt;initializer_list&lt;/code&gt; constructors.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;T c = { 2, 3, 5, 7};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will behave like &lt;code&gt;a&lt;/code&gt;, save for what kinds of conversions it will do. Since this is copy-list-initialization, it will attempt to call an initializer_list constructor. If no such constructor is available, it will attempt to call a 4-argument constructor, but it will only allow &lt;em&gt;implicit conversions&lt;/em&gt; of its for arguments into the type parameters.&lt;/p&gt;&lt;p&gt;That&#x27;s the only difference. It doesn&#x27;t require copy/move constructors or anything (the specification only mentions copy-list-initialization in 3 places. None of them forbid it when copy/move construction is unavailable). It is almost exactly equivalent to &lt;code&gt;a&lt;/code&gt; except for the kind of conversion it allows on its arguments.&lt;/p&gt;&lt;p&gt;This is why it&#x27;s commonly called &quot;uniform initialization&quot;: because it works almost the same way everywhere.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Traditionally (C++98/03), initialization like &lt;code&gt;T x(T());&lt;/code&gt; invoked direct initialization, and initialization like &lt;code&gt;T x = T();&lt;/code&gt; invoked copy initialization. When you used copy initialization, the copy ctor was required to be present available, even though it might not (i.e., usually wasn&#x27;t) used.&lt;/p&gt;&lt;p&gt;Initializer lists kind of change that. Looking at §8.5/14 and §8.5/15 shows that the terms &lt;em&gt;direct-initialization&lt;/em&gt; and &lt;em&gt;copy-initialization&lt;/em&gt; still apply -- but looking at §8.5/16, we find that for a braced init list, this is a distinction without a difference, at least for your first and third examples:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;— If the initializer is a (non-parenthesized) braced-init-list, the object or reference is list-initialized (8.5.4).&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;As such, the actual initialization for your first and third examples is done identically, and neither requires a copy ctor (or move ctor). In both cases, we&#x27;re dealing with the fourth bullet in §8.5.4/3:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;— Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;... so both use &lt;code&gt;std::vector&lt;/code&gt;&#x27;s ctor that takes an &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; as its argument.&lt;/p&gt;&lt;p&gt;As noted in the quote above, however, that only deals with a &quot;(non-parenthesized) braced-init-list&quot;. For your second example with a parenthesized braced-init-list, we get to the first sub-bullet of the sixth bullet (geeze -- really need to talk to somebody about adding numbers for those) of §8.5/16:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;— If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Since this uses the syntax for direct initialization, and the expression inside the parentheses is a braced-initializer-list, and &lt;code&gt;std::vector&lt;/code&gt; has a ctor that takes an initializer list, that&#x27;s the overload that&#x27;s selected.&lt;/p&gt;&lt;p&gt;Bottom line: although the routes through the standard to get there are different, all three end up using &lt;code&gt;std::vector&lt;/code&gt;&#x27;s constructor overload for &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;. From any practical viewpoint, there&#x27;s no difference between the three. All three will invoke &lt;code&gt;vector::vector(std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt;, with no copies or other conversions happening (not even ones that are likely to be elided and really happen only in theory).&lt;/p&gt;&lt;p&gt;I believe with slightly different values, however, there is (or at least may be) one minor difference. The prohibition against narrowing conversions is in §8.5.4/3, so your second example (which doesn&#x27;t go through §8.5.4/3, so to speak) should probably allow narrowing conversions, where the other two clearly do not. Even if I were an inveterate gambler, however, I wouldn&#x27;t bet a thing on a compiler actually recognizing this distinction and allowing the narrowing conversion in the one case but not the others (I find it a little surprising, and rather doubt that it&#x27;s intended to be allowed).&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Let&#x27;s abstract away from &lt;code&gt;std::vector&lt;/code&gt;. And call it &lt;code&gt;T&lt;/code&gt;. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;T t{a, b, c};T t = { a, b, c };T t({a, b, c});&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The first two forms are list initialization (and the &lt;em&gt;only&lt;/em&gt; difference between them is that if &lt;code&gt;T&lt;/code&gt; is a class, for the second &lt;code&gt;explicit&lt;/code&gt; constructors are forbidden to be called. If one is called, the program becomes ill-formed). The last form is just ordinary direct initialization as we know it from C++03:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;T t(arg);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That there appears a &lt;code&gt;{a, b, c}&lt;/code&gt; as &lt;em&gt;arg&lt;/em&gt; means that the argument for the constructor call is a brace initializer list. This third form does not have the special handling that list initialization has. &lt;code&gt;T&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be a class type there, even if the braced init list has only 1 argument. I&#x27;m glad that &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1214&quot; rel=&quot;nofollow&quot;&gt;we put clear rules&lt;/a&gt; before releasing C++11 in this case. &lt;/p&gt;&lt;hr&gt;&lt;p&gt;As in terms of what constructors are called for the third, let&#x27;s assume&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct T {  T(int);  T(std::initializer_list&amp;lt;int&amp;gt;);};T t({1});&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since a direct initialization is just a call to the overloaded constructors, we can transform this to&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void ctor(int); void ctor(std::initializer_list&amp;lt;int&amp;gt;);void ctor(T const&amp;amp;);void ctor(T &amp;amp;&amp;amp;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can use both trailing functions, but we would need a user defined conversion if we picked these functions. To initialize the &lt;code&gt;T ref&lt;/code&gt; parameter, list initialization will be used because this is not a direct initialization with parens (so the parameter initialization is equivalent to &lt;code&gt;T ref t = { 1 }&lt;/code&gt;). The first two functions are exact matches. However, the Standard says that in such a case, when one function converts to &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; and the other does not, then the former function wins. Therefor in this scenario, the second &lt;code&gt;ctor&lt;/code&gt; would be used. &lt;em&gt;Note that in this scenario, we will not do two-phase overload resolution with first only initializer list ctors - only list initialization will do that&lt;/em&gt;. &lt;/p&gt;&lt;hr&gt;&lt;p&gt;For the first two, we will use list-initialization, and it will do context dependent things. If &lt;code&gt;T&lt;/code&gt; is an array, it will initialize an array. Take this example for a class&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct T {  T(long);  T(std::initializer_list&amp;lt;int&amp;gt;);};T t = { 1L };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, we do &lt;em&gt;two-phase overload resolution&lt;/em&gt;. We first only consider initializer list constructors and see if one matches, as argument we take the whole braced init list. The second ctor matches, so we pick it. We will ignore the first constructor. If we have no initializer list ctor or if none matches, we take all ctors and the elements of the initializer list&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct T {  T(long);  template&amp;lt;typename A = std::initializer_list&amp;lt;int&amp;gt;&amp;gt;  T(A);};T t = { 1L };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case we pick the first constructor, because &lt;code&gt;1L&lt;/code&gt; cannot be converted to &lt;code&gt;std::initializer_list&amp;lt;int&amp;gt;&lt;/code&gt;.&lt;/p&gt;</Body>
</answer>
</qroot>
