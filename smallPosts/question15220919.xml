<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>std::vector constructor - why int and not int*?</Title>
<Body>&lt;p&gt;I know that the following code can build a stl vector from an array:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  // the iterator constructor can also be used to construct from arrays:  int myints[] = {16,2,77,29};  std::vector&amp;lt;int&amp;gt; fifth (myints, myints + sizeof(myints) / sizeof(int) );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(source: &lt;a href=&quot;http://www.cplusplus.com/reference/vector/vector/vector/&quot; rel=&quot;nofollow&quot;&gt;cppreference&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;the constructor used should be&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template &amp;lt;class InputIterator&amp;gt;         vector (InputIterator first, InputIterator last,                 const allocator_type&amp;amp; alloc = allocator_type());&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;if &lt;em&gt;&amp;lt; class InputIterator &gt;&lt;/em&gt; is &lt;em&gt;&amp;lt; int &gt;&lt;/em&gt; in the above example, why isn&#x27;t the &lt;em&gt;InputIterator first&lt;/em&gt; an integer pointer? The array name &quot;myints&quot; decays into a pointer to the first element because it&#x27;s equivalent to &amp;amp;myints[0]&lt;/p&gt;&lt;p&gt;I thought a correct version would be &lt;/p&gt;&lt;pre&gt;&lt;code&gt;template &amp;lt;class InputIterator&amp;gt;         vector (InputIterator *first, InputIterator *last,                 const allocator_type&amp;amp; alloc = allocator_type());&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++,templates,stl</Tags>
</question>
<answer>
<Body>&lt;p&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/container/vector&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;std::vector&lt;/code&gt;&lt;/a&gt; is declared something like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template &amp;lt;class T, class Allocator = std::allocator&amp;lt;T&amp;gt;&amp;gt;class Vector{  // ...  typedef Allocator allocator_type;  template &amp;lt;class InputIterator&amp;gt;  vector(InputIterator first, InputIterator last,         const allocator_type&amp;amp; = alocator_type());  // ...};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that both the class itself and the constructor have template paremeters. When you create your &lt;code&gt;std::vector&amp;lt;int&amp;gt;&lt;/code&gt;, the &lt;code&gt;int&lt;/code&gt; template argument is for the class template paremeter &lt;code&gt;T&lt;/code&gt;, determining the types of elements of the vector, not for the constructor&#x27;s &lt;code&gt;InputIterator&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;You are allowing &lt;code&gt;InputIterator&lt;/code&gt; to be deduced by the compiler (in fact, a constructor&#x27;s template parameters must be deduced). Your are passing &lt;code&gt;myints&lt;/code&gt; as the first argument to the function which is going to deduce &lt;code&gt;InputIterator&lt;/code&gt;. Since &lt;code&gt;myints&lt;/code&gt; decays to an &lt;code&gt;int*&lt;/code&gt; to the first element of your array, as you say, then &lt;code&gt;InputIterator&lt;/code&gt; will be deduced to be an &lt;code&gt;int*&lt;/code&gt; and you get the following instantiation of the constructor:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vector (int* first, int* last,        const allocator_type&amp;amp; alloc = allocator_type());&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;InputIterator&lt;/code&gt; is not deduced to be &lt;code&gt;int&lt;/code&gt;. It&#x27;s deduced to be the full type that you pass as the first argument (and the second argument must match, of course).&lt;/p&gt;&lt;p&gt;This makes sense because an &lt;code&gt;int&lt;/code&gt; is not a valid Input Iterator. Whatever &lt;code&gt;InputIterator&lt;/code&gt; is deduced as must meet the requirements of an Input Iterator. An &lt;code&gt;int*&lt;/code&gt; however, is valid.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;&lt;code&gt;&amp;lt;class InputIterator&amp;gt;&lt;/code&gt; cannot be &lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt; because you cannot dereference (apply &lt;code&gt;operator*()&lt;/code&gt;) an &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;You&#x27;re confusing the templated type of the vector (&lt;code&gt;int&lt;/code&gt; in your case) with the templated type of the constructor&#x27;s parameter. The constructor for &lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; takes a first parameter of type &lt;code&gt;InputIterator&lt;/code&gt;-yielding-&lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;That is - &lt;code&gt;&amp;lt;class InputIterator&amp;gt;&lt;/code&gt; is not &lt;code&gt;int&lt;/code&gt;; it&#x27;s an iterator that dereferences to &lt;code&gt;int&lt;/code&gt;; such as &lt;code&gt;int*&lt;/code&gt;&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;This is because Iterators are not always pointers. Or put the other way: most Iterators are &lt;em&gt;not&lt;/em&gt; pointers and therefore the signature you propose would not apply to them.&lt;/p&gt;&lt;p&gt;So in your case, &lt;code&gt;InputIterator&lt;/code&gt; is &lt;code&gt;int*&lt;/code&gt; which is perfectly understandable, since the concept of iterators initially was invented as a broader notion of &quot;pointer range&quot;.&lt;/p&gt;</Body>
</answer>
</qroot>
