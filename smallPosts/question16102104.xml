<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Java ByteArray equivalent in C or C++</Title>
<Body>&lt;p&gt;What are the equivalent for java byte in C,C++ &lt;/p&gt;&lt;pre&gt;&lt;code&gt;byte[]  itemsArray;itemsArray = new byte[items *no];itemsArray[x] = (byte) xyz;unsigned char * itemsArray;itemsArray = (unsigned char*) malloc (items*no);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How to assign bytes to &lt;code&gt;itemsArray&lt;/code&gt; (like  &lt;code&gt;itemsArray[x] = (byte) xyz&lt;/code&gt; ) in C++ with endianess to ensure the proper byteorder.&lt;/p&gt;&lt;p&gt;Are the above things equivalent to byteArray in C ?&lt;/p&gt;</Body>
<Tags>java,c++,c,byte,bytearray</Tags>
</question>
<answer>
<Body>&lt;p&gt;Use &lt;code&gt;memcpy()&lt;/code&gt; to copy buffers between memories in &lt;code&gt;C&lt;/code&gt;. &lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Yes they are equivalent&lt;/p&gt;&lt;p&gt;I just wanted to point that it is a really good idea to always init your variables:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;unsigned char * itemsArray = (unsigned char*) malloc (numberOfItems);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;or&lt;/p&gt;&lt;pre&gt;&lt;code&gt;unsigned char * itemsArray = NULL;itemsArray = (unsigned char*) malloc (numberOfItems);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you are a bit paranoid:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;unsigned char * itemsArray = (unsigned char*) malloc (numberOfItems);if(itemsArray == NULL) {    //Error, not enough memory}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And in c++ you should use new/delete instead of malloc/free (note that in C++ you CAN use malloc/free, but don&#x27;t mix them with new/delete)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;unsigned char * itemsArray = new unsigned char[items*no];&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;&lt;code&gt;signed char&lt;/code&gt; is equivalent to Java byte on most platforms - the C/C++ standard doesn&#x27;t actually require this, but you can rely on chars being 8-bit on all but the most obscure platforms/compilers. &lt;code&gt;char&lt;/code&gt;, regardless of signedness, corresponds to the smallest addressable unit on most platforms, so you shouldn&#x27;t have to worry about endianness at all.&lt;/p&gt;&lt;p&gt;You would assign to the array just like you would to any other array - in your example &lt;code&gt;itemsArray[x] = (unsigned char) xyz&lt;/code&gt;. Note, though, that Java&#x27;s bytes are signed - I&#x27;m not sure if you intended to have &lt;code&gt;unsigned&lt;/code&gt; in there. As noted in the comments, if you&#x27;re using the array to store binary data, it is indeed customary to use &lt;code&gt;unsigned char&lt;/code&gt;.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Yes, they are roughly equivalent.  Java of course stores the length of the array and does bounds checks on each array reference.  C/C++ do not, at least not without extra work.&lt;/p&gt;&lt;p&gt;I tend to use &lt;code&gt;int8_t&lt;/code&gt; and &lt;code&gt;uint8_t&lt;/code&gt; when dealing with numeric byte values in C (include &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; to get the typedefs) (see &lt;a href=&quot;http://www.cplusplus.com/reference/cstdint/&quot; rel=&quot;nofollow&quot;&gt;http://www.cplusplus.com/reference/cstdint/&lt;/a&gt; for more).  It is equivalent to &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;, but I find it to be more explicit that the code is working on bytes.  Both &lt;code&gt;int8_t&lt;/code&gt; and &lt;code&gt;signed char&lt;/code&gt; are equivalent to Java&#x27;s &lt;code&gt;byte&lt;/code&gt; since all numeric values in Java are signed.&lt;/p&gt;&lt;p&gt;Big/little-endian only come into play when you want to write a multi-byte value to the array.  If you want to be on the safe-side, follow the same pattern you&#x27;d use in Java.  E.g.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/* example of storing in big-endian */bytes[i+0] = (int8_t)(myint &amp;gt;&amp;gt; 24);bytes[i+1] = (int8_t)(myint &amp;gt;&amp;gt; 16);bytes[i+2] = (int8_t)(myint &amp;gt;&amp;gt; 8);bytes[i+3] = (int8_t)(myint);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to avoid the extra shifts and write directly to the byte array, you can cast the byte array pointer to an int array and store, BUT you will run into two potential issues: (1) the endian issue you pointed out (solvable with a &lt;code&gt;htonl&lt;/code&gt; unless you&#x27;re not switching endians, see &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/007908775/xns/htonl.html&quot; rel=&quot;nofollow&quot;&gt;http://pubs.opengroup.org/onlinepubs/007908775/xns/htonl.html&lt;/a&gt;), and (2) storage alignment issues.  If you attempt to store/read an unaligned value, on some systems you&#x27;ll get a bus-error and your program will crash.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/* only do this if &#x27;i&#x27; is a multiple of 4! */*((uint32_t*)&amp;amp;bytes[i]) = htonl(myint);  &lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
