<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Vector of changing amount of class objects</Title>
<Body>&lt;p&gt;I have a situation where I have a bunch of class objects whose member variables I need to update over time.  The amount of objects I need to have can increase and decrease, and do so rapidly throughout my program&#x27;s.  Because I need to have a resizable array of class objects, I chose to use std::vector.  Problem is, my current code crashes after about a minute or so of execution (I&#x27;m assuming memory leak or something, but I don&#x27;t know for sure).  Here&#x27;s an example program I wrote to demonstrate what I am doing:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;Windows.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; char* names[] = {&quot;Larry&quot;, &quot;Bob&quot;, &quot;xXx_Quicksc0p3zl33t_xXx&quot;, &quot;InsertUnoriginalNameHere&quot;, &quot;Idunno&quot;};class CEnt{public:    const char* name;    int         health;};std::vector&amp;lt;CEnt&amp;gt;   entities;int main(){    while (1)    {        int iEntCount = rand() % 1000 + 1;  //Generate random value from 1000 to 2000.  This simulates the changing ingame entity count that I grab        if (entities.size() != iEntCount)        {            entities.resize(iEntCount);        }        //Print.ToConsole(TYPE_NOTIFY, &quot;%i&quot;, iEntCount);        for (int iIndex = 0; iIndex &amp;lt; iEntCount; iIndex++)        {            CEnt&amp;amp; Ent = entities[iIndex];            Ent.health =    rand() % 100 + 1;   //Generate random value to fill the objects.  This simulates when I grab values from ingame entities and put them in each object            Ent.name =      names[rand() % 5 + 1];            printf(&quot;Index: %i    Name: %s  Health: %i\n&quot;, iIndex, entities[iIndex].name, entities[iIndex].health);        }    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It looks sloppy and it is, but it demonstrates what I am doing.  Is there a better way to achieve this?  I need to access a container at random points in my code that contains the last updated variables for each object in my vector.&lt;/p&gt;</Body>
<Tags>c++,class,object,vector</Tags>
</question>
<answer>
<Body>&lt;p&gt;One thing that looks suspicious is the &lt;/p&gt;&lt;pre&gt;&lt;code&gt;        Ent.name =      names[rand() % 5 + 1];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;that is going to choose a value in the range 1..5.  But the highest valid name is &lt;code&gt;names[4]&lt;/code&gt;, and it will read off the end of the array.&lt;/p&gt;&lt;p&gt;I would expect that will make it crash immediately or not at all, but it&#x27;s possible there&#x27;s some other variable there that changes and eventually becomes an invalid pointer.&lt;/p&gt;&lt;p&gt;One slightly better way to write that would be &lt;/p&gt;&lt;pre&gt;&lt;code&gt;const int n_names = sizeof(names)/sizeof(*names);....    Ent.name =      names[rand() % n_names];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;although better style might be to put the names themselves in a vector, etc.  See for example &lt;a href=&quot;https://stackoverflow.com/q/1898657/243712&quot;&gt;this question&lt;/a&gt; and its many many dupes&lt;/p&gt;</Body>
</answer>
</qroot>
