<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>std::sort giving very strange results</Title>
<Body>&lt;p&gt;I have managed to find a reproducible example of the strange behaviour I am seeing with &lt;code&gt;std::sort&lt;/code&gt;&lt;/p&gt;&lt;p&gt;I am trying to sort a list of pairs, where it should be sorted on the second element. The list of the second elements is &lt;code&gt;[1 1 1 1 3 1 1 1 1 1 1 3 2 1 1 5 2 1 7 1]&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Below is my code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;std::vector&amp;lt;pair&amp;lt;int, double&amp;gt; &amp;gt; pairs;for (int i = 0; i &amp;lt; 4; i++) {    pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 1));}pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 3));for (int i = 0; i &amp;lt; 6; i++) {    pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 1));}pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 3));pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 2));pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 1));pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 1));pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 5));pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 2));pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 1));pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 7));pairs.push_back(pair&amp;lt;int, double&amp;gt;(1, 1));&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and the sorting function is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;struct descending_sort {    bool operator()(pair&amp;lt;T, double&amp;gt; const &amp;amp; a, pair&amp;lt;T, double&amp;gt; const &amp;amp; b) const {        cout &amp;lt;&amp;lt; &quot;sorting (&quot; &amp;lt;&amp;lt; a.second &amp;lt;&amp;lt; &quot; , &quot; &amp;lt;&amp;lt; b.second &amp;lt;&amp;lt; &quot;)&quot; &amp;lt;&amp;lt; std::endl;        return a.second &amp;gt;= b.second;    }};descending_sort &amp;lt; int &amp;gt; d = descending_sort&amp;lt;int&amp;gt;();std::sort(pairs.begin(), pairs.end(), d);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This produces the correct result, but when I examine a bit closely the output of the sort function at each step (what I print to console) I get some very interesting output.&lt;/p&gt;&lt;p&gt;The whole output can be found &lt;a href=&quot;http://pastebin.com/0WXg5s6f&quot; rel=&quot;nofollow&quot;&gt;here&lt;/a&gt; but there are some strange lines (i.e. line 46 in linked page) which read:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sorting (0 , 1)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But 0 does not appear in the input list. Why is this here?&lt;/p&gt;</Body>
<Tags>c++,stl</Tags>
</question>
<answer>
<Body>&lt;p&gt;Your code leads to undefined behavior, because &lt;code&gt;std::sort()&lt;/code&gt; requires a strict weak ordering, which &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; provides, but &lt;code&gt;&amp;gt;=&lt;/code&gt; does not provide because &lt;strong&gt;it violates the requirement to be antisymmetric&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;Regarding &lt;code&gt;strict weak ordering&lt;/code&gt;, it also include below properties&lt;/p&gt;&lt;p&gt;(1) &lt;strong&gt;antisymmetric&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;That for operator &amp;lt;: If x &amp;lt; y is true, then y &amp;lt; x is false.That for a predicate op(): If op(x,y) is true, then op(y,x) is false.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(2) &lt;strong&gt;transitive&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;that for operator &amp;lt;: If x &amp;lt; y is true and y &amp;lt; z is true, then x &amp;lt; z is true.   That for a predicate op(): If op(x,y) is true and op(y,z) is true, then op(x,z)is true.&lt;/p&gt;&lt;p&gt;(3) &lt;strong&gt;irreflexive&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;That for operator &amp;lt;: x &amp;lt; x is always false.That for a predicate op(): op(x,x) is always false.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(4) &lt;strong&gt;transitivity of equivalence&lt;/strong&gt;, which means roughly: If a is equivalent to b and b is equivalent to c, then a is equivalent to c. &lt;/p&gt;&lt;p&gt;§ 25.4.4&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;For all algorithms that take Compare, there is a version that uses operator&amp;lt; instead. That is, 1comp(*i,*j) != false1 defaults to *i &amp;lt; *j != false. &lt;strong&gt;For algorithms other than those described in 25.4.3 to work correctly, comp has to induce a strict weak ordering on the values.&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;To read more about &lt;a href=&quot;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&quot; rel=&quot;noreferrer&quot;&gt;strict weak ordering&lt;/a&gt;&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;In C++, the &quot;compare&quot; predicate must be a &lt;a href=&quot;http://www.sgi.com/tech/stl/StrictWeakOrdering.html&quot; rel=&quot;nofollow&quot;&gt;&lt;strong&gt;strict weak ordering&lt;/strong&gt;&lt;/a&gt;. For example, the case &lt;code&gt;descending_sort( X, X )&lt;/code&gt; (both pairs identical) should always return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Also, on this &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/sort&quot; rel=&quot;nofollow&quot;&gt;reference&lt;/a&gt;, it is said:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;&lt;strong&gt;comp&lt;/strong&gt; - comparison function which returns ​true if the first argument is &lt;strong&gt;&lt;em&gt;less&lt;/em&gt;&lt;/strong&gt; than the second.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;For you it means that in &lt;code&gt;descending_sort&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;return a.second &amp;gt;= b.second;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;should be&lt;/p&gt;&lt;pre&gt;&lt;code&gt;return a.second &amp;gt; b.second;&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
