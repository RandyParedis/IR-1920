<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>What is the fastest way to get the value of π?</Title>
<Body>&lt;p&gt;I&#x27;m looking for the fastest way to obtain the value of π, as a personal challenge. More specifically, I&#x27;m using ways that don&#x27;t involve using &lt;code&gt;#define&lt;/code&gt; constants like &lt;code&gt;M_PI&lt;/code&gt;, or hard-coding the number in.&lt;/p&gt;&lt;p&gt;The program below tests the various ways I know of. The inline assembly version is, in theory, the fastest option, though clearly not portable. I&#x27;ve included it as a baseline to compare against the other versions. In my tests, with built-ins, the &lt;code&gt;4 * atan(1)&lt;/code&gt; version is fastest on GCC 4.2, because it auto-folds the &lt;code&gt;atan(1)&lt;/code&gt; into a constant. With &lt;code&gt;-fno-builtin&lt;/code&gt; specified, the &lt;code&gt;atan2(0, -1)&lt;/code&gt; version is fastest.&lt;/p&gt;&lt;p&gt;Here&#x27;s the main testing program (&lt;code&gt;pitimes.c&lt;/code&gt;):&lt;/p&gt;&lt;pre class=&quot;lang-c prettyprint-override&quot;&gt;&lt;code&gt;#include &amp;lt;math.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;time.h&amp;gt;#define ITERS 10000000#define TESTWITH(x) {                                                       \    diff = 0.0;                                                             \    time1 = clock();                                                        \    for (i = 0; i &amp;lt; ITERS; ++i)                                             \        diff += (x) - M_PI;                                                 \    time2 = clock();                                                        \    printf(&quot;%s\t=&amp;gt; %e, time =&amp;gt; %f\n&quot;, #x, diff, diffclock(time2, time1));   \}static inline doublediffclock(clock_t time1, clock_t time0){    return (double) (time1 - time0) / CLOCKS_PER_SEC;}intmain(){    int i;    clock_t time1, time2;    double diff;    /* Warmup. The atan2 case catches GCC&#x27;s atan folding (which would     * optimise the ``4 * atan(1) - M_PI&#x27;&#x27; to a no-op), if -fno-builtin     * is not used. */    TESTWITH(4 * atan(1))    TESTWITH(4 * atan2(1, 1))#if defined(__GNUC__) &amp;amp;&amp;amp; (defined(__i386__) || defined(__amd64__))    extern double fldpi();    TESTWITH(fldpi())#endif    /* Actual tests start here. */    TESTWITH(atan2(0, -1))    TESTWITH(acos(-1))    TESTWITH(2 * asin(1))    TESTWITH(4 * atan2(1, 1))    TESTWITH(4 * atan(1))    return 0;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the inline assembly stuff (&lt;code&gt;fldpi.c&lt;/code&gt;) that will only work for x86 and x64 systems:&lt;/p&gt;&lt;pre class=&quot;lang-c prettyprint-override&quot;&gt;&lt;code&gt;doublefldpi(){    double pi;    asm(&quot;fldpi&quot; : &quot;=t&quot; (pi));    return pi;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And a build script that builds all the configurations I&#x27;m testing (&lt;code&gt;build.sh&lt;/code&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#!/bin/shgcc -O3 -Wall -c           -m32 -o fldpi-32.o fldpi.cgcc -O3 -Wall -c           -m64 -o fldpi-64.o fldpi.cgcc -O3 -Wall -ffast-math  -m32 -o pitimes1-32 pitimes.c fldpi-32.ogcc -O3 -Wall              -m32 -o pitimes2-32 pitimes.c fldpi-32.o -lmgcc -O3 -Wall -fno-builtin -m32 -o pitimes3-32 pitimes.c fldpi-32.o -lmgcc -O3 -Wall -ffast-math  -m64 -o pitimes1-64 pitimes.c fldpi-64.o -lmgcc -O3 -Wall              -m64 -o pitimes2-64 pitimes.c fldpi-64.o -lmgcc -O3 -Wall -fno-builtin -m64 -o pitimes3-64 pitimes.c fldpi-64.o -lm&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Apart from testing between various compiler flags (I&#x27;ve compared 32-bit against 64-bit too because the optimizations are different), I&#x27;ve also tried switching the order of the tests around. But still, the &lt;code&gt;atan2(0, -1)&lt;/code&gt; version still comes out on top every time.&lt;/p&gt;</Body>
<Tags>performance,algorithm,language-agnostic,unix,pi</Tags>
</question>
<answer>
<Body>&lt;p&gt;Here&#x27;s a general description of a technique for calculating pi that I learnt in high school.&lt;/p&gt;&lt;p&gt;I only share this because I think it is simple enough that anyone can remember it, indefinitely, plus it teaches you the concept of &quot;Monte-Carlo&quot; methods -- which are statistical methods of arriving at answers that don&#x27;t immediately appear to be deducible through random processes.&lt;/p&gt;&lt;p&gt;Draw a square, and inscribe a quadrant (one quarter of a semi-circle) inside that square (a quadrant with radius equal to the side of the square, so it fills as much of the square as possible)&lt;/p&gt;&lt;p&gt;Now throw a dart at the square, and record where it lands -- that is, choose a random point anywhere inside the square. Of course, it landed inside the square, but is it inside the semi-circle? Record this fact.&lt;/p&gt;&lt;p&gt;Repeat this process many times -- and you will find there is a ratio of the number of points inside the semi-circle versus the total number thrown, call this ratio x.&lt;/p&gt;&lt;p&gt;Since the area of the square is r times r, you can deduce that the area of the semi circle is x times r times r (that is, x times r squared). Hence x times 4 will give you pi. &lt;/p&gt;&lt;p&gt;This is not a quick method to use. But it&#x27;s a nice example of a Monte Carlo method. And if you look around, you may find that many problems otherwise outside your computational skills can be solved by such methods.&lt;/p&gt;</Body>
</answer>
</qroot>
