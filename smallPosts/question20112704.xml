<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Imposing type safety on existing C intrusive linked lists</Title>
<Body>&lt;p&gt;I have a fairly simple set of doubly linked list helpers centered around two basic structs:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;typedef struct DoubleLinkedListNode_struct {   struct DoubleLinkedListNode_struct *m_prev;   struct DoubleLinkedListNode_struct *m_next;} DoubleLinkedListNode;typedef struct DoubleLinkedList_struct {   DoubleLinkedListNode m_anchor;} DoubleLinkedList;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These primitive pieces are used to construct intrusive linked lists in a whole host of structures and (now) classes.  I&#x27;m attempting to rework this set of structures and supporting functions with a whole ream of caveats and requirements.  If you want the background read the part below the &#x27;------&#x27; break.&lt;/p&gt;&lt;p&gt;My first attempt uses the old Node structures and provides a new type-safe List template:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;typename Type, DoubleLinkedListNode Type::*MP&amp;gt;struct NewDoubleLinkedList{   DoubleLinkedListNode m_anchor;   //static const int Offset = ((unsigned int)(&amp;amp;(((Type *)0)-&amp;gt;*MP))); ///&amp;lt;- broken   void pushBack(Type *inst) { DoubleLinkedList_pushBack(this,&amp;amp;(inst-&amp;gt;*MP)); }   Type *begin() { return GetObjectFromMember(Type,*MP,m_anchor.m_next); }   Type *end() { return GetObjectFromMember(Type,*MP,&amp;amp;m_anchor); }   Type *getNext(Type *from) { return GetObjectFromMember(Type,*MP,from-&amp;gt;*MP.m_next); }};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And this template is used like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct MyClient {   DoubleLinkedListNode m_serviceNode;};void testNewList(){   NewDoubleLinkedList&amp;lt;MyClient,&amp;amp;MyClient::m_serviceNode&amp;gt; newList;   MyClient testClient;   newList.pushBack(&amp;amp;testClient);   MyClient *client = newList.begin();   while(client != newList.end()) {      ASSERT(client == &amp;amp;testClient);      client = newList.getNext(client);   }   DoubleLinkedListNode_remove(&amp;amp;testClient.m_serviceNode);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This all seems to work, and complains correctly, except this code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   static const int Offset = ((unsigned int)(&amp;amp;(((Type *)0)-&amp;gt;*MP))); &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which is intended to fail (at compile time) only if instance-&gt;*MP can&#x27;t be resolved at compile time (i.e. it relies on the instance&#x27;s virtual table, due to virtual inheritance).&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Is there some way I can fix this code, or some alternate way to prevent potential confusion with virtual inheritance?&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;On the off chance you think I&#x27;m on the complete wrong path I&#x27;ve included the (overly long) background on what I&#x27;m doing and my requirements below).  Otherwise just &lt;strong&gt;stop here&lt;/strong&gt;.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;First, I&#x27;m going to stress that this is existing code written in C.  It&#x27;s used all over the place so I need a method which allows slow roll-out without having to rewrite every piece of code that uses the list structures at once.&lt;/p&gt;&lt;p&gt;The typical use case usually goes something like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct MyService {   ...  //other backend service data   DoubleLinkedList m_clientList;}struct MyClient {   ...  //other client service data   MyService *m_serviceProvider;   DoubleLinkedListNode m_serviceNode;   DoubleLinkedListNode m_wrongServiceNode;   void (*v_doSomethingLater)( MyClient *);  //&quot;virtual&quot; function}void Client_requestService( MyClient *client ){   ...  //prep work for service request   DoubleLinkedList_pushBack( &amp;amp;client-&amp;gt;m_serviceProvider.m_clientList,                              &amp;amp;client-&amp;gt;m_serviceNode );}void Service_handleClients( MyService *service ){    DoubleLinkedListNode *iter = DoubleLinkedList_begin(&amp;amp;service-&amp;gt;m_clientList);    DoubleLinkedListNode *end = DoubleLinkedList_end(&amp;amp;service-&amp;gt;m_clientList);    while(iter != end) {       MyClient *client = GetObjectFromMember( MyClient, m_serviceNode, iter );       iter = DoubleLinkedListNode_getNext(iter);       client-&amp;gt;v_doSomethingLater(client);    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The (uber evil and absolutely everywhere) macro GetObjectFromMember takes (TypeName,memberName,memberPointer) and returns a Typed pointer such that:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   TypeName *result = GetObjectFromMember(TypeName,memberName,memberPointer);   ASSERT(&amp;amp;result-&amp;gt;memberName == memberPointer);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For the truly masochistic it looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  #define GetObjectFromMember(ObjectType,MemberName,MemberPointer) \              ((ObjectType *)(((char *)MemberPointer) - ((char *)(&amp;amp;(((ObjectType *)0)-&amp;gt;MemberName)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;My goal is to find the least intrusive way to write some templates that can add type safety to the spots in this code most prone to error:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   DoubleLinkedList_pushBack( &amp;amp;client-&amp;gt;m_serviceProvider.m_clientList,                              &amp;amp;client-&amp;gt;m_serviceNode );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where someone might accidentally use the wrong node, like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   DoubleLinkedList_pushBack( &amp;amp;client-&amp;gt;m_serviceProvider.m_clientList,                              &amp;amp;client-&amp;gt;m_wrongServiceNode );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which compiles cleanly and leads to a catastrophe during the callback phase where we do:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   MyClient *client = GetObjectFromMember( MyClient, m_serviceNode, iter );   client-&amp;gt;v_doSomethingLater(client);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since the pointer derived by GetObjectFromMember will be wrong.&lt;/p&gt;&lt;p&gt;The other major problem is that since we are now doing C++, GetObjectFromMember works only if TypeName does not reach memberName via virtual inheritance.  I need whatever solution I come up with to fail at compile time if GetObjectFromMember isn&#x27;t safe.&lt;/p&gt;&lt;p&gt;So, the goals are:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;o-&gt;&lt;/strong&gt; Allow continued use of the existing DoubleLinkedListNode typename&lt;br/&gt;&lt;strong&gt;o-&gt;&lt;/strong&gt; Allow continued use of the existing DoubleLinkedList typename if possible (I suspect this isn&#x27;t possible)&lt;br/&gt;&lt;strong&gt;o-&gt;&lt;/strong&gt; Allow continued use of the existing macros (DoubleLinkedListNode_pushBack and (many) others).&lt;br/&gt;&lt;strong&gt;o-&gt;&lt;/strong&gt; Compile time errors for virtual inheritance which breaks the GetObjectFromMember usage&lt;br/&gt;&lt;strong&gt;o-&gt;&lt;/strong&gt; Use case where this:&lt;br/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;DoubleLinkedList_pushBack( &amp;amp;client-&amp;gt;m_serviceProvider.m_clientList,                           &amp;amp;client-&amp;gt;m_serviceNode );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;strong&gt;-&gt;&lt;/strong&gt; can be freely replaced with this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   client-&amp;gt;m_serviceProvider.m_clientList.pushBack(client);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;o-&gt;&lt;/strong&gt; Use case where the Service_handleClients call is reworked to look something like:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void Service_handleClients( MyFabulousService *service ){    MyClient *client = service-&amp;gt;m_clientList.begin();    while(client != service-&amp;gt;m_clientList.end()) {       MyClient *nextClient = service-&amp;gt;m_clientList.getNext(client);       client-&amp;gt;v_doSomethingLater(client);       client = nextClient;    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;o-&gt;&lt;/strong&gt; No dynamic allocation of any kind.&lt;br/&gt;&lt;strong&gt;o-&gt;&lt;/strong&gt; Not significantly (order of magnitude) larger (memory) or slower (cpu) than existing implementation.&lt;/p&gt;</Body>
<Tags>c++</Tags>
</question>
<answer>
<Body>&lt;p&gt;Fact 1: The expression &lt;code&gt;&amp;amp;Type::member&lt;/code&gt; has type &lt;code&gt;MemberType ClassType::*&lt;/code&gt;, where &lt;code&gt;ClassType&lt;/code&gt; is the class where &lt;code&gt;member&lt;/code&gt; is declared, not necessarily &lt;code&gt;Type&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Fact 2: It is legal (though not always safe) to &lt;code&gt;static_cast&lt;/code&gt; a reference or pointer from a base class to a derived class only if the base class is not a virtual base (nor an ambiguous base).  It seems to me that this is exactly the things you want to check at every use of &lt;code&gt;GetObjectFromMember&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;So how about:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Precondition: mptr points at the specified member of a ClassType object.// Precondition: member must not be in a virtual base class of ClassType.//// The second precondition is not an issue if the template arguments are// deduced from an &amp;amp;AnyClass::member expression, since ClassType will// deduce as the member&#x27;s actual enclosing class.template&amp;lt;typename ClassType, typename MemberType&amp;gt;ClassType* ObjectContainingMember(MemberType ClassType::*member,                                  MemberType *mptr){    ClassType* dummy = 0;    std::size_t member_offset =        reinterpret_cast&amp;lt;char*&amp;gt;(&amp;amp;(dummy-&amp;gt;*member)) -        reinterpret_cast&amp;lt;char*&amp;gt;(dummy);    char* obj_addr =        reinterpret_cast&amp;lt;char*&amp;gt;(mptr) - member_offset;    return reinterpret_cast&amp;lt;ClassType*&amp;gt;(obj_addr);}// Precondition: MemberPointer points at the specified member of// an ObjectType object.  Returns a pointer to that ObjectType.#define GetObjectFromMember(ObjectType,MemberName,MemberPointer)  \    static_cast&amp;lt;ObjectType*&amp;gt;(ObjectContainingMember(              \        &amp;amp;ObjectType::MemberName, MemberPointer))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Because of fact 1, the template parameter &lt;code&gt;ClassType&lt;/code&gt; will be deduced as the class where the member is declared.&lt;/p&gt;</Body>
</answer>
</qroot>
