<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Delayed evaluation of template type function</Title>
<Body>&lt;p&gt;I read &quot;The C++ Programming language 4th edition, 1st printing, by Bjarne Stroustrup&quot; book (from Amazon.com).Page 785.Stroustrup is explaining how he can eliminate explicit writing of &quot;&lt;strong&gt;::type&lt;/strong&gt;&quot;, when using &quot;&lt;strong&gt;std::conditional&lt;/strong&gt; + &lt;strong&gt;std::make_unsigned&lt;/strong&gt;&quot;, using &quot;&lt;strong&gt;type aliases&lt;/strong&gt;&quot; (keyword &quot;using&quot;). But that using &quot;type aliases&quot; on &quot;&lt;strong&gt;std::conditional&lt;/strong&gt; + &lt;strong&gt;std::make_unsigned&lt;/strong&gt;&quot; is causing compile errors. By now everything is as it should be. And he goes on to show how to elimintate these compile errors using &quot;delayed evaluation of template type function&quot;.&lt;/p&gt;&lt;p&gt;The question is on the line &lt;code&gt;Atype&amp;lt;make_unsigned&amp;lt;string&amp;gt;&lt;/code&gt; and &lt;code&gt;myType2&amp;lt;string&amp;gt; ...&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;I used g++ 4.8.2.&lt;/p&gt;&lt;h2&gt;Compile:&lt;/h2&gt;&lt;h2&gt;g++ -std=c++1y test45.cpp -o a&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;type_traits&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;typeinfo&amp;gt;  // for typeid(...)using namespace std;template&amp;lt;class T&amp;gt;struct ErrIndicator {   typedef ErrIndicator&amp;lt;T&amp;gt; type;};template&amp;lt;bool C, class T, class F&amp;gt;using Conditional = typename conditional&amp;lt;C,T,F&amp;gt;::type;template&amp;lt;typename T&amp;gt;using Make_unsigned = typename make_unsigned&amp;lt;T&amp;gt;::type;template&amp;lt;template&amp;lt;typename ...&amp;gt; class F, typename... Args&amp;gt;using Delay = F&amp;lt;Args ...&amp;gt;;template&amp;lt;class T&amp;gt;using myType1 = Conditional&amp;lt;is_integral&amp;lt;T&amp;gt;::value,    Make_unsigned&amp;lt;T&amp;gt;,    ErrIndicator&amp;lt;T&amp;gt;    &amp;gt;;template&amp;lt;class T&amp;gt;     using myType2 = Conditional&amp;lt;is_integral&amp;lt;T&amp;gt;::value,    Delay&amp;lt;Make_unsigned, T&amp;gt;,   // delayed evaluation    ErrIndicator&amp;lt;T&amp;gt;    &amp;gt;;template&amp;lt;class T&amp;gt;    using myType4 = Conditional&amp;lt;is_integral&amp;lt;T&amp;gt;::value,    make_unsigned&amp;lt;T&amp;gt;,    ErrIndicator&amp;lt;T&amp;gt;    &amp;gt;;template&amp;lt;typename T&amp;gt;class Atype {}; template&amp;lt;typename T&amp;gt;void func1(T &amp;amp;ia /* output param */) {  cout &amp;lt;&amp;lt; &quot;unsigned integral type&quot; &amp;lt;&amp;lt; endl;  ia = 4;  // &quot;unsigned integral type&quot; computation}template&amp;lt;typename T&amp;gt;void func1(ErrIndicator&amp;lt;T&amp;gt; &amp;amp;) {  cout &amp;lt;&amp;lt; &quot;non integral type: &quot; &amp;lt;&amp;lt; typeid(T).name() &amp;lt;&amp;lt; endl;}int main() {  myType1&amp;lt;int&amp;gt; var1a; // OK  // myType1&amp;lt;string&amp;gt; var1b; // Error; The book says error  //                    // should occur here. Here I understand.  myType2&amp;lt;int&amp;gt; var2a; // OK  // myType2&amp;lt;string&amp;gt; var2b; // Error - why?. Maybe I didn&#x27;t get it,  //                      // but I understand the book as no  //                      // error should occur here.  //                      // @DyP answered it.  Atype&amp;lt;make_unsigned&amp;lt;string&amp;gt; &amp;gt; var3;  // OK here, look below at @DyP  //                             // for &quot;foo, bar, X&quot; why  //                        // make_unsigned&amp;lt;string&amp;gt; is not an error here.  // make_unsigned&amp;lt;string&amp;gt; var6; // Error  // Atype&amp;lt;make_unsigned&amp;lt;string&amp;gt;::type &amp;gt; var4;  // Error  Atype&amp;lt;make_unsigned&amp;lt;int&amp;gt;::type &amp;gt; var5;  // OK  //-------------  myType4&amp;lt;string&amp;gt;::type var7;    // Look below for &quot;myType3&quot;, where @Yakk  //                          // obviates the necessity to write &quot;::type&quot;.  // rsl7 = 1:  cout &amp;lt;&amp;lt; &quot;rsl7 = &quot; &amp;lt;&amp;lt; is_same&amp;lt;decltype(var7), ErrIndicator&amp;lt;string&amp;gt; &amp;gt;::value &amp;lt;&amp;lt; endl;   func1(var7);  // &quot;non integral type&quot; overload of func1()  //---------  myType4&amp;lt;int&amp;gt;::type var8;  // rsl8 = 1:  cout &amp;lt;&amp;lt; &quot;rsl8 = &quot; &amp;lt;&amp;lt; is_same&amp;lt;decltype(var8), unsigned int&amp;gt;::value &amp;lt;&amp;lt; endl;   func1(var8);  // &quot;unsigned integral type&quot; overload of func1()}&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++,templates,c++11</Tags>
</question>
<answer>
<Body>&lt;p&gt;I think Stroustrup intents to delay the access to &lt;code&gt;make_unsigned&amp;lt;T&amp;gt;::type&lt;/code&gt;, because this nested type isn&#x27;t defined for non-integral types. However, using an alias template seems not to be enough for clang++ and g++: They resolve &lt;code&gt;Delay&amp;lt;Make_unsigned,T&amp;gt;&lt;/code&gt; directly to &lt;code&gt;Make_unsigned&amp;lt;T&amp;gt;&lt;/code&gt;, and this to &lt;code&gt;make_unsigned&amp;lt;T&amp;gt;::type&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The whole example is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;typename C, typename T, typename F&amp;gt;using Conditional = typename std::conditional&amp;lt;C,T,F&amp;gt;::type;template&amp;lt;typename T&amp;gt;using Make_unsigned = typename std::make_unsigned&amp;lt;T&amp;gt;::type;// the exampleConditional&amp;lt;  is_integral&amp;lt;T&amp;gt;::value,  Delay&amp;lt;Make_unsigned,T&amp;gt;,  Error&amp;lt;T&amp;gt;&amp;gt;// &quot;The implementation of a perfect `Delay` function is nontrivial,//  but for many uses this will do:&quot;template&amp;lt;template&amp;lt;typename...&amp;gt; class F, typename... Args&amp;gt;using Delay = F&amp;lt;Args...&amp;gt;;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&lt;p&gt;The question is of course, when is &lt;code&gt;Delay&amp;lt;Make_Unsigned,T&amp;gt;&lt;/code&gt; resolved? For class templates (not alias templates), they&#x27;re only instantiated implicitly when a complete object type is required or the semantics of the program are affected. Consider:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;type_traits&amp;gt;using namespace std;template&amp;lt;class T&amp;gt;struct foo{    static_assert(is_same&amp;lt;T, void&amp;gt;{}, &quot;!&quot;);};template&amp;lt;class X&amp;gt;struct bar{    // without the line below, no error!    //X x;};int main(){    bar&amp;lt;foo&amp;lt;int&amp;gt;&amp;gt; b;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This however is not the case for alias templates. They&#x27;re substituted [temp.alias]/2&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;When a &lt;em&gt;template-id&lt;/em&gt; refers to the specialization of an alias template, it is equivalent to the associated type  obtained by substitution of its &lt;em&gt;template-arguments&lt;/em&gt; for the &lt;em&gt;template-parameters&lt;/em&gt; in the &lt;em&gt;type-id&lt;/em&gt; of the alias  template.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;IMHO, this suggests that in the example above, &lt;code&gt;Delay&amp;lt;Make_unsigned,T&amp;gt;&lt;/code&gt; is equivalent to &lt;code&gt;make_unsigned&amp;lt;T&amp;gt;::type&lt;/code&gt;, which &lt;em&gt;will&lt;/em&gt; instantiate &lt;code&gt;make_unsigned&amp;lt;string&amp;gt;::type&lt;/code&gt; and cause a compile-time error.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;template&amp;lt;bool, template&amp;lt;typename...&amp;gt;class Lhs, template&amp;lt;typename...&amp;gt;class Rhs, typename... Ts&amp;gt;struct conditional_apply {  typedef Lhs&amp;lt;Ts...&amp;gt; type;};template&amp;lt;template&amp;lt;typename...&amp;gt;class Lhs, template&amp;lt;typename...&amp;gt;class Rhs, typename...Ts&amp;gt;struct conditional_apply&amp;lt;false, Lhs, Rhs, Ts...&amp;gt; {  typedef Rhs&amp;lt;Ts...&amp;gt; type;};template&amp;lt;bool b, template&amp;lt;typename...&amp;gt;class Lhs, template&amp;lt;typename...&amp;gt;class Rhs, typename... Ts&amp;gt;using Conditional_apply=typename conditional_apply&amp;lt;b, Lhs, Rhs, Ts...&amp;gt;::type;template&amp;lt;class T&amp;gt; using myType3 = Conditional_apply&amp;lt;is_integral&amp;lt;T&amp;gt;::value, Make_unsigned, ErrIndicator, T &amp;gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;should do actual delayed application of &lt;code&gt;template&lt;/code&gt;s on &lt;code&gt;T&lt;/code&gt;, barring typos (on phone).&lt;/p&gt;</Body>
</answer>
</qroot>
