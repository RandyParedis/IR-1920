<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Why does the expression below characterize a narrowing conversion?</Title>
<Body>&lt;p&gt;This expression can be found in the Example in ยง8.5.4/7 in the Standard (N3797)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;unsigned int ui1 = {-1}; // error: narrows&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Given ยง8.5.4/7 and its 4th bullet point:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;A narrowing conversion is an implicit conversion:&lt;/p&gt;    &lt;ul&gt;  &lt;li&gt;from an integer type or unscoped enumeration type to an integer type    that cannot represent all the values of the original type,  except    where the source is a constant expression whose value after  integral    promotions will fit into the target type.&lt;/li&gt;  &lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;I would say there&#x27;s no narrowing here, as -1 is a constant expression, whose value after integral promotion fits into an unsigned int.&lt;/p&gt;&lt;p&gt;See also ยง4.5/1 about &lt;strong&gt;Integral Promotion&lt;/strong&gt;:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;A prvalue of an integer type other than bool, char16_t, char32_t, or  wchar_t whose integer conversion rank (4.13) is less than the rank of  int can be converted to a prvalue of type int if int can represent all  the values of the source type; otherwise, the source prvalue can be  converted to a prvalue of type unsigned int.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;From 4.13 we have that the rank of -1 (an int) is equal to the rank of an unsigned int, and so it can be converted to an unsigned int.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Unfortunately &lt;a href=&quot;https://stackoverflow.com/users/179910/jerry-coffin&quot;&gt;Jerry Coffin&lt;/a&gt; removed his answer from this thread. I believe he was on the right track, if we accept the fact that the current reading of the 4th bullet point in ยง8.5.4/7 is wrong, after this &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3382.html#1449&quot; rel=&quot;nofollow noreferrer&quot;&gt;change&lt;/a&gt; in the Standard.&lt;/p&gt;</Body>
<Tags>c++,c++11,language-lawyer,narrowing</Tags>
</question>
<answer>
<Body>&lt;p&gt;There is no integral promotion from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;unsigned int&lt;/code&gt;, therefor it is still illformed.&lt;/p&gt;&lt;p&gt;That would be an &lt;em&gt;integral &lt;strong&gt;conversion&lt;/em&gt;&lt;/strong&gt;. &lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;Narrowing is an implicit conversion from an integer type to an integer type that cannot represent all the values of the original type&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Conversion from integer type &lt;code&gt;int&lt;/code&gt; to integer type &lt;code&gt;unsigned int&lt;/code&gt;, of course, cannot represent all the values of the original type -- the standard is quite unambigious here. If you really need it, you can do&lt;/p&gt;&lt;pre&gt;&lt;code&gt; unsigned int ui1 = {-1u};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This works without any errors/warnings since &lt;code&gt;1u&lt;/code&gt; is a literal of type &lt;code&gt;unsigned int&lt;/code&gt; which is then negated. This is well-defined as &lt;strong&gt;[expr.unary.op]&lt;/strong&gt; in the standard states:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;The negative of an unsigned quantity is computed by subtracting its value from 2&lt;sup&gt;n&lt;/sup&gt;, where n is the number of bits in the promoted operand.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;-1&lt;/code&gt; however is an &lt;code&gt;int&lt;/code&gt; before and after the negation and hence it becomes a narrowing conversion. &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/integer_literal#Notes&quot; rel=&quot;nofollow noreferrer&quot;&gt;There are no negative literals&lt;/a&gt;; see &lt;a href=&quot;https://stackoverflow.com/a/14695202/183120&quot;&gt;this answer&lt;/a&gt; for details.&lt;/p&gt;&lt;p&gt;Promotion is, informally, copying the same value into a larger space, so it shouldn&#x27;t be confused here as the sizes (of &lt;code&gt;signed&lt;/code&gt; and &lt;code&gt;unsigned&lt;/code&gt;) are equal. Even if you try to convert it to some type of larger size, say &lt;code&gt;unsigned long long&lt;/code&gt; it&#x27;s still a narrowing conversion as it cannot represent a negative number truly.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The change in the wording of the standard is intended to confirm the understanding that converting a negative value into an unsigned type is and always has been a narrowing conversion.&lt;/p&gt;&lt;p&gt;Informally, -1 cannot be represented within the range of any unsigned type, and the bit pattern that represents it does not represent the same value if stored in an unsigned int. Therefore this is a narrowing conversion and promotion/widening is not involved.&lt;/p&gt;&lt;p&gt;This is about the dainty art of reading the standard. As usual, the compiler knows best.&lt;/p&gt;</Body>
</answer>
</qroot>
