<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>signal on condition variable without holding lock</Title>
<Body>&lt;p&gt;So I just found out that it&#x27;s legal to signal a condition variable if you&#x27;re not holding the lock in c++11. That seems to open the door to some nasty race condition:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;std::mutex m_mutex;std::condition_variable m_cv;T1:   std::unique_lock&amp;lt;std::mutex&amp;gt; lock(m_mutex);  m_cv.wait(lock, []{ return !is_empty(); });T2:  generate_data();  m_cv.notify();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Is it guaranteed that T1 will never end up in a situation where we check is_empty() first (it returning true), then getting preempted by T2 which creates some data and signals the condition variable before we can actually wait on it?&lt;/p&gt;&lt;p&gt;If this is guaranteed to work (I&#x27;d guess so, otherwise it would seem like an intentionally bad API design), how is this actually implemented for say linux and &lt;code&gt;stdlibc++&lt;/code&gt;? Seems we&#x27;d need another lock to avoid this situation.&lt;/p&gt;</Body>
<Tags>c++,multithreading,c++11,condition-variable</Tags>
</question>
<answer>
<Body>&lt;p&gt;It is not guaranteed - if you don&#x27;t want to miss the signal then you must lock the mutex prior to notifying.   Some applications may be agnostic about missing signals.&lt;/p&gt;&lt;p&gt;From man pthread_signal:&lt;/p&gt;&lt;p&gt;The pthread_cond_signal() or pthread_cond_broadcast() functions may be called by a thread whether or not it currently owns the mutex that threads calling pthread_cond_wait() or pthread_cond_timedwait() have associated with the condition variable during their waits; however, if predictable scheduling behaviour is required, then that mutex is locked by the thread calling pthread_cond_signal() or pthread_cond_broadcast(). &lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Checking the predicate and waiting are not performed atomically in &lt;code&gt;std::condition_variable::wait&lt;/code&gt; (unlocking the lock and sleeping &lt;em&gt;are&lt;/em&gt; performed atomically). If it is possible for another thread to change the value of the predicate while this thread holds the mutex, then it is possible for notifications to occur between the predicate check and going to sleep, and effectively be lost.&lt;/p&gt;&lt;p&gt;In your example, if &lt;code&gt;generate_data()&lt;/code&gt; in &lt;code&gt;T2&lt;/code&gt; can alter the result of &lt;code&gt;is_empty()&lt;/code&gt; without holding &lt;code&gt;m_mutex&lt;/code&gt;, it&#x27;s possible for a notification to happen between &lt;code&gt;T1&lt;/code&gt; checking &lt;code&gt;is_empty()&lt;/code&gt; and sleeping on &lt;code&gt;m_cv&lt;/code&gt;. Holding the mutex at any time between the change to the predicate and the notification is sufficient to guarantee the atomicity of the predicate check and &lt;code&gt;wait&lt;/code&gt; call in the other thread. That could look like:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{  std::lock_guard&amp;lt;std::mutex&amp;gt; lk(m_mutex);  generate_data();}m_cv.notify();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;or even&lt;/p&gt;&lt;pre&gt;&lt;code&gt;generate_data();std::lock_guard&amp;lt;std::mutex&amp;gt;(m_mutex); // Lock the mutex and drop it immediatelym_cv.notify();&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
