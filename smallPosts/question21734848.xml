<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Should i always use smart pointer in C++ 11</Title>
<Body>&lt;p&gt;From c++ 11 i can write code without create and deleting raw pointers. But is it the right way to go- Should i always use smart pointers (either shared, unique or weak) or are there situations in which i should delete objects by myself?&lt;/p&gt;</Body>
<Tags>c++,c++11,shared-ptr</Tags>
</question>
<answer>
<Body>&lt;p&gt;It is hard to imagine situations where you would want to manually delete an object, so in that sense, the answer to your question is &quot;yes, always use smart pointers&quot;.&lt;/p&gt;&lt;p&gt;However, raw pointers do have another use case. Smart pointers are all about conferring &lt;em&gt;ownership&lt;/em&gt; semantics. A &lt;code&gt;unique_ptr&lt;/code&gt; has exclusive ownership of the object it points to, and will destroy the object when the pointer goes out of scope. A &lt;code&gt;shared_ptr&lt;/code&gt; implements &lt;em&gt;shared&lt;/em&gt; ownership, and the object will be destroyed when the last shared pointer goes out of scope.&lt;/p&gt;&lt;p&gt;Raw pointers are still useful for cases where you want to point to an object &lt;em&gt;without&lt;/em&gt; indicating any kind of ownership. You&#x27;re just pointing to an object you know exists, and that someone else (who owns it) will delete it when the time comes.&lt;/p&gt;&lt;p&gt;Raw pointers are for pointing to objects. Smart pointers are for owning objects.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;There are really very few cases where you&#x27;d want to use a smartpointer.  In most applications, either most deletes will be&lt;code&gt;delete this&lt;/code&gt;, or if the application is transactional, thetransaction manager will take care of the delete.  In caseswhere this doesn&#x27;t apply, you generally don&#x27;t want to usedynamic allocation to begin with.  About the only times you&#x27;lluse smart pointers: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;For some reason or another, you cannot make the object fullyoperational in the constructor, but have to follow up withadditional actions before it is active.  In this case, it makessense to keep it in an &lt;code&gt;std::unique_ptr&lt;/code&gt; until the object isfully active, then call &lt;code&gt;release&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;You really want value semantics, but you also needpolymorphism.  In this case, use some sort of shared pointer.(But beware of cycles.)  If the object is mutable, beware too,since you&#x27;ll end up with reference semantics.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;You really want value semantics (with deep copy), but theprofiler shows that the cost of copying is too high, you mightalso consider some sort of shared pointer.  This has itsdangers, but for large blocks of immutable data, can be a goodsolution.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;But for starters, you  should always ask yourself: why amI allocating this object dynamically.  The most frequent validreason is that it is an entity object, with a lifetime definedby program logic (i.e. its lifetime ends as a result of someexternal event).  In such cases, smart pointers will cause moreproblems than they solve.&lt;/p&gt;</Body>
</answer>
</qroot>
