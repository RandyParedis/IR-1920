<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Unexplained out_of_range in string::substr</Title>
<Body>&lt;p&gt;I have been getting a really annoying error about an std::out_of_range when calling substr. The exact error is &lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;terminate called after throwing an  instance of &#x27;std::out_of_range&#x27;&lt;br&gt;  what():  basic_string::substr&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I&#x27;m absolutely sure that tmp_request has a length greater then 1. No matter what I pass to substr&amp;mdash;1, 2, or bodypos&amp;mdash;it always throws that error.  I&#x27;m using g++ on Unix. &lt;/p&gt;&lt;p&gt;Only interesting thing I can include is the string has multiple &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, including one &lt;code&gt;&quot;\r\n\r\n&quot;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;In one cpp file:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;std::string tmp_request, outRequest;tmp_request = SS_Twitter-&amp;gt;readData();outRequest = SS_Twitter-&amp;gt;parse(tmp_request);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In another:&lt;/p&gt;&lt;pre&gt;&lt;code&gt; std::string parse(const std::string &amp;amp;request) {  std::map&amp;lt;std::string,std::string&amp;gt; keyval;  std::string outRequest;  if(request[0]==&#x27;P&#x27;)  {   if(request.find(&quot;register&quot;)!=std::string::npos)   { //we have a register request    size_t bodypos = request.find(&quot;username&quot;);    if(bodypos==std::string::npos)     {     HttpError(400,&quot;Malformed HTTP POST request. Could not find key username.&quot;,request);     }    else    {     std::string body = request.substr(bodypos);     StringExplode(body,&quot;&amp;amp;&quot;, &quot;=&quot;,keyval);     outRequest = &quot;doing stuff&quot;;    }   }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Update: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;std::string request2(&quot;P\r\nregister\r\nusername=hello\r\n\r\n&quot;);std::string body = request2.substr(4);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That throws the same error. Now I know this is perfectly valid and correct code, but it&#x27;s still throwing the error. //removed source link&lt;/p&gt;</Body>
<Tags>c++,g++</Tags>
</question>
<answer>
<Body>&lt;p&gt;Looks like you need an else after&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if(bodypos==std::string::npos){    HttpError(...);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;otherwise you are calling substr with bodypos = npos&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;You might consider using the (unsigned) type &lt;code&gt;std::string::size_type&lt;/code&gt; instead of &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Why are you casting the result of find to an int here:&lt;code&gt;int(request.find(&quot;register&quot;))!=std::string::npos&lt;/code&gt;&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Are you sure that it&#x27;s failing on that &lt;code&gt;substr&lt;/code&gt; and not on a &lt;code&gt;substr&lt;/code&gt; call within the &lt;code&gt;HttpError&lt;/code&gt; or &lt;code&gt;StringExplode&lt;/code&gt; functions?  If you haven&#x27;t already, you should run this through a debugger so that you can see exactly where it&#x27;s throwing the exception.  Alternatively, you could add a:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;std::cout &amp;lt;&amp;lt; &quot;calling substr&quot; &amp;lt;&amp;lt; std::endl;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;line immediately before you call &lt;code&gt;substr&lt;/code&gt;, and a similar line immediately afterwards, so that it would look like:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;std::cout &amp;lt;&amp;lt; &quot;calling substr&quot; &amp;lt;&amp;lt; std::endl;std::string body = request.substr(bodypos);std::cout &amp;lt;&amp;lt; &quot;finished calling substr&quot; &amp;lt;&amp;lt; std::endl;StringExplode(body,&quot;&amp;amp;&quot;, &quot;=&quot;,keyval);outRequest = &quot;doing stuff&quot;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If that &lt;code&gt;substr&lt;/code&gt; really is throwing the exception, then you&#x27;ll know because the program will print &quot;calling substr&quot; without a matching &quot;finished calling substr&quot;.  If it prints the pair of debug messages, though, or none at all, then something else is throwing the exception.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I modified your sample slightly to decrease amount of indentation used.&lt;br&gt;There are 5 &quot;test cases&quot; and none causes any problem. Could you please provide a sample request to reproduce the problem you&#x27;re having.&lt;/p&gt;&lt;p&gt;EDIT: Forgot to mention: if this sample as it is (with commented-out bits) doesn&#x27;t produce that error, your best bet is that you have a bug in your &lt;code&gt;StringExplode&lt;/code&gt; function. You could post its source, to get a more helpful advice.&lt;/p&gt;&lt;p&gt;EDIT2:In your &lt;code&gt;StringExplode&lt;/code&gt;, change &lt;code&gt;results[tmpKey] = tmpKey.substr(found+1);&lt;/code&gt; to &lt;code&gt;results[tmpKey] = tmpResult[i].substr(found+1);&lt;/code&gt;. Change &lt;code&gt;int found&lt;/code&gt; to &lt;code&gt;size_t found&lt;/code&gt;, and remove all of &lt;code&gt;if (found &amp;gt; 0)&lt;/code&gt;, that will fix your mysterious out_of_range. You were &lt;code&gt;substr&lt;/code&gt;-ing a wrong string. Just in case, here&#x27;s the code with a fix:  &lt;/p&gt;&lt;pre&gt;&lt;code&gt;void StringExplode(std::string str, std::string objseparator, std::string keyseperator,                   std::map &amp;lt;std::string, std::string&amp;gt; &amp;amp;results){    size_t found;    std::vector&amp;lt;std::string&amp;gt; tmpResult;    found = str.find_first_of(objseparator);    while(found != std::string::npos)    {        tmpResult.push_back(str.substr(0,found));        str = str.substr(found+1);        found = str.find_first_of(objseparator);    }    if(str.length() &amp;gt; 0)    {        tmpResult.push_back(str);    }    for(size_t i = 0; i &amp;lt; tmpResult.size(); i++)    {        found = tmpResult[i].find_first_of(keyseperator);        while(found != std::string::npos)        {                std::string tmpKey = tmpResult[i].substr(0, found);                results[tmpKey] = tmpResult[i].substr(found+1);                found = tmpResult[i].find_first_of(keyseperator, found + results[tmpKey].size());        }    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Initial test code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;string&amp;gt;std::string parse(const std::string &amp;amp;request){    std::map&amp;lt;std::string,std::string&amp;gt; keyval;    std::string outRequest;    if(request[0] != &#x27;P&#x27;)        return outRequest;    if(request.find(&quot;register&quot;) == std::string::npos)        return outRequest;    //we have a register request    size_t bodypos = request.find(&quot;username&quot;);    if(bodypos==std::string::npos)    {        // HttpError(400,&quot;Malformed HTTP POST request. Could not find key username.&quot;,request);        // you said HttpError returns, so here&#x27;s a return        return outRequest;    }    std::string body = request.substr(bodypos);    // StringExplode(body,&quot;&amp;amp;&quot;, &quot;=&quot;,keyval);    outRequest = &quot;doing stuff&quot;;    return outRequest;}int main(){    std::string request(&quot;P\r\nregister\r\nusername=hello\r\n\r\n&quot;);    std::cout &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; parse(request) &amp;lt;&amp;lt; &quot;]\n&quot;;    request = &quot;Pregisternusername=hello\r\n\r\n&quot;;    std::cout &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; parse(request) &amp;lt;&amp;lt; &quot;]\n&quot;;    request = &quot;Pregisternusername=hello&quot;;    std::cout &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; parse(request) &amp;lt;&amp;lt; &quot;]\n&quot;;    request = &quot;registernusername=hello&quot;;    std::cout &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; parse(request) &amp;lt;&amp;lt; &quot;]\n&quot;;    request = &quot;&quot;;    std::cout &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; parse(request) &amp;lt;&amp;lt; &quot;]\n&quot;;    return 0;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This outputs, predictably:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;[doing stuff]&lt;br&gt;  [doing stuff]&lt;br&gt;  [doing stuff]&lt;br&gt;  []&lt;br&gt;  []  &lt;/p&gt;&lt;/blockquote&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;One fairly obvious thing wrong with your code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int k = read(ns, buf, sizeof(buf)-1);buf[k] = &#x27;\0&#x27;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You are not checking that read() succeeded - it returns -1 on failure which will cause all sorts of memory corruption problems if it occurs.&lt;/p&gt;&lt;p&gt;Also:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;char * buf2 = const_cast&amp;lt;char *&amp;gt;(reply.c_str());write(ns,buf2,sizeof(buf2));&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You are taking the size of the pointer - you want the length of the output string:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;write(ns, buf2, reply.size() );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And you should once again test that write succeeded and that it wrote as many bytes as you requested, though this shouldn&#x27;t directly cause the substr() error.&lt;/p&gt;</Body>
</answer>
</qroot>
