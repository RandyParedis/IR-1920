<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Error using CArray: cannot access private member declared in class CObject</Title>
<Body>&lt;p&gt;I&#x27;ve created a dll using Microsoft Visual Studio 2010 and all works fine; now I want to add a member variable to the class I export; this member variable is a vector of struct which contains a CArray of another struct. The error I have in debug mode is &lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;code&gt;error C2248: &#x27;CObject::CObject&#x27;: cannot access private member declared in class &#x27;CObject&#x27;c:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\afxtempl.h  262&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;I know I get this error because there a problem with the constructor of the struct which contains the CArray but I&#x27;m not able to fix it. Please help me.Below I posted the code.&lt;/p&gt;&lt;p&gt;EXPORTED CLASS:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;namespace optFun{    // si posso definire altri casi in base a dove vengono collocati gli strumenti di gestione delle eccezioni    enum RETURN{        RETURN_INIT=0,        RETURN_ERRORINREADING,        RETURN_ERRORINPARALLEL,        RETURN_ERRORINMAKESPAN,        RETURN_SUCCESSFUL    };    struct DataPrescription{    EDrug  NameDrug;    float Dosage;    EContainerType DestType;    ELiquid IdDest;    float CapacityDest;    float Priority;    bool ScaricoShaker;    int  BlockNumber;    DataPrescription(){        NameDrug=EDrug_NoDrug;        Dosage=0.0;        DestType= EContainerType_Tot;        IdDest=ELiquid_NoLiquid;        CapacityDest=0.0;        Priority=0.0;        ScaricoShaker=true;        BlockNumber=0;    }    DataPrescription(EDrug name,float dos,EContainerType dest,ELiquid ID,float cap_dest,float p,bool _ScaricoShaker,int _BlockNumber){        NameDrug=name;        Dosage=dos;        DestType=dest;        IdDest=ID;        CapacityDest=cap_dest;        Priority=p;        ScaricoShaker=_ScaricoShaker;        BlockNumber=_BlockNumber;    }};struct final_block{  CArray&amp;lt;DataPrescription&amp;gt; block_list;  vector&amp;lt;load_info&amp;gt; carico;  bool scarico_MI;  final_block(){      scarico_MI=false;  }};    // This class is exported from the optFunDll.dll    class OPTFUNDLL_API OptimizationTool    {    public:         // funzione che implementa il modulo di ottimizzazione        CArray&amp;lt;DataPrescription&amp;gt; OptList;        time_info time;        vector&amp;lt;final_block&amp;gt; execution_mode;        vector&amp;lt;state_info&amp;gt; StatusInfo;        vector&amp;lt;load_info&amp;gt; LoadIndication;        CArray&amp;lt;DataPrescription&amp;gt; ShakingList; //lista dei soli farmaci da restituire nell&#x27;ordine ottimo di schedulazione        OptimizationTool(void);        ~OptimizationTool();        void CreateDataPrescription(vector&amp;lt;block&amp;gt;&amp;amp;);        //void CreateBlockPrescription(block&amp;amp;);         RETURN scheduling(vector&amp;lt;string&amp;gt;,const char*,const char*,const char*);        void InitializeParameter(double,int);        void LoadDetails(vector&amp;lt;block&amp;gt;&amp;amp;,vector&amp;lt;magazzino_ospedale&amp;gt;&amp;amp;);        //void ToLoad(ricetta&amp;amp;,vector&amp;lt;magazzino_ospedale&amp;gt;&amp;amp;,vector&amp;lt;magazzino_ospedale&amp;gt;&amp;amp;);        void SyncronizeLoad(vector&amp;lt;block&amp;gt;&amp;amp;);        // accessor function        double get_PercVel();        int get_CountSame();    private:        double _PercentMaximumVelocityOfSearchSpace; // % che determina range di variazione della velocit√† (e quindi anche della posizione)        int _CountSame; // numero di stesse iterazioni dopo le quali la procedura di ottimizzazione si arresta    };}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The struct which give me error is &quot;final_block&quot;; I used this struct in this way:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;for(unsigned int i=0;i&amp;lt;output.size();i++){           final_block pr;           for(unsigned int j=0;j&amp;lt;output[i].list.size();j++){               DataPrescription tmp(output[i].list[j].getID(),output[i].list[j].getdosage(),output[i].list[j].get_destination(),output[i].list[j].get_DestType(),output[i].list[j].get_CapacityDest(),output[i].list[j].getPriority(),output[i].list[j].processing_info.scarico_shaker,i+1);               pr.block_list.Add(tmp);           }           pr.carico.push_back(this-&amp;gt;LoadIndication[i]);           pr.scarico_MI=output[i].scarico_MI;          this-&amp;gt;execution_mode.push_back(pr);       }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thanks in advance for your help.&lt;/p&gt;</Body>
<Tags>c++,mfc</Tags>
</question>
<answer>
<Body>&lt;p&gt;The problem is that MFC &lt;code&gt;CArray&lt;/code&gt; (which derives from &lt;code&gt;CObject&lt;/code&gt;) is &lt;strong&gt;not copyable&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;So, the &lt;code&gt;CArray&lt;/code&gt; data member inside your &lt;code&gt;final_block&lt;/code&gt; structure makes the latter not copyable as well.&lt;/p&gt;&lt;p&gt;So, being not copyable, you can&#x27;t &lt;code&gt;push_back()&lt;/code&gt; instances of &lt;code&gt;final_block&lt;/code&gt; in a &lt;code&gt;std::vector&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;An option is to just substitute &lt;code&gt;CArray&lt;/code&gt; with **&lt;code&gt;std::vector&lt;/code&gt; in your &lt;code&gt;final_block&lt;/code&gt; structure.&lt;/p&gt;&lt;p&gt;Or you can provide custom copy constructor and copy assignment for your &lt;code&gt;final_block&lt;/code&gt; structure, and writing custom code for copying the &lt;code&gt;CArray&lt;/code&gt; member.&lt;/p&gt;&lt;p&gt;Frankly, I&#x27;d just use &lt;code&gt;std::vector&lt;/code&gt; instead of &lt;code&gt;CArray&lt;/code&gt;.&lt;/p&gt;</Body>
</answer>
</qroot>
