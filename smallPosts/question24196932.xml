<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>How can I get the IP address from NIC in Python?</Title>
<Body>&lt;p&gt;When an error occurs in a Python script on Unix , an email is sent.&lt;/p&gt;&lt;p&gt;I have been asked to add {Testing Environment} to the subject line of the email if the IP address is 192.168.100.37 which is the testing server. This way we can have one version of a script and a way to tell if the email is coming from messed up data on the testing server.&lt;/p&gt;&lt;p&gt;However, when I google I keep finding this code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import socketsocket.gethostbyname(socket.gethostname())&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, that&#x27;s giving me the IP address of 127.0.1.1. When I use &lt;code&gt;ifconfig&lt;/code&gt; I get this&lt;/p&gt;&lt;pre&gt;&lt;code&gt;eth0      Link encap:Ethernet  HWaddr 00:1c:c4:2c:c8:3e          inet addr:192.168.100.37  Bcast:192.168.100.255  Mask:255.255.255.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:75760697 errors:0 dropped:411180 overruns:0 frame:0          TX packets:23166399 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:59525958247 (59.5 GB)  TX bytes:10142130096 (10.1 GB)          Interrupt:19 Memory:f0500000-f0520000lo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          UP LOOPBACK RUNNING  MTU:16436  Metric:1          RX packets:25573544 errors:0 dropped:0 overruns:0 frame:0          TX packets:25573544 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:44531490070 (44.5 GB)  TX bytes:44531490070 (44.5 GB)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Firstly, I don&#x27;t know where it got 127.0.1.1 from, but either way that&#x27;s not what I want. When I google I keep coming to the same syntax, &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot; rel=&quot;noreferrer&quot;&gt;Bash&lt;/a&gt; scripts or netifaces and I&#x27;m trying to use standard libraries.&lt;/p&gt;&lt;p&gt;So how can I get the IP address of eth0 in Python?&lt;/p&gt;</Body>
<Tags>python,unix,networking,nic</Tags>
</question>
<answer>
<Body>&lt;p&gt;Two methods:&lt;/p&gt;&lt;h2&gt;Method #1 (use external package)&lt;/h2&gt;&lt;p&gt;You need to ask for the IP address that is bound to your &lt;code&gt;eth0&lt;/code&gt; interface. This is available from the &lt;a href=&quot;https://pypi.python.org/pypi/netifaces/&quot; rel=&quot;noreferrer&quot;&gt;netifaces package&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import netifaces as nini.ifaddresses(&#x27;eth0&#x27;)ip = ni.ifaddresses(&#x27;eth0&#x27;)[ni.AF_INET][0][&#x27;addr&#x27;]print ip  # should print &quot;192.168.100.37&quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can also get a list of all available interfaces via&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ni.interfaces()&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Method #2 (no external package)&lt;/h2&gt;&lt;p&gt;Here&#x27;s a way to get the IP address without using a python package:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import socketimport fcntlimport structdef get_ip_address(ifname):    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)    return socket.inet_ntoa(fcntl.ioctl(        s.fileno(),        0x8915,  # SIOCGIFADDR        struct.pack(&#x27;256s&#x27;, ifname[:15])    )[20:24])get_ip_address(&#x27;eth0&#x27;)  # &#x27;192.168.0.110&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note: detecting the IP address to determine what environment you are using is quite a hack. Almost all frameworks provide a very simple way to set/modify an environment variable to indicate the current environment. Try and take a look at your documentation for this. It should be as simple as doing&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if app.config[&#x27;ENV&#x27;] == &#x27;production&#x27;:  #send production emailelse:  #send development email&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Alternatively, if you want to get the IP address of whichever interface is used to connect to the network without having to know its name, you can use this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import socketdef get_ip_address():    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)    s.connect((&quot;8.8.8.8&quot;, 80))    return s.getsockname()[0]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I know it&#x27;s a little different than your question, but others may arrive here and find this one more useful. You do not have to have a route to 8.8.8.8 to use this. All it is doing is opening a socket, but not sending any data.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;If you only need to work on Unix, you can use a system call (ref. Stack&amp;nbsp;Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/23934425/bash-parse-ifconfig-to-get-only-my-ip-address&quot;&gt;Parse ifconfig to get only my IP address using Bash&lt;/a&gt;&lt;/em&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import osf = os.popen(&#x27;ifconfig eth0 | grep &quot;inet\ addr&quot; | cut -d: -f2 | cut -d&quot; &quot; -f1&#x27;)your_ip=f.read()&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;try below code, it works for me in Mac10.10.2:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import subprocessif __name__ == &quot;__main__&quot;:    result = subprocess.check_output(&#x27;ifconfig en0 |grep -w inet&#x27;, shell=True) # you may need to use eth0 instead of en0 here!!!    print &#x27;output = %s&#x27; % result.strip()    # result = None    ip = &#x27;&#x27;    if result:        strs = result.split(&#x27;\n&#x27;)        for line in strs:            # remove \t, space...            line = line.strip()            if line.startswith(&#x27;inet &#x27;):                a = line.find(&#x27; &#x27;)                ipStart = a+1                ipEnd = line.find(&#x27; &#x27;, ipStart)                if a != -1 and ipEnd != -1:                    ip = line[ipStart:ipEnd]                    break    print &#x27;ip = %s&#x27; % ip&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;It worked for me &lt;/p&gt;&lt;pre&gt;&lt;code&gt; import subprocess my_ip = subprocess.Popen([&#x27;ifconfig eth0 | awk &quot;/inet /&quot; | cut -d&quot;:&quot; -f 2 | cut -d&quot; &quot; -f1&#x27;], stdout=subprocess.PIPE, shell=True) (IP,errors) = my_ip.communicate() my_ip.stdout.close() print IP&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Find the IP address of the first eth/wlan entry in ifconfig that&#x27;s RUNNING:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import itertoolsimport osimport redef get_ip():    f = os.popen(&#x27;ifconfig&#x27;)    for iface in [&#x27; &#x27;.join(i) for i in iter(lambda: list(itertools.takewhile(lambda l: not l.isspace(),f)), [])]:        if re.findall(&#x27;^(eth|wlan)[0-9]&#x27;,iface) and re.findall(&#x27;RUNNING&#x27;,iface):            ip = re.findall(&#x27;(?&amp;lt;=inet\saddr:)[0-9\.]+&#x27;,iface)            if ip:                return ip[0]    return False&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Since most of the answers use &lt;code&gt;ifconfig&lt;/code&gt; to extract the IPv4 from the eth0 interface, which is deprecated in favor of &lt;code&gt;ip addr&lt;/code&gt;, the following code could be used instead:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import osipv4 = os.popen(&#x27;ip addr show eth0 | grep &quot;\&amp;lt;inet\&amp;gt;&quot; | awk \&#x27;{ print $2 }\&#x27; | awk -F &quot;/&quot; \&#x27;{ print $1 }\&#x27;&#x27;).read().strip()ipv6 = os.popen(&#x27;ip addr show eth0 | grep &quot;\&amp;lt;inet6\&amp;gt;&quot; | awk \&#x27;{ print $2 }\&#x27; | awk -F &quot;/&quot; \&#x27;{ print $1 }\&#x27;&#x27;).read().strip()&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;UPDATE:&lt;/h1&gt;&lt;p&gt;Alternatively, you can shift part of the parsing task to the python interpreter by using &lt;code&gt;split()&lt;/code&gt; instead of grep and awk, as @serg points out in the comment:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import osipv4 = os.popen(&#x27;ip addr show eth0&#x27;).read().split(&quot;inet &quot;)[1].split(&quot;/&quot;)[0]ipv6 = os.popen(&#x27;ip addr show eth0&#x27;).read().split(&quot;inet6 &quot;)[1].split(&quot;/&quot;)[0]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But in this case you have to check the bounds of the array returned by each &lt;code&gt;split()&lt;/code&gt; call.&lt;/p&gt;&lt;h1&gt;UPDATE 2:&lt;/h1&gt;&lt;p&gt;Another version using regex:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import osimport reipv4 = re.search(re.compile(r&#x27;(?&amp;lt;=inet )(.*)(?=\/)&#x27;, re.M), os.popen(&#x27;ip addr show eth0&#x27;).read()).groups()[0]ipv6 = re.search(re.compile(r&#x27;(?&amp;lt;=inet6 )(.*)(?=\/)&#x27;, re.M), os.popen(&#x27;ip addr show eth0&#x27;).read()).groups()[0]&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;A simple approach which returns a string with ip-addresses for the interfaces is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;from subprocess import check_outputips = check_output([&#x27;hostname&#x27;, &#x27;--all-ip-addresses&#x27;])&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;for more info see &lt;a href=&quot;http://linux.die.net/man/1/hostname&quot; rel=&quot;noreferrer&quot;&gt;hostname&lt;/a&gt;.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Building on the answer from @jeremyjjbrown, another version that cleans up after itself as mentioned in the comments to his answer. This version also allows providing a different server address for use on private internal networks, etc..&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import socketdef get_my_ip_address(remote_server=&quot;google.com&quot;):    &quot;&quot;&quot;    Return the/a network-facing IP number for this system.    &quot;&quot;&quot;    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:         s.connect((remote_server, 80))        return s.getsockname()[0]&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;This is the result of ifconfig:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ ifconfigeth0: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu 1500        inet 192.168.2.24  netmask 255.255.255.0  broadcast 192.168.2.255        inet6 fe80::88e9:4d2:c057:2d5f  prefixlen 64  scopeid 0x20&amp;lt;link&amp;gt;        ether b8:27:eb:d0:9a:f3  txqueuelen 1000  (Ethernet)        RX packets 261861  bytes 250818555 (239.1 MiB)        RX errors 0  dropped 6  overruns 0  frame 0        TX packets 299436  bytes 280053853 (267.0 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&amp;lt;UP,LOOPBACK,RUNNING&amp;gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&amp;lt;host&amp;gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 74  bytes 16073 (15.6 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 74  bytes 16073 (15.6 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0wlan0: flags=4099&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu 1500        ether b8:27:eb:85:cf:a6  txqueuelen 1000  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0pi@raspberrypi:~ $ &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cutting a bit the output, we have:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pi@raspberrypi:~ $ pi@raspberrypi:~ $ ifconfig eth0 | grep &quot;inet 192&quot; | cut -c 14-25192.168.2.24pi@raspberrypi:~ $ pi@raspberrypi:~ $ &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, we can go to python and do:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import osmine = os.popen(&#x27;ifconfig eth0 | grep &quot;inet 192&quot; | cut -c 14-25&#x27;)myip = mine.read()print (myip)&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Yet another way of obtaining the IP Address from a NIC, using Python.&lt;/p&gt;&lt;p&gt;I had this as part of an app that I developed long time ago, and I didn&#x27;t wanted to simply &lt;code&gt;git rm script.py&lt;/code&gt;. So, here I provide the approach, using &lt;code&gt;subprocess&lt;/code&gt; and list comprehensions for the sake of functional approach and less lines of code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import subprocess as sp__version__ = &quot;v1.0&quot;                                                            __author__ = &quot;@ivanleoncz&quot;def get_nic_ipv4(nic):                                                              &quot;&quot;&quot;        Get IP address from a NIC.                                                      Parameter        ---------        nic : str            Network Interface Card used for the query.                                  Returns                                                                         -------                                                                         ipaddr : str            Ipaddress from the NIC provided as parameter.                           &quot;&quot;&quot;                                                                             result = None                                                                   try:                                                                                result = sp.check_output([&quot;ip&quot;, &quot;-4&quot;, &quot;addr&quot;, &quot;show&quot;, nic],                                                               stderr=sp.STDOUT)    except Exception:        return &quot;Unkown NIC: %s&quot; % nic    result = result.decode().splitlines()    ipaddr = [l.split()[1].split(&#x27;/&#x27;)[0] for l in result if &quot;inet&quot; in l]            return ipaddr[0]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Additionally, you can use a similar approach for obtaining a list of NICs:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def get_nics():                                                                     &quot;&quot;&quot;                                                                                 Get all NICs from the Operating System.                                         Returns                                                                         -------                                                                         nics : list                                                                         All Network Interface Cards.                                            &quot;&quot;&quot;                                                                             result = sp.check_output([&quot;ip&quot;, &quot;addr&quot;, &quot;show&quot;])                                result = result.decode().splitlines()                                           nics = [l.split()[1].strip(&#x27;:&#x27;) for l in result if l[0].isdigit()]              return nics                                                &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here&#x27;s the solution as a &lt;a href=&quot;https://gist.github.com/ivanlmj/3a4e53a64a8ca44a72c7594c424e1145&quot; rel=&quot;nofollow noreferrer&quot;&gt;Gist&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;And you would have something like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ python3Python 3.6.7 (default, Oct 22 2018, 11:32:17) [GCC 8.2.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; import helpers&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; helpers.get_nics()[&#x27;lo&#x27;, &#x27;enp1s0&#x27;, &#x27;wlp2s0&#x27;, &#x27;docker0&#x27;]&amp;gt;&amp;gt;&amp;gt; helpers.get_nic_ipv4(&#x27;docker0&#x27;)&#x27;172.17.0.1&#x27;&amp;gt;&amp;gt;&amp;gt; helpers.get_nic_ipv4(&#x27;docker2&#x27;)&#x27;Unkown NIC: docker2&#x27;&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
