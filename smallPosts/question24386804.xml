<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>How do I use Tkinter and allow my application to keep the focus?</Title>
<Body>&lt;p&gt;I have a small application that the user can interact with as a command line. I want the user to be able to copy to the Windows clipboard information that the application has just displayed on-screen. Obviously, the user can do this manually, but it takes several steps: right-click on the window, select &quot;Mark&quot;, select the rectangle of text, and press Enter to copy it. I want to allow the user to do this automatically by typing a short command like &quot;cb&quot; or &quot;copy&quot;.&lt;/p&gt;&lt;p&gt;Per &lt;a href=&quot;https://stackoverflow.com/a/4203897/340819&quot;&gt;this answer&lt;/a&gt;, an easy way to get clipboard functionality is using the tkinter library. This does indeed work well. However, I find that when my application starts up, it loses the focus. It seems that a hidden window (opened by &lt;code&gt;Tk()&lt;/code&gt; and then hidden by &lt;code&gt;withdraw()&lt;/code&gt;) has it. The act of hiding the window with &lt;code&gt;withdraw()&lt;/code&gt; did not give focus back to my application. This is inconvenient, because having opened the application, the user has to manually switch back to it rather than being able to just begin typing.&lt;/p&gt;&lt;p&gt;I want to create a tkinter object and either give the focus back to my application after I hide the new window, or have my application not lose focus in the first place. How can I do this?&lt;/p&gt;&lt;p&gt;There are various questions already relating to tkinter and focus, but they seem generally to relate to giving focus to the windows that tkinter itself opens, whereas I want to keep focus on the original window of my application, and deny it to the tkinter window.&lt;/p&gt;&lt;p&gt;I&#x27;m working at a Windows 8 machine.&lt;/p&gt;&lt;p&gt;Pastebin &lt;a href=&quot;http://pastebin.com/6jsasiNE&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://pastebin.com/6jsasiNE&lt;/a&gt;&lt;/p&gt;</Body>
<Tags>python,tkinter,focus,lost-focus</Tags>
</question>
<answer>
<Body>&lt;p&gt;&lt;strong&gt;On Windows NT, Windows Server 2003, and Windows 7+&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;You don&#x27;t need to use &lt;code&gt;Tkinter&lt;/code&gt; at all to achieve your goal.&lt;/p&gt;&lt;p&gt;clip.py:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import subprocessdef write_to_clipboard(string):    p = subprocess.Popen([&#x27;clip&#x27;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)    p.communicate(input=string)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code just calls the standard windows &lt;code&gt;clip.exe&lt;/code&gt; utility, pasting whatever passed in the &lt;code&gt;string&lt;/code&gt; variable.&lt;/p&gt;&lt;p&gt;Usage:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;from clip import write_to_clipboardtry:    while True:        write_to_clipboard(raw_input())        except KeyboardInterrupt:    pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;On Windows 95, 98, ME, and XP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Those versions of windows don&#x27;t come with &lt;code&gt;clip.exe&lt;/code&gt;, so here&#x27;s a python only version:&lt;/p&gt;&lt;p&gt;clip.py:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import subprocessdef write_to_clipboard(string):    p = subprocess.Popen([&#x27;python&#x27;, __file__], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)    p.communicate(input=string)if __name__ == &quot;__main__&quot;:    import sys    from Tkinter import Tk    r = Tk()    r.withdraw()    r.clipboard_clear()    r.clipboard_append(sys.stdin.read())    r.update()    r.destroy()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will work on all version of windows and in face any OS supporting &lt;code&gt;TK&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Note that you must run the &lt;code&gt;Tk&lt;/code&gt; code in a separate process like this, because even though we call &lt;code&gt;r.destroy()&lt;/code&gt;, &lt;code&gt;Tk&lt;/code&gt; seems to &quot;lock&quot; the clipboard (no other process can access the clipboard until this process has exited).&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Reading and Writing Clipboard&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;If you want to be able to read from the clipboard as well as write to it, this is the solution.&lt;/p&gt;&lt;p&gt;clip.py:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import subprocessdef write(string):    p = subprocess.Popen([&#x27;python&#x27;, __file__, &#x27;write&#x27;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)    p.communicate(input=string)def read():    p = subprocess.Popen([&#x27;python&#x27;, __file__, &#x27;read&#x27;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)    return p.communicate()[0]if __name__ == &quot;__main__&quot;:    import sys    from Tkinter import Tk    if len(sys.argv) != 2:        sys.exit(1)    r = Tk()    try:        r.withdraw()        if sys.argv[1] == &quot;write&quot;:            r.clipboard_clear()            r.clipboard_append(sys.stdin.read())            r.update()        elif sys.argv[1] == &quot;read&quot;:            sys.stdout.write(r.clipboard_get()),        else:            sys.exit(1)    finally:        r.destroy()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Usage:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import clipprint &quot;clipboard contains: %s&quot; % clip.read()&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
