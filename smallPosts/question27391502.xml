<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>deleting indiviual pointers from an array</Title>
<Body>&lt;p&gt;So, If if have an array of pointers&lt;/p&gt;&lt;pre&gt;&lt;code&gt;stuff **items;stuff *testPTR;items = new stuff[200];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;the contents of which are used to hold dynamic memory objects&lt;/p&gt;&lt;pre&gt;&lt;code&gt;items[0] = new stuff;items[1] = new stuff;etc. testPTR = items[0];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and I want to delete the items, how come this doesn&#x27;t work?&lt;/p&gt;&lt;pre&gt;&lt;code&gt;delete items[0];delete items[1];etc.delete [] items;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I tested this code and I could still access things that where allocated using testPTR (after the delete statements ran) which i set earlier.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//stuff held in items[0] is still accessible with*testPTR&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I am confused becuase if I cout items[any position] I will get a memory address which delete should use to return the memory that was allocated for stuff, but the code above seems to leave the stuff and only delete the pointer array. What am I missing? Thank You//edited to make question clearer&lt;/p&gt;</Body>
<Tags>c++,pointers</Tags>
</question>
<answer>
<Body>&lt;p&gt;&lt;code&gt;delete items[0]&lt;/code&gt; only deallocates memory that &lt;code&gt;items[0]&lt;/code&gt; points to, it does NOT set items[0] to NULL. You have to do that yourself.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;delete items[0];items[0] = NULL;etc&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As other answers point out, the actual deallocation of the memory might not happen right away, but that&#x27;s an implementation detail of the memory management system and you shouldn&#x27;t rely on it.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;In addition to what pbkhrv said, &lt;code&gt;delete&lt;/code&gt; has no obligation to immediately release the memory back to the operating system, so it is undefined behavior whether you can still access memory returned.  You will only get a segmentation fault if your program no longer owns the memory space you are trying to access, but if &lt;code&gt;delete&lt;/code&gt; didn&#x27;t actually give it back to the operating system the operating system still sees your program as owning the memory and doesn&#x27;t mind that you are accessing it.  The reason &lt;code&gt;delete&lt;/code&gt; may not give back the memory is simply that it is much faster to keep the memory allocated to your program and if you call &lt;code&gt;new&lt;/code&gt; again, just give you a pointer to the same memory you already own.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;In addition to the other answers, especially Namfuak one.&lt;/p&gt;&lt;p&gt;Take a look at the short program bellow:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {    char *p = new char [1];    for (int i=0; 1;i++){       p[i]=0;       cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;    }    return 0;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I guess you would expect that it will crash when i=1. but for me it actually can run till 32 or 64.&lt;/p&gt;&lt;p&gt;Obviously I didn&#x27;t allocate all the memory I can access to. but still I can access to it.&lt;/p&gt;&lt;p&gt;So as you can see, when you ask for 1 byte you get you get allocation of more, because dynamic allocations are slow operations. it actually allocate a larger block for efficiency. &lt;/p&gt;&lt;p&gt;And you can use some addresses after freed since you didn&#x27;t free the whole block.   &lt;/p&gt;</Body>
</answer>
</qroot>
