<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Bug in gcc, or extention in clang/MSVS</Title>
<Body>&lt;p&gt;The following snippet compiles in clang and MSVS, but not in gcc.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt; class clone_ptr;template&amp;lt;typename T, typename U, typename ...Args&amp;gt;clone_ptr&amp;lt;T&amp;gt; make_cloned( Args ...args );// note: everything not needed for example cut out, so// this class is neither complete nor correcttemplate&amp;lt;typename T&amp;gt;class clone_ptr {public:    clone_ptr() : ptr(nullptr) {}    operator bool() { return ptr!=nullptr; }    T* operator-&amp;gt;() { return ptr; }private:    clone_ptr(T* p) : ptr(p) {}    T* ptr;    template&amp;lt;class T1,class U1, typename ...Args&amp;gt;        friend clone_ptr&amp;lt;T1&amp;gt; make_cloned( Args ...args );};template&amp;lt;typename T, typename U=T, typename ...Args&amp;gt;clone_ptr&amp;lt;T&amp;gt; make_cloned( Args ...args ){    return {new U(args...)};}// ----------------------------------------------#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;struct Base{    int a;    Base( int a=0 ) : a(a) {}    virtual string foo() { return &quot;Base &quot;+to_string(a); };    virtual ~Base() {}};struct Sub : Base{    Sub( int a=0 ) : Base(a) {}    virtual string foo() override { return &quot;Sub &quot;+to_string(a); };};string testit(){    std::vector&amp;lt; clone_ptr&amp;lt; Base &amp;gt; &amp;gt; vec;    vec.push_back( make_cloned&amp;lt;Base&amp;gt;(7) );    vec.emplace_back();    vec.push_back( make_cloned&amp;lt;Base,Sub&amp;gt;(5) );    string ss;    for( auto&amp;amp;&amp;amp; a : vec )    {        ss += a?a-&amp;gt;foo():&quot;&amp;lt;empty&amp;gt;&quot;;    }    return ss;}int main(){    cout &amp;lt;&amp;lt; testit() &amp;lt;&amp;lt; endl;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;gcc complains:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;error: no matching function for call to &#x27;make_cloned(int)&#x27;vec.push_back( make_cloned&amp;lt;Base&amp;gt;(7) );note: candidate is:note: template&amp;lt;class T, class U, class ... Args&amp;gt; clone_ptr&amp;lt;T&amp;gt; make_cloned(Args ...)clone_ptr&amp;lt;T&amp;gt; make_cloned( Args ...args )             ^note:   template argument deduction/substitution failed:note:   couldn&#x27;t deduce template parameter &#x27;U&#x27;vec.push_back( make_cloned&amp;lt;Base&amp;gt;(7) );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Is this a bug in gcc, and is there a workaround that onlyrelies on standard-compliant C++ ?&lt;/p&gt;</Body>
<Tags>c++,variadic-templates</Tags>
</question>
<answer>
<Body>&lt;p&gt;Indeed this seems like a bug. A workaround is to separate the default template parameter into a second function. Within &lt;code&gt;clone_ptr&lt;/code&gt; you then have two friends:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;class T1, typename ...Args&amp;gt;    friend clone_ptr&amp;lt;T1&amp;gt; make_cloned( Args ...args );template&amp;lt;class T1, class U1, typename ...Args&amp;gt;    friend clone_ptr&amp;lt;T1&amp;gt; make_cloned( Args ...args );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and the definition is easy:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, typename ...Args&amp;gt;clone_ptr&amp;lt;T&amp;gt; make_cloned( Args ...args ) { return {new T(args...)}; }template&amp;lt;typename T, typename U, typename ...Args&amp;gt;clone_ptr&amp;lt;T&amp;gt; make_cloned( Args ...args ) { return {new U(args...)}; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tested with gcc 4.8.3 and clang 3.5.&lt;/p&gt;&lt;p&gt;Edit:After investigating I was able to get your code working with gcc 4.8.3 in two different ways:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Remove the template function declaration completely&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// this is not needed:template&amp;lt;typename T, typename U, typename ...Args&amp;gt;clone_ptr&amp;lt;T&amp;gt; make_cloned( Args ...args );&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Move the default template parameter definition from the template function definition to the declaration:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, typename U = T, typename ...Args&amp;gt;clone_ptr&amp;lt;T&amp;gt; make_cloned( Args ...args );template&amp;lt;typename T, typename U, typename ...Args&amp;gt;clone_ptr&amp;lt;T&amp;gt; make_cloned( Args ...args ){    return {new U(args...)};}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I still assume that this is a problem with gcc but this way your code works.&lt;/p&gt;</Body>
</answer>
</qroot>
