<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Sorting data in a dictionary alphabetically in python</Title>
<Body>&lt;p&gt;I am learning how to use a dictionary to group the name and score together. It prints out from high to low score. I am trying to get it to only print out the highest score per person which I believe is using MAX but I can&#x27;t do it. Any ideas?&lt;/p&gt;&lt;p&gt;I also need to calculate the average score per student, so if they had 3 scores is that using &lt;code&gt;len&lt;/code&gt;? &lt;/p&gt;&lt;pre&gt;&lt;code&gt;scores = {}resultfile = open(&quot;results.txt&quot;)for line in resultfile:    (name, score) = line.split()    scores[score]=nameresultfile.close()print(&quot;The top scores were:&quot;)for each_score in sorted(scores.keys(), reverse = True):     print(scores[each_score] + each_score)&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>python,dictionary</Tags>
</question>
<answer>
<Body>&lt;p&gt;You need to ensure you are working with the correct data types here; to sort scores (integers) you want to convert from &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;; strings are sorted lexicographically (first characters first, then second, etc, just like alphabetising), integers are compared numerically. So the string &lt;code&gt;&#x27;10&#x27;&lt;/code&gt; sorts &lt;em&gt;before&lt;/em&gt; &lt;code&gt;&#x27;9&#x27;&lt;/code&gt;, but the integer &lt;code&gt;10&lt;/code&gt; sorts after &lt;code&gt;9&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;You also need to store your scores in &lt;em&gt;lists&lt;/em&gt; for each name, not just store the last name and score:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scores = {}resultfile = open(&quot;results.txt&quot;)for line in resultfile:    name, score = line.split()    score = int(score)    scores.setdefault(name, []).append(score)resultfile.close()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you have a mapping from &lt;code&gt;name&lt;/code&gt; -&gt; &lt;code&gt;[score1, score2, score3, ...]&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;You need to write a sorting key here; one that returns the maximum score for a given key in the dictionary:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sorted(scores, key=lambda key: max(scores[key]), reverse=True)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;key&lt;/code&gt; argument of the &lt;code&gt;sorted()&lt;/code&gt; function must be a function, and it is given each element that is being sorted in turn, and should return the value by which to sort. If &lt;code&gt;scores[key]&lt;/code&gt; is all scores for that given user, then &lt;code&gt;max(scores[key])&lt;/code&gt; will be their highest score.&lt;/p&gt;&lt;p&gt;If your scores were already sorted from highest score to lowest, then you don&#x27;t need a key function as sequences are compared lexicographically.&lt;/p&gt;&lt;p&gt;Next, if you need to display the highest score, then &lt;code&gt;max()&lt;/code&gt; is all you need:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sorted_by_highest_score = sorted(scores, key=lambda key: max(scores[key]), reverse=True)for name in sorted_by_highest_score:    highest_score = max(scores[name])    print(name, highest_score)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To calculate the average, all you need to do is take the sum of the scores divided by the number of scores, so using &lt;code&gt;len()&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;average = sum(scores[name]) / len(scores[name])&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Your main problem is that you&#x27;ve mapped scores to names:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scores[score]=name&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What if two people have the same score? &lt;code&gt;score[score] = name&lt;/code&gt; would overwrite (lose) one of the names since a &lt;code&gt;dict&lt;/code&gt; can only may one key (e.g. score) to one value (e.g. name). Therefore, instead, you need to map names to a list of scores:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scores.setdefault(name, []).append(name)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#dict.setdefault&quot; rel=&quot;nofollow&quot;&gt;The &lt;code&gt;setdefault&lt;/code&gt; method&lt;/a&gt; returns &lt;code&gt;scores[name]&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt; is in &lt;code&gt;scores&lt;/code&gt;, and returns a new empty list &lt;code&gt;[]&lt;/code&gt;, assigned to &lt;code&gt;scores[name]&lt;/code&gt;, otherwise. &lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;Sorting&lt;/strong&gt;:&lt;/p&gt;&lt;p&gt;With &lt;code&gt;scores&lt;/code&gt; being a dict mapping names to scores, sorting the names alphebatically is easy: you could use &lt;code&gt;sorted(scores)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;To sort &lt;code&gt;scores&lt;/code&gt; by maximum score from highest to lowest, you could use &lt;/p&gt;&lt;pre&gt;&lt;code&gt;sorted(scores, key=lambda name: max(scores[name]), reverse=True)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;See &lt;a href=&quot;http://wiki.python.org/moin/HowTo/Sorting/&quot; rel=&quot;nofollow&quot;&gt;HOWTO Sort&lt;/a&gt; for an excellent tutorial on sorting, including the use of the &lt;code&gt;key&lt;/code&gt; parameter.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;Keeping the last three values&lt;/strong&gt;:&lt;/p&gt;&lt;p&gt;To store just the last three values for each name, you could use a &lt;a href=&quot;https://docs.python.org/2/library/collections.html#collections.deque&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;collections.deque&lt;/code&gt;&lt;/a&gt;, which is a list-like container which can have a maximum length. As items are appended to the deque, older items are dropped if the maximum length has been reached.&lt;/p&gt;&lt;p&gt;For example, here is a deque with maximum length 3:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In [100]: d = collections.deque(maxlen=3)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can insert three values:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In [101]: d.extend([1,2,3])In [102]: dOut[102]: deque([1, 2, 3], maxlen=3)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But when we insert a fourth value, only the last three are kept:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In [103]: d.append(4)In [104]: dOut[104]: deque([2, 3, 4], maxlen=3)&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&lt;p&gt;Thus, to sort the names according to the maximum of the last 3 scores per person,you could use:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import collectionsscores = {}with open(&quot;results.txt&quot;) as resultfile:    for line in resultfile:        name, score = line.split()        scores.setdefault(name, collections.deque(maxlen=3)).append(float(score))print(&quot;The top and average scores were:&quot;)for name in sorted(scores, key=lambda name: max(scores[name]), reverse=True):    ave = sum(scores[name])/len(scores[name])    m = max(scores[name])    print(&#x27;{name}: {m} {a}&#x27;.format(name=name, m=m, a=ave))&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;An alternative to avoid the double computation&lt;/strong&gt;:&lt;/p&gt;&lt;p&gt;One weakness of the above code is that the quantity &lt;code&gt;max(scores[name])&lt;/code&gt; is computed twice: once in the call to &lt;code&gt;sorted&lt;/code&gt;, and once inside the &lt;code&gt;for-loop&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;One way to avoid this double computation is to precompute the values once and store the results in a list, &lt;code&gt;data&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data = []for name, vals in scores.items():    m = max(vals)    ave = sum(vals)/len(vals)    data.append((ave, name, m))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;data&lt;/code&gt; is now a list of tuples. Each tuple has the form &lt;code&gt;(ave, name, m)&lt;/code&gt;.Sorting a list of tuples is done lexicographically. The tuples are sorted according to the first element, with the second element used to break ties, and then the third to break any remaining ties, and so on.&lt;/p&gt;&lt;p&gt;So &lt;/p&gt;&lt;pre&gt;&lt;code&gt;for ave, name, m in sorted(data, reverse=True):    print(&#x27;{name}: {m} {a}&#x27;.format(name=name, m=m, a=ave))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;would iterate over the tuples in &lt;code&gt;data&lt;/code&gt;, from highest average to lowest average, and the averages are only computed once. The disadvantage of doing it this way is that it requires more memory (to store &lt;code&gt;data&lt;/code&gt;). So the two options shown above each has a pro and con. The first method requires less memory, the second requires less computation.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;A potential problem that I see from the code you&#x27;ve written is the potential in deleting students with the same score. Based on the code you&#x27;ve written here: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;(name, score) = line.split()scores[score]=name&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead, of having a check to see if scores[score] is not null, you&#x27;ve essentially replaced the past name. I don&#x27;t know what the results look like, so it may seem the case where all students have unique score. &lt;/p&gt;&lt;p&gt;Now to answer your question:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;I am trying to get it to only print out the highest score per person  which I believe is using MAX but I can&#x27;t do it. [Why is that you ask?] &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;You want to print out the highest score per person stored in the dictionary, but how you store the data does not make this simple. &lt;/p&gt;&lt;p&gt;I suggest you have the name as a key and store the score(s) as a value, then when you iterate the dictionary, you can freely use Max to get the highest score. &lt;/p&gt;&lt;p&gt;As for the average, I advise you follow the suggestion I wrote above. &lt;/p&gt;&lt;p&gt;I hope this helps. &lt;/p&gt;</Body>
</answer>
</qroot>
