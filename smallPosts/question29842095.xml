<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Incompatible operand types when using ternary conditional operator</Title>
<Body>&lt;p&gt;This code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  bool contains = std::find(indexes.begin(), indexes.end(), i) != indexes.end();  CardAbility* cardAbility = contains ? new CardAbilityBurn(i) : new CardAbilityEmpty;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;gives me the following error:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;Incompatible operand types CardAbilityBurn and CardAbilityEmpty&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;However if I write the code like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt; if (contains) {    cardAbility = new CardAbilityBurn(i); } else {    cardAbility = new CardAbilityEmpty; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;then the compiler doesn&#x27;t mind. Why so? I want to use ternary conditional operator because it is just one line. What&#x27;s wrong there? &lt;/p&gt;&lt;p&gt;I need to note (I think you might need this information) that &lt;code&gt;CardAbilityEmpty&lt;/code&gt; and &lt;code&gt;CardAbilityBurn&lt;/code&gt; both derive from &lt;code&gt;CardAbility&lt;/code&gt; so they are so to say brothers.&lt;/p&gt;&lt;p&gt;Thanks&lt;/p&gt;</Body>
<Tags>c++,ternary-operator</Tags>
</question>
<answer>
<Body>&lt;p&gt;There are &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/e4213hs1.aspx&quot; rel=&quot;nofollow&quot;&gt;several cases described for Microsoft compilers&lt;/a&gt;, how to handle operand types.&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;If both operands are of the same type, the result is of that type.&lt;/p&gt;    &lt;p&gt;If both operands are of arithmetic or enumeration types, the usual  arithmetic conversions (covered in Arithmetic Conversions) are performed to  convert them to a common type.&lt;/p&gt;    &lt;p&gt;If both operands are of pointer types or if one is a pointer type and the  other is a constant expression that evaluates to 0, pointer conversions are  performed to convert them to a common type.&lt;/p&gt;    &lt;p&gt;If both operands are of reference types, reference conversions are  performed to convert them to a common type.&lt;/p&gt;    &lt;p&gt;If both operands are of type void, the common type is type void.&lt;/p&gt;    &lt;p&gt;If both operands are of the same user-defined type, the common type is   that type.&lt;/p&gt;    &lt;p&gt;If the operands have different types and at least one of the operands   has user-defined type then the language rules are used to  determine the common type. (See warning below.)&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;And then there is a caution:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;If the types of the second and third operands are not identical, then  complex type conversion rules, as specified in the C++ Standard, are  invoked. These conversions may lead to unexpected behavior including  construction and destruction of temporary objects. For this reason, we  strongly advise you to either (1) avoid using user-defined types as  operands with the conditional operator or (2) if you do use  user-defined types, then explicitly cast each operand to a common  type.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Probably, this is the reason,  Apple deactivated this implicit conversion in LLVM.&lt;/p&gt;&lt;p&gt;So, if/else seems to be more appropriate in your case.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;C++&#x27;s type system determines expressions&#x27; types from the inside out&lt;sup&gt;[1]&lt;/sup&gt;. That means that the conditional expression&#x27;s type is determined before the assignment to &lt;code&gt;CardAbility*&lt;/code&gt; is made, and the compiler has to choose with only &lt;code&gt;CardAbilityBurn*&lt;/code&gt; and &lt;code&gt;CardAbilityEmpty*&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;As C++ features multiple inheritance and some more possible conversion paths, since none of the types is a superclass of the other the compilation stops there.&lt;/p&gt;&lt;p&gt;To compile successfully, you need to provide the missing part : cast one or both operands to the base class type, so the conditional expression as a whole can take that type.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;auto* cardAbility = contains    ? static_cast&amp;lt;CardAbility*&amp;gt;(new CardAbilityBurn(i))    : static_cast&amp;lt;CardAbility*&amp;gt;(new CardAbilityEmpty  );&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(Note the use of auto, since you already provided the destination type in the right-side expression.)&lt;/p&gt;&lt;p&gt;It &lt;em&gt;is&lt;/em&gt; however a bit convoluted, so in the end the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; structure is better-suited in this case.&lt;/p&gt;&lt;p&gt;[1] There is one exception : overloaded function names have no definitive type until you convert them (implicitly or explicitly) to one of their versions.&lt;/p&gt;</Body>
</answer>
</qroot>
