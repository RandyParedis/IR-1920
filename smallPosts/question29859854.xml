<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>C++: Writing and Reading objects into a binary file</Title>
<Body>&lt;p&gt;I decided to read/write to a file using serialization; however, it only rights a few items. Our items are dynamically allocated through a test scripts then after they are all put into the vector they will then be put written into a script. The following is the code in our main function, the switch cases where we call the functions to read and write the objects, and lastly the functions where we attempt to write and read to the file. I do not know why it&#x27;s only reading in a couple object, so any help would be great! &lt;/p&gt;&lt;pre&gt;&lt;code&gt;////////////////////////////////////////////////////////// Mainint main(int argc, char *argv[]) {    std::string optionInput;    const char *const file_name = &quot;data.dat&quot;;    menuDisplay();    while (loopBool) {        std::cin.clear();        if (selectedObject == SELECT_INIT) {            std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; &quot;Menu (No Item): &quot;;        } else {            std::cout &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; &quot;Item &quot; &amp;lt;&amp;lt; selectedObject &amp;lt;&amp;lt; &quot; Menu: &quot;;        }        try {            optionInput = menuInput();        } catch (const Input_Error &amp;amp;) {            std::cout &amp;lt;&amp;lt; &quot;Input error detected. Exiting.\n&quot;;            break;        }        catch (...) {            std::cout &amp;lt;&amp;lt; &quot;You should not be seeing this error message.\n&quot;;            break;        }        std::cout &amp;lt;&amp;lt; optionInput[0] &amp;lt;&amp;lt; std::endl;        optionSelect(optionInput[0]);    }    std::cout &amp;lt;&amp;lt; &quot;Exiting\n&quot; &amp;lt;&amp;lt; std::endl;}////////////////////////////////////////////////////////// Case &#x27;W&#x27;case &#x27;W&#x27;: {    // Writes authors to a file    std::ofstream aSaveFile(&quot;authors.dat&quot;);    boost::archive::text_oarchive aArchiveOut(aSaveFile);    aArchiveOut &amp;lt;&amp;lt; authorObject;    // Writes mediaItem objects to a file    std::ofstream mSaveFile(&quot;items.dat&quot;);    boost::archive::text_oarchive mArchiveOut(mSaveFile);    ioMediaInfo itemSender;    for (int mediaWrite = 0; mediaWrite &amp;lt; mediaObject.size(); mediaWrite++) {        itemSender.assignVariables(mediaObject[mediaWrite]);        mArchiveOut &amp;lt;&amp;lt; itemSender;    }    break;}////////////////////////////////////////////////////////// Case &#x27;Z&#x27;case &#x27;Z&#x27;: {    // Reads in authors to author array    std::ifstream aReadFile(&quot;authors.dat&quot;);    boost::archive::text_iarchive aArchiveIn(aReadFile);    aArchiveIn &amp;gt;&amp;gt; authorObject;    // Reads in mediaItems    std::ifstream mReadFile(&quot;items.dat&quot;);    boost::archive::text_iarchive mArchiveIn(mReadFile);    std::string itemType;    ioMediaInfo itemReciever;    // for (int mediaRead = 0; mediaRead &amp;lt; 20; mediaRead++)    // {    mArchiveIn &amp;gt;&amp;gt; itemReciever;    // Checks type of current object and creates a new mediaItem object in the vector to store it    // TODO: Break case statement repetition into functions for greater code reuse    itemType = itemReciever.getType();    switch (itemType[0]) {    case &#x27;*&#x27;: {        mediaObject.push_back(new mediaInfo());        selectedObject++;        mediaObject[selectedObject]-&amp;gt;setName(itemReciever.getName());        mediaObject[selectedObject]-&amp;gt;setYear(itemReciever.getYear());        mediaObject[selectedObject]-&amp;gt;setEmpty(itemReciever.getEmpty());        break;    }    case &#x27;B&#x27;: {        mediaObject.push_back(new bookInfo());        mediaObject[selectedObject]-&amp;gt;setName(itemReciever.getName());        mediaObject[selectedObject]-&amp;gt;setEmpty(itemReciever.getEmpty());        break;    }    case &#x27;V&#x27;: {        mediaObject.push_back(new videoInfo());        mediaObject[selectedObject]-&amp;gt;setName(itemReciever.getName());        mediaObject[selectedObject]-&amp;gt;setEmpty(itemReciever.getEmpty());        break;    }    case &#x27;M&#x27;: {        mediaObject.push_back(new musicInfo());        mediaObject[selectedObject]-&amp;gt;setName(itemReciever.getName());        mediaObject[selectedObject]-&amp;gt;setEmpty(itemReciever.getEmpty());        break;    }    default: { break; }    }    // }    break;}////////////////////////////////////////////////////////// assignVariable where we write to filevoid ioMediaInfo::assignVariables(mediaInfo *originalMediaObject) {    mediaItemName_ = originalMediaObject-&amp;gt;getName();    mediaItemYear_ = originalMediaObject-&amp;gt;getYear();    mediaItemPageNum_ = originalMediaObject-&amp;gt;getPage();    mediaItemPrint_ = originalMediaObject-&amp;gt;getPrint();    mediaItemValue_ = originalMediaObject-&amp;gt;getValue();    mediaItemType_ = originalMediaObject-&amp;gt;getType();    isEmpty_ = originalMediaObject-&amp;gt;isEmpty();    // mediaItemAuthor_ = originalMediaObject-&amp;gt;getAuthor();}////////////////////////////////////////////////////////// Where we read the filevoid ioMediaInfo::printData() { std::cout &amp;lt;&amp;lt; mediaItemName_ &amp;lt;&amp;lt; std::endl; }&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++,serialization,boost,vector,io</Tags>
</question>
<answer>
<Body>&lt;p&gt;I think you&#x27;re mixing paradigms. This looks very much like code taken from a bad C-style sample that used a fixed length array of manually allocated polymorphic ioMediaItem classes (that, to add insult to injury, contain and serialize a manual typeswitch &lt;code&gt;mediaInfoType_&lt;/code&gt;).&lt;/p&gt;&lt;p&gt;Then you&#x27;re driving a horrendously complicated loop to read items and maintain the collection invariants (presumably that &lt;code&gt;type==&#x27;*&#x27;&lt;/code&gt; implies &lt;code&gt;isEmpty()&lt;/code&gt; and that the vector of &lt;code&gt;mediaInfoObjects&lt;/code&gt; contains no invalid objects etc). &lt;/p&gt;&lt;p&gt;Boost serialization was made so you &lt;em&gt;do not&lt;/em&gt; have to worry about these things. Why use a complicated library if you&#x27;re going to do all the clumsy managing and baby steps after all?&lt;/p&gt;&lt;p&gt;Just let go. Here&#x27;s a taste of what it could be like:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;kbd&gt;&lt;a href=&quot;http://coliru.stacked-crooked.com/a/c96ecf3c78119406&quot; rel=&quot;nofollow&quot;&gt;Live On Coliru&lt;/a&gt;&lt;/kbd&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;fstream&amp;gt; #include &amp;lt;boost/archive/binary_oarchive.hpp&amp;gt;#include &amp;lt;boost/archive/binary_iarchive.hpp&amp;gt;#include &amp;lt;boost/serialization/serialization.hpp&amp;gt;#include &amp;lt;boost/serialization/vector.hpp&amp;gt;#include &amp;lt;boost/serialization/variant.hpp&amp;gt;#include &amp;lt;boost/serialization/shared_ptr.hpp&amp;gt;#include &amp;lt;boost/make_shared.hpp&amp;gt;namespace Media {    struct Author {        std::string name;        Author(std::string name = &quot;&quot;) : name(std::move(name)) {}    };    using AuthorRef = boost::shared_ptr&amp;lt;Author&amp;gt;;    struct CommonInfo {        std::string name;        int         year;        AuthorRef   author;    };    struct BookInfo : CommonInfo {        BookInfo() = default;        int pageNum;        int print;        int value;        BookInfo(CommonInfo ci, int pageNum, int print, int value) :            CommonInfo(ci), pageNum(pageNum), print(print), value(value)        { }    };    struct VideoInfo : CommonInfo {        VideoInfo(CommonInfo ci = {}) : CommonInfo(ci) { }    };    struct MusicInfo : CommonInfo {        MusicInfo(CommonInfo ci = {}) : CommonInfo(ci) { }    };    using Object  = boost::variant&amp;lt;BookInfo, MusicInfo, VideoInfo&amp;gt;;    using Catalog = std::vector&amp;lt;Object&amp;gt;;    ////// serialization methods    static inline std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp; os, CommonInfo const&amp;amp; ci) { return os &amp;lt;&amp;lt; ci.name &amp;lt;&amp;lt; &quot; (&quot; &amp;lt;&amp;lt; ci.author-&amp;gt;name &amp;lt;&amp;lt; &quot;)&quot;; }    // out-of-class serialization    template &amp;lt;typename Ar&amp;gt; void serialize(Ar&amp;amp; ar, VideoInfo&amp;amp; o, unsigned) { ar &amp;amp; boost::serialization::base_object&amp;lt;CommonInfo&amp;gt;(o); }    template &amp;lt;typename Ar&amp;gt; void serialize(Ar&amp;amp; ar, MusicInfo&amp;amp; o, unsigned) { ar &amp;amp; boost::serialization::base_object&amp;lt;CommonInfo&amp;gt;(o); }    template &amp;lt;typename Ar&amp;gt; void serialize(Ar&amp;amp; ar, CommonInfo&amp;amp;o, unsigned) {        ar &amp;amp; o.name &amp;amp; o.year &amp;amp; o.author;    }    template &amp;lt;typename Ar&amp;gt; void serialize(Ar&amp;amp; ar, Author&amp;amp; o,    unsigned) {        ar &amp;amp; o.name;    }    template &amp;lt;typename Ar&amp;gt; void serialize(Ar&amp;amp; ar, BookInfo&amp;amp; o,  unsigned) {        ar  &amp;amp; boost::serialization::base_object&amp;lt;CommonInfo&amp;gt;(o)            &amp;amp; o.pageNum             &amp;amp; o.print            &amp;amp; o.value            ;    }}struct Library {    std::vector&amp;lt;Media::AuthorRef&amp;gt; authors; // to allow unreferenced authors    Media::Catalog catalog;    static Library makeSample();    static Library load(std::string const&amp;amp; fname);    void save(std::string const&amp;amp; fname) const;    template &amp;lt;typename Ar&amp;gt; void serialize(Ar&amp;amp;ar,unsigned) {        ar &amp;amp; authors &amp;amp; catalog;    }};////////////////////////////////////////////////////////// Mainint main() {    Library::makeSample().save(&quot;authorsAndItems.dat&quot;);    auto cloned = Library::load(&quot;authorsAndItems.dat&quot;);    for (auto&amp;amp; obj : cloned.catalog)        std::cout &amp;lt;&amp;lt; obj &amp;lt;&amp;lt; &quot;\n&quot;;}using namespace Media;Library Library::makeSample() {    using boost::make_shared;    // shared author    auto multaScripserat = make_shared&amp;lt;Author&amp;gt;(&quot;Scripserat, Multa T.&quot;);    return {        {            multaScripserat,            boost::make_shared&amp;lt;Author&amp;gt;(Author{&quot;Sufferer, A.&quot;}), // no books/music survived        },        {            BookInfo { CommonInfo { &quot;Title 1&quot;, 1999, multaScripserat }, 453, 7, 3 },            BookInfo { CommonInfo { &quot;Title 2&quot;, 2011, multaScripserat }, 200, 5, 1 },            MusicInfo { { &quot;Pop Album&quot;, 1972, make_shared&amp;lt;Author&amp;gt;(&quot;Beatles, The&quot;) } },            MusicInfo { { &quot;Title 2&quot;, 2011, multaScripserat } },            VideoInfo { { &quot;The Battleship Potemkin&quot;, 1925, make_shared&amp;lt;Author&amp;gt;(&quot;Eisenstein, Sergei&quot;) } },        }    };}void Library::save(std::string const&amp;amp; fname) const {    std::ofstream ofs(fname, std::ios::binary);    boost::archive::binary_oarchive oa(ofs);    oa &amp;lt;&amp;lt; *this;}Library Library::load(std::string const&amp;amp; fname) {    std::ifstream ifs(fname, std::ios::binary);    boost::archive::binary_iarchive ia(ifs);    Library lib;    ia &amp;gt;&amp;gt; lib;    return lib;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Prints&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Title 1 (Scripserat, Multa T.)Title 2 (Scripserat, Multa T.)Pop Album (Beatles, The)Title 2 (Scripserat, Multa T.)The Battleship Potemkin (Eisenstein, Sergei)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The hexdump of the &lt;code&gt;authorsAndItems.dat&lt;/code&gt; file:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;0000000: 1600 0000 0000 0000 7365 7269 616c 697a  ........serializ0000010: 6174 696f 6e3a 3a61 7263 6869 7665 0b00  ation::archive..0000020: 0408 0408 0100 0000 0000 0000 0000 0000  ................0000030: 0000 0200 0000 0000 0000 0100 0000 0001  ................0000040: 0000 0003 0001 0000 0000 0000 0000 1400  ................0000050: 0000 0000 0000 5363 7269 7073 6572 6174  ......Scripserat0000060: 2c20 4d75 6c74 6120 542e 0300 0100 0000  , Multa T.......0000070: 0c00 0000 0000 0000 5375 6666 6572 6572  ........Sufferer0000080: 2c20 412e 0000 0000 0005 0000 0000 0000  , A.............0000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................00000a0: 0000 0000 0000 0000 0700 0000 0000 0000  ................00000b0: 5469 746c 6520 31cf 0700 0003 0000 0000  Title 1.........00000c0: 00c5 0100 0007 0000 0003 0000 0000 0000  ................00000d0: 0007 0000 0000 0000 0054 6974 6c65 2032  .........Title 200000e0: db07 0000 0300 0000 0000 c800 0000 0500  ................00000f0: 0000 0100 0000 0100 0000 0000 0000 0009  ................0000100: 0000 0000 0000 0050 6f70 2041 6c62 756d  .......Pop Album0000110: b407 0000 0300 0200 0000 0c00 0000 0000  ................0000120: 0000 4265 6174 6c65 732c 2054 6865 0100  ..Beatles, The..0000130: 0000 0700 0000 0000 0000 5469 746c 6520  ..........Title 0000140: 32db 0700 0003 0000 0000 0002 0000 0000  2...............0000150: 0000 0000 1700 0000 0000 0000 5468 6520  ............The 0000160: 4261 7474 6c65 7368 6970 2050 6f74 656d  Battleship Potem0000170: 6b69 6e85 0700 0003 0003 0000 0012 0000  kin.............0000180: 0000 0000 0045 6973 656e 7374 6569 6e2c  .....Eisenstein,0000190: 2053 6572 6765 69                         Sergei&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
