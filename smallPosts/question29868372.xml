<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>python asyncio run event loop once?</Title>
<Body>&lt;p&gt;I am trying to understand the asyncio library, specifically with using sockets. I have written some code in an attempt to gain understanding, &lt;/p&gt;&lt;p&gt;I wanted to run a sender and a receiver sockets asynchrounously. I got to the point where I get all data sent up till the last one, but then I have to run one more loop. Looking at how to do this, I found &lt;a href=&quot;https://stackoverflow.com/questions/29782377/is-it-possible-to-run-only-a-single-step-of-the-asyncio-event-loop&quot;&gt;this link from stackoverflow&lt;/a&gt;, which I implemented below -- but what is going on here? Is there a better/more sane way to do this than to call &lt;code&gt;stop&lt;/code&gt; followed by &lt;code&gt;run_forever&lt;/code&gt;?&lt;/p&gt;&lt;p&gt;The documentation for &lt;code&gt;stop()&lt;/code&gt; in the event loop is:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;Stop running the event loop.&lt;/p&gt;    &lt;p&gt;Every callback scheduled before stop() is called will run. Callbacks scheduled after stop() is called will not run. However, those callbacks will run if run_forever() is called again later.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;And &lt;code&gt;run_forever()&lt;/code&gt;&#x27;s documentation is:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;Run until stop() is called.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Questions:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;why in the world is &lt;code&gt;run_forever&lt;/code&gt; the only way to &lt;code&gt;run_once&lt;/code&gt;? This doesn&#x27;t even make sense&lt;/li&gt;&lt;li&gt;Is there a better way to do this?&lt;/li&gt;&lt;li&gt;Does my code look like a reasonable way to program with the asyncio library? &lt;/li&gt;&lt;li&gt;Is there a better way to add tasks to the event loop besides &lt;code&gt;asyncio.async()&lt;/code&gt;? &lt;code&gt;loop.create_task&lt;/code&gt; gives an error on my Linux system.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/cloudformdesign/b30e0860497f19bd6596&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://gist.github.com/cloudformdesign/b30e0860497f19bd6596&lt;/a&gt;&lt;/p&gt;</Body>
<Tags>python,sockets,asyncsocket,python-asyncio</Tags>
</question>
<answer>
<Body>&lt;p&gt;The &lt;code&gt;stop(); run_forever()&lt;/code&gt; trick works because of how &lt;code&gt;stop&lt;/code&gt; is implemented:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def stop(self):    &quot;&quot;&quot;Stop running the event loop.    Every callback scheduled before stop() is called will run.    Callback scheduled after stop() is called won&#x27;t.  However,    those callbacks will run if run() is called again later.    &quot;&quot;&quot;    self.call_soon(_raise_stop_error)def _raise_stop_error(*args):    raise _StopError&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, next time the event loop runs and executes pending callbacks, it&#x27;s going to call &lt;code&gt;_raise_stop_error&lt;/code&gt;, which raises &lt;code&gt;_StopError&lt;/code&gt;. The &lt;code&gt;run_forever&lt;/code&gt; loop will break only on that specific exception:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def run_forever(self):    &quot;&quot;&quot;Run until stop() is called.&quot;&quot;&quot;    if self._running:        raise RuntimeError(&#x27;Event loop is running.&#x27;)    self._running = True    try:        while True:            try:                self._run_once()            except _StopError:                break    finally:        self._running = False&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, by scheduling a &lt;code&gt;stop()&lt;/code&gt; and then calling &lt;code&gt;run_forever&lt;/code&gt;, you end up running one iteration of the event loop, then stopping once it hits the &lt;code&gt;_raise_stop_error&lt;/code&gt; callback. You may have also noticed that &lt;code&gt;_run_once&lt;/code&gt; is defined and called by &lt;code&gt;run_forever&lt;/code&gt;. You could call that directly, but that can sometimes block if there aren&#x27;t any callbacks ready to run, which may not be desirable. I don&#x27;t think there&#x27;s a cleaner way to do this currently - That answer was provided by Andrew Svetlov, who is an &lt;code&gt;asyncio&lt;/code&gt; contributor; he would probably know if there&#x27;s a better option. :)&lt;/p&gt;&lt;p&gt;In general, your code looks reasonable, though I think that you shouldn&#x27;t be using this &lt;code&gt;run_once&lt;/code&gt; approach to begin with. It&#x27;s not deterministic; if you had a longer list or a slower system, it might require more than two extra iterations to print everything. Instead, you should just send a sentinel that tells the receiver to shut down, and then wait on both the send and receive coroutines to finish:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import sysimport timeimport socketimport asyncioaddr = (&#x27;127.0.0.1&#x27;, 1064)SENTINEL = b&quot;_DONE_&quot; # ... (This stuff is the same)@asyncio.coroutinedef sending(addr, dataiter):    loop = asyncio.get_event_loop()    for d in dataiter:        print(&quot;Sending:&quot;, d)        sock = socket.socket()        yield from send_close(loop, sock, addr, str(d).encode())    # Send a sentinel    sock = socket.socket()    yield from send_close(loop, sock, addr, SENTINEL)@asyncio.coroutinedef receiving(addr):    loop = asyncio.get_event_loop()    sock = socket.socket()    try:        sock.setblocking(False)        sock.bind(addr)        sock.listen(5)        while True:            data = yield from accept_recv(loop, sock)            if data == SENTINEL:  # Got a sentinel                return            print(&quot;Recevied:&quot;, data)    finally: sock.close()def main():    loop = asyncio.get_event_loop()    # add these items to the event loop    recv = asyncio.async(receiving(addr), loop=loop)    send = asyncio.async(sending(addr, range(10)), loop=loop)    loop.run_until_complete(asyncio.wait([recv, send]))main()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, &lt;code&gt;asyncio.async&lt;/code&gt; is the right way to add tasks to the event loop. &lt;code&gt;create_task&lt;/code&gt; was added in Python 3.4.2, so if you have an earlier version it won&#x27;t exist.&lt;/p&gt;</Body>
</answer>
</qroot>
