<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>How should boost::lockfree::spsc_queue&#x27;s read_available and write_available be used?</Title>
<Body>&lt;p&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_58_0/doc/html/boost/lockfree/spsc_queue.html&quot; rel=&quot;nofollow&quot;&gt;Boost documentation for &lt;code&gt;spsc_queue&lt;/code&gt;&lt;/a&gt; says:&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;read_available()&lt;/code&gt;&lt;/strong&gt;: Thread-safe and wait-free, should only be called from the producer thread&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;write_available()&lt;/code&gt;&lt;/strong&gt;: Thread-safe and wait-free, should only be called from the consumer thread&lt;/p&gt;&lt;p&gt;I would expect the most common use case to be just the other way around: producer thread (thread &lt;em&gt;writing&lt;/em&gt; data to the queue) would need &lt;code&gt;write_available()&lt;/code&gt;, and consumer thread (thread &lt;em&gt;reading&lt;/em&gt; data from the queue) would need &lt;code&gt;read_available()&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;If I need to know how much I can write to the queue in the producer thread, should I use &lt;code&gt;QUEUE_CAPACITY - read_available()&lt;/code&gt;?&lt;/p&gt;</Body>
<Tags>c++,boost,lock-free</Tags>
</question>
<answer>
<Body>&lt;p&gt;Any kind of size assessment is going to be a race in the lockfree world.&lt;/p&gt;&lt;p&gt;Simple reason being that the size might be changed on other threads before you act on the &quot;measured size&quot;.&lt;/p&gt;&lt;p&gt;Single-Producer/Single-Consumer is &lt;em&gt;special&lt;/em&gt; in the sense that the consumer &lt;em&gt;knows&lt;/em&gt; nobody else can read from the the queue (so &quot;read_available&quot; will never decrease &lt;em&gt;unless the consumer reads it itself&lt;/em&gt;). Similarly for the producer side.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;It is clear that &lt;code&gt;write_available&lt;/code&gt; is what you need&lt;/strong&gt;. Sure, it could be &lt;em&gt;more&lt;/em&gt; by the time you actually write, but you can&#x27;t get more accurate. At least it will never be &lt;em&gt;less&lt;/em&gt; (after all there is only 1 producer thread).&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that the documentation appears to be in error (swapping the allowed threads)&lt;/p&gt;    &lt;p&gt;This made me double check, and sure enough they use the functions internally in the expected ways (contradicting the erronous documentation claim):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ConstIterator push(ConstIterator begin, ConstIterator end, T * internal_buffer, size_t max_size){    const size_t write_index = write_index_.load(memory_order_relaxed);  // only written from push thread    const size_t read_index  = read_index_.load(memory_order_acquire);    const size_t avail = write_available(write_index, read_index, max_size);&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt;I heartily suggest using the range-push shown here to automatically push the exact number of items possible. E.g.:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;auto b = messages.begin(), e = messages.end();do {    b = a.push(b, e)} while (b != e);&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
