<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Possible to autogenerate Cython bindings around a large, existing C library?</Title>
<Body>&lt;p&gt;&lt;strong&gt;In otherwords: &lt;code&gt;*.h/*.c --[??POSSIBLE??]--&amp;gt; *.pxd/*.pyx&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;OK. I’ve done (I hope) enough digging around the Internet - but I think this is a good question so I’ll ask it straight.&lt;/p&gt;&lt;p&gt;There are a few related questions (e.g. &lt;a href=&quot;https://stackoverflow.com/questions/13990317/generate-python-bindings-what-methods-programs-to-use&quot;&gt;Generate python bindings, what methods/programs to use&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/1942298/wrapping-a-c-library-in-python-c-cython-or-ctypes&quot;&gt;Wrapping a C library in Python: C, Cython or ctypes?&lt;/a&gt; ) but which don&#x27;t quite sum up the situation that I’m asking which is perhaps for a more “high-level” approach (and specifically for an existing library, not generating new C from python).&lt;/p&gt;&lt;p&gt;I’ve got a &lt;a href=&quot;https://github.com/timlukins/pylcs/blob/master/xcs.pyx&quot; rel=&quot;noreferrer&quot;&gt;little bit&lt;/a&gt; of experience of this myself having wrapped a wee bit of code before using Cython. Cython gets the thumbs up for speed and maintainability. That’s OK in my book for small/single bits of code - but, this time I’ve got a bit more on my plate… &lt;/p&gt;&lt;p&gt;And following the first of the &lt;a href=&quot;http://threevirtues.com&quot; rel=&quot;noreferrer&quot;&gt;three great virtues of a programmer&lt;/a&gt; - I want to do this with as minimal effort as possible.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;So the real question here is how can I ease the creation by automated means of the .pxd, and possibly .pyx, files (i.e. to save time and not slip up miss-typing something).&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/cython/cython/wiki/AutoPxd&quot; rel=&quot;noreferrer&quot;&gt;This here&lt;/a&gt; seems to be the only real hint/note about how to do this - but most of the projects on it are defunct, old or sourceforge. Many only seem to work for C++ (this is C I&#x27;m doing here).&lt;/p&gt;&lt;p&gt;Does anyone still use them? Recently? Has anyone got a workflow or best practice for doing this? Am I simply just better doing it by hand?&lt;/p&gt;&lt;p&gt;My library is well defined by a set of header files. One containing defs of all the C struct/types and another containing prototypes for all the functions. But it&#x27;s loooonnnggg...&lt;/p&gt;&lt;p&gt;Thanks for any tips.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;UPDATE (25th August, 2015):&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Right, so over the last few months when I had a spare moment, I tried:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;CFFI (thank for @David pointing that out) - has a noble aim of &quot;to call C code from Python without learning a 3rd language: existing alternatives require users to learn domain specific language (Cython, SWIG) or API (ctypes)” -  but it didn’t quite fit the bill as it involved a fair degree of embedded C code in the actual python files (or loading it in). This would be a pretty manual process to do for a large library. Maybe I missed something…&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SWIG is the granddaddy of Python binding, and is pretty solid. Fundamentally though, it is not “hands off” as I understand it - i.e. you need a separate specification file. For example, you have to edit all your C header files to indicate building a python module with a &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; or use other annotations. SIP has the same issue here. You don’t auto-generate from the headers, you modify them to include your own directives and annotations and create a complete &lt;em&gt;specification&lt;/em&gt; file.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cwrap - I’m on a Mac so I used this version for clang. &lt;a href=&quot;https://github.com/geggo/cwrap&quot; rel=&quot;noreferrer&quot;&gt;https://github.com/geggo/cwrap&lt;/a&gt; Really poor doc - but using the source I finally got it to run and it generated…. an empty .pyx file from a  pretty simple header of structs. Not so good.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;xdress - This showed promise. The website is down so the docs are actually seemingly &lt;a href=&quot;http://xdress-fabio.readthedocs.org/en/latest/index.html&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;. There’s an impressive amount of work gone into it and it looks straightforward to use. But it needed all the llvm headers (and a correctly linked version of clang). I had to use &lt;code&gt;brew install llvm —with-clang&lt;/code&gt;. There is a xdress&lt;code&gt;clang-3.5&lt;/code&gt; branch, but it doesn’t seem to have enough fixes done. I tried tapping homebrew/versions for an earlier version of clang (install llvm33 / llvm34) and that got it built. Anyway, I digress… it worked great for a simple example, but the resulting ctypes files for the full library was pretty garbled and refused to build. Something in the AST C-&gt;Python is a bit awry...&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ctypesgen wasn’t one I had encountered in the original search. The documentation is pretty sparse - or you might call it concise. It hasn’t seemingly had much work done on it the last 4 years either (and people enquiring on the issues list if the developers are ever going to further the project). I’ve tried running it, but sadly it seems to fall over with what I suspect/seems like issues with the Clang compiler cdefs.h use of &lt;code&gt;_attribute_&lt;/code&gt;. I’ve tried things like &lt;code&gt;-std=c11&lt;/code&gt;  but to no avail.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;In conclusion, out of all the ones I’ve looked at I think xdress came the closest to the fully automated generation of python bindings. It worked fine for the simple examples given, but couldn’t handle the more complex existing library headers, with all the complexities of forward declarations, enumerated types, void&lt;/em&gt; pointers… It seems a well designed and (for a while) well maintained project, so there is possibly some way to circumvent these issues if someone were to take it on again.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Still, the question remains, does anyone have a robust toolchain for generating python wrappers from C headers automatically? I think the reality is there always has to be a bit of manual work, and for that CFFI looks the most “modern” approach (one of the best overviews/comparisons I encountered is &lt;a href=&quot;http://eli.thegreenplace.net/2013/03/09/python-ffi-with-ctypes-and-cffi&quot; rel=&quot;noreferrer&quot;&gt;here&lt;/a&gt;) - yet it always involves a specially edited &lt;code&gt;cdef()&lt;/code&gt; version of any header files (e.g. &lt;a href=&quot;https://stackoverflow.com/questions/31795394/using-pythons-cffi-and-excluding-system-headers&quot;&gt;Using Python&amp;#39;s CFFI and excluding system headers&lt;/a&gt;). &lt;/p&gt;</Body>
<Tags>python,c,cython</Tags>
</question>
<answer>
<Body>&lt;p&gt;I find ctypesgen great for autogeneration.  I&#x27;m only using it with one or two python modules that I hope to open source, and I&#x27;ve been happy so far.  Here&#x27;s a quick example using it with zlib, but I also just tried it successfully with a few other libraries:&lt;br&gt;&lt;br&gt;(Edit: I know you mentioned ctypesgen has problems on a mac, so maybe it needs someone to tweak it to work on OSX - I don&#x27;t have OSX at home or I&#x27;d try it.)&lt;br&gt;&lt;br&gt;Get ctypesgen:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git clone https://github.com/davidjamesca/ctypesgen.git&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run short script to call ctypesgen (replace zlib info with another library): &lt;/p&gt;&lt;pre&gt;&lt;code&gt;import os                           ZLIB_INC_DIR = &quot;/usr/include&quot;       ZLIB_LIB_DIR = &quot;/usr/lib/x86_64-linux-gnu&quot;       ZLIB_LIB = &quot;libz.so&quot;       ZLIB_HEADERS = &quot;/usr/include/zlib.h&quot;       # Set location of ctypesgen.py                                      ctypesgen_path = &#x27;ctypesgen/ctypesgen.py&#x27;                                       wrapper_filename = &#x27;zlib.py&#x27;                                                 cmd = &quot;LD_LIBRARY_PATH={} {} -I {} -L {} -l {} {} -o {}&quot;.format(             ZLIB_LIB_DIR, ctypesgen_path, ZLIB_INC_DIR, ZLIB_LIB_DIR, ZLIB_LIB,      ZLIB_HEADERS, wrapper_filename)                                        print(cmd)os.system(cmd)                                                             &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Usage example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python&amp;gt;&amp;gt;&amp;gt; import zlib&amp;gt;&amp;gt;&amp;gt; zlib.compress(&quot;asdfasdfasdfasdfasdf&quot;)&#x27;x\x9cK,NIKD\xc3\x00T\xfb\x08\x17&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;</Body>
</answer>
</qroot>
