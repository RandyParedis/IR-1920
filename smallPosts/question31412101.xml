<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>invalid initialization of non-const reference of type &#x27;const char*&amp;&#x27; from an rvalue of type &#x27;const char *&#x27;</Title>
<Body>&lt;p&gt;i made a mystrcpy function,&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void mystrcpy(char *&amp;amp;stuff, const char *&amp;amp;otherstuff){    for(int i=0; stuff[i]&amp;amp;&amp;amp;other[i]; i++){        stuff[i]=other[i];    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and a main function:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int main(){    char *hello=&quot;hello&quot;;    mystrcpy(hello, &quot;bye bye&quot;/*&amp;lt;--i have no clue what data type this really is!!*/);    printf(&quot;%s\n&quot;, hello);    return 0;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;it does not compile, and says &quot;invalid initialization of non-const reference of type &#x27;const char*&amp;amp;&#x27; from an rvalue of type &#x27;const char *&#x27;&quot;...&lt;/p&gt;&lt;p&gt;when i just do:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const char *bye=&quot;bye bye&quot;;mystrcpy(hello, bye);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;it compiles without error.&lt;/p&gt;&lt;p&gt;i need to know why the former one doesnt work, thanks.&lt;/p&gt;</Body>
<Tags>c++,reference,const,reference-binding</Tags>
</question>
<answer>
<Body>&lt;p&gt;&quot;bye bye&quot; is no pointer but an array of characters. It can decay to a pointer, but it is not possible to pass it as a reference to a pointer.&lt;/p&gt;&lt;p&gt;You might change the function signature:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void mystrcpy(char *stuff, const char *otherstuff)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to inspect a type at compile time, you might use a static assertion generating a compiler error:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;type_traits&amp;gt;template &amp;lt;typename T&amp;gt;void inspect_type(T&amp;amp;){    static_assert(std::is_same&amp;lt;T, void&amp;gt;::value, &quot;inspect_type&quot;);}int main(){    inspect_type(&quot;bye bye&quot;);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;g++ gives:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;In instantiation of ‘void inspect_type(const T&amp;amp;) [with T = const char [8]]’  ...&lt;/p&gt;&lt;/blockquote&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Your function takes &lt;em&gt;a reference to a pointer&lt;/em&gt;, which is a bit unusual. Notably, this means that the input must be a pointer that has its own storage (so that you can take a reference to the pointer).&lt;/p&gt;&lt;p&gt;&lt;code&gt;const char *bye=&quot;bye bye&quot;; mystrcpy(hello, bye);&lt;/code&gt; works because &lt;code&gt;bye&lt;/code&gt; is a pointer variable, so you can take a reference to it.&lt;/p&gt;&lt;p&gt;&lt;code&gt;mystrcpy(hello, &quot;bye bye&quot;)&lt;/code&gt; fails because &lt;code&gt;&quot;bye bye&quot;&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a pointer - it&#x27;s an array of characters (a &lt;code&gt;const char [8]&lt;/code&gt;) and so there&#x27;s no pointer to take a reference to.&lt;/p&gt;&lt;p&gt;You do not need the reference &lt;code&gt;&amp;amp;&lt;/code&gt; in your &lt;code&gt;mystrcpy&lt;/code&gt; function signature - that simply makes the function harder to use, and can introduce interesting bugs if you accidentally adjust the pointers in the function (e.g. if you started doing &lt;code&gt;*stuff++ = *other++;&lt;/code&gt;).&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;&lt;code&gt;const char *&amp;amp;&lt;/code&gt; is a non-&lt;code&gt;const&lt;/code&gt; reference to a &lt;code&gt;char const *&lt;/code&gt;. The type of &lt;code&gt;&quot;bye bye&quot;&lt;/code&gt; is &lt;code&gt;char const[8]&lt;/code&gt; (the size includes the terminating null character). Your call to &lt;code&gt;mystrcpy&lt;/code&gt; will implicit convert (or &lt;em&gt;decay&lt;/em&gt;) the &lt;code&gt;char const [8]&lt;/code&gt; to a &lt;code&gt;char const *&lt;/code&gt;, but that produces an rvalue pointer, which you cannot bind to a non-&lt;code&gt;const&lt;/code&gt; reference parameter.&lt;/p&gt;&lt;p&gt;If you change your function signature to &lt;/p&gt;&lt;pre&gt;&lt;code&gt;void mystrcpy(char *&amp;amp;, const char * const&amp;amp;)//                                  ^^^^^ const reference&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;your code will compile. Similarly, if you take the pointer(s) by value, your code will compile&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void mystrcpy(char *, const char *)&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&lt;p&gt;Once you fix all that, your code will compile and probably crash at runtime, because you have undefined behavior.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;char *hello=&quot;hello&quot;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;C++11 forbids you from converting a string literal to a &lt;code&gt;char *&lt;/code&gt;, and it was deprecated behavior in C++03. Not only that, but your &lt;code&gt;mystrcpy&lt;/code&gt; call then attempts to overwrite the string literal, which is again undefined behavior.&lt;/p&gt;&lt;p&gt;Turn up your compiler&#x27;s warning level, and pay attention to the warnings. g++ produces the following warning for the line above with &lt;code&gt;-pedantic&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;warning: ISO C++ forbids converting a string constant to &#x27;char*&#x27; [-Wpedantic]&lt;/p&gt;&lt;pre&gt;&lt;code&gt; char *hello=&quot;hello&quot;;             ^&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;</Body>
</answer>
</qroot>
