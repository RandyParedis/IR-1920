<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>C++ Ambiguity issue</Title>
<Body>&lt;p&gt;Let the following classes :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class BaseClass{    class OnSomeEventListener    {    public:        enum SomeEnum { BLABLA }        virtual void OnSomeEvent( SomeEnum eventData ) = 0;    }};class ChildClass :    public BaseClass,    public BaseClass::OnSomeEventListener{    virtual void OnSomeEvent( BaseClass::OnSomeEventListener::SomeEnum eventData );}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;My question is : why do I need to specify &lt;code&gt;BaseClass::&lt;/code&gt; in front of &lt;code&gt;OnSomeEventListener::SomeEnum eventData&lt;/code&gt; in the method &lt;code&gt;virtual void OnSomeEvent( BaseClass::OnSomeEventListener::SomeEnum eventData );&lt;/code&gt; ?&lt;/p&gt;&lt;p&gt;If I don&#x27;t do it, it says that &lt;code&gt;OnSomeEventListener&lt;/code&gt; is ambiguous between &lt;code&gt;BaseClass::OnSomeEventListener&lt;/code&gt; and &lt;code&gt;BaseClass::OnSomeEventListener::OnSomeEventListener&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Why would it think i&#x27;m referencing the constructor instead of the &lt;code&gt;OnSomeEventListener&lt;/code&gt; type ? Why would i need to prefix the argument type with &lt;code&gt;BaseClass::&lt;/code&gt; since I&#x27;m already inside &lt;code&gt;BaseClass&lt;/code&gt; ?&lt;/p&gt;&lt;p&gt;Thank you.&lt;/p&gt;</Body>
<Tags>c++,inheritance,ambiguous</Tags>
</question>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;Why would i need to prefix the argument type with BaseClass:: since I&#x27;m already inside BaseClass ?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;You are inside &lt;code&gt;BaseClass&lt;/code&gt;, but you are &lt;em&gt;also&lt;/em&gt; inside &lt;code&gt;OnSomeEventListener&lt;/code&gt; because you inherit from both. &lt;/p&gt;&lt;p&gt;When the compiler parses a name, it doesn&#x27;t think &lt;em&gt;&quot;I need a type here, can this be an enum?&quot;&lt;/em&gt;, instead it thinks &lt;em&gt;&quot;I have a name here, what can it be?&quot;&lt;/em&gt;. And in your case it can be two different things, depending on which base class is searched for the name.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;You don&#x27;t need the &lt;code&gt;BaseClass::OnSomeEventListener&lt;/code&gt; scope at all since you bring that in with your inheritance of &lt;code&gt;BaseClass::OnSomeEventListener&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class ChildClass:  public BaseClass,  public BaseClass::OnSomeEventListener{  virtual void OnSomeEvent(SomeEnum eventData);};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That being said &lt;code&gt;OnSomeEventListener&lt;/code&gt; in the &lt;code&gt;ChildClass&lt;/code&gt; is ambiguous since it can be either the constructor or the class from that scope since you inherit both.&lt;/p&gt;&lt;p&gt;When trying to use the name &lt;code&gt;OnSomeEventListener::SomeEnum&lt;/code&gt;, it wasn&#x27;t preceded with &lt;code&gt;::&lt;/code&gt; so the compiler uses the &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/unqualified_lookup&quot; rel=&quot;nofollow&quot;&gt;unqualified lookup rules&lt;/a&gt; to create a &lt;em&gt;lookup set&lt;/em&gt;. And from the compiler error you can see it first only considers &lt;code&gt;OnSomeEventListener&lt;/code&gt; which directly becomes ambiguous in that scope since both the class itself and the constructor matches.&lt;/p&gt;</Body>
</answer>
</qroot>
