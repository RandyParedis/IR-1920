<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Unloading a ByteArray using Actionscript 3</Title>
<Body>&lt;p&gt;How do I forcefully unload a &lt;code&gt;ByteArray&lt;/code&gt; from memory using ActionScript 3?&lt;/p&gt;&lt;p&gt;I have tried the following:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// First non-working solutionbyteArray.length = 0;byteArray = new ByteArray();// Second non-working solutionfor ( var i:int=0; i &amp;lt; byteArray.length; i++ ) {    byteArray[i] = null;}&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>arrays,actionscript-3,apache-flex</Tags>
</question>
<answer>
<Body>&lt;p&gt;Have a look at this article&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.gskinner.com/blog/archives/2006/06/as3_resource_ma.html&quot; rel=&quot;noreferrer&quot;&gt;http://www.gskinner.com/blog/archives/2006/06/as3_resource_ma.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;IANA actionscript programmer, however the feeling I&#x27;m getting is that, because the garbage collector might not run when you want it to.&lt;/p&gt;&lt;p&gt;Hence&lt;a href=&quot;http://www.craftymind.com/2008/04/09/kick-starting-the-garbage-collector-in-actionscript-3-with-air/&quot; rel=&quot;noreferrer&quot;&gt;http://www.craftymind.com/2008/04/09/kick-starting-the-garbage-collector-in-actionscript-3-with-air/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;So I&#x27;d recommend trying out their collection code and see if it helps&lt;/p&gt;&lt;pre&gt;&lt;code&gt;private var gcCount:int;private function startGCCycle():void{    gcCount = 0;    addEventListener(Event.ENTER_FRAME, doGC);}private function doGC(evt:Event):void{    flash.system.System.gc();    if(++gcCount &amp;gt; 1){        removeEventListener(Event.ENTER_FRAME, doGC);        setTimeout(lastGC, 40);    }}private function lastGC():void{    flash.system.System.gc();}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;(I&#x27;m not positive about this, but...)&lt;/p&gt;&lt;p&gt;AS3 uses a non-deterministic garbage collection. Which means that unreferenced memory will be freed up whenever the runtime feels like it (typically not unless there&#x27;s a reason to run, since it&#x27;s an expensive operation to execute). This is the same approach used by most modern garbage collected languages (like C# and Java as well).&lt;/p&gt;&lt;p&gt;Assuming there are no other references to the memory pointed to by &lt;code&gt;byteArray&lt;/code&gt; or the items within the array itself, the memory will be freed at some point after you exit the scope where &lt;code&gt;byteArray&lt;/code&gt; is declared.&lt;/p&gt;&lt;p&gt;You can force a garbage collection, though you really shouldn&#x27;t. If you do, do it only for testing... if you do it in production, you&#x27;ll hurt performance much more than help it.&lt;/p&gt;&lt;p&gt;To force a GC, try (yes, twice):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;flash.system.System.gc();flash.system.System.gc();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;http://www.craftymind.com/2008/04/09/kick-starting-the-garbage-collector-in-actionscript-3-with-air/&quot; rel=&quot;noreferrer&quot;&gt;You can read more here&lt;/a&gt;.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Unfortunately when it comes to memory management in &lt;em&gt;Flash/actionscript&lt;/em&gt; there isn&#x27;t a whole lot you can do. ActionScript was designed to be easy to use (so they didn&#x27;t want people to have to worry about memory management)&lt;/p&gt;&lt;p&gt;The following is a workaround, instead of creating a &lt;code&gt;ByteArray&lt;/code&gt; variable try this.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;var byteObject:Object = new Object();byteObject.byteArray = new ByteArray();...//Then when you are finished delete the variable from byteObjectdelete byteObject.byteArray;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where &lt;code&gt;byteArray&lt;/code&gt; is a dynamic property of &lt;code&gt;byteObject&lt;/code&gt;, you can free the memory that was allocated for it.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I believe you have answered your own question...&lt;/p&gt;&lt;p&gt;&lt;code&gt;System.totalMemory&lt;/code&gt; gives you the total amount of memory being &quot;used&quot;, not allocated. It is accurate that your application may only be using 20mb, but it has 5mb that is free for future allocations.&lt;/p&gt;&lt;p&gt;I&#x27;m not sure if the Adobe docs would shed light on the way that it manages memory...&lt;/p&gt;</Body>
</answer>
</qroot>
