<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>SetPixelFormat fail when using WGL_SAMPLE_BUFFERS_ARB / WGL_SAMPLES_ARB</Title>
<Body>&lt;p&gt;I decided to add MSAA support into my application and therefor I checked what&#x27;s up to do. The examples I found always refer to WGL_SAMPLE_BUFFERS_ARB / WGL_SAMPLES_ARB in the pixelformatdescriptor to do that. I am using glew right now:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int DesiredColorBits   = 32;int DesiredStencilBits = 0;int DesiredDepthBits   = 24;int MajorVersion=3;int MinorVersion=3;PIXELFORMATDESCRIPTOR temppfd =    {        sizeof(PIXELFORMATDESCRIPTOR),        1,        PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,        PFD_TYPE_RGBA,        DesiredColorBits,        0, 0, 0, 0, 0, 0,        0, 0,        0, 0, 0, 0, 0,        DesiredDepthBits,        0,//DesiredStencilBits,        0,        PFD_MAIN_PLANE,        0,        0, 0, 0    };HDC TemphDC;TemphDC = GetDC( hWnd );int nPixelFormat = ChoosePixelFormat( TemphDC, &amp;amp;temppfd );check(nPixelFormat);verify(SetPixelFormat( TemphDC, nPixelFormat, &amp;amp;temppfd ));// oldstyle context to init glew.HGLRC tempContext = wglCreateContext(TemphDC);wglMakeCurrent(TemphDC, tempContext);//init glewglewExperimental = GL_TRUE;GLenum err = glewInit();if (GLEW_OK != err)    errorprintf(TEXT(&quot;Error: Init glew failed: %s&quot;), glewGetErrorString(err)));else debugprintf( TEXT(&quot;Glew successfully initialized.&quot;));ReleaseDC(hWnd, TemphDC);//Now init pure OpenGL &amp;gt;= 3.3 context.if (WGLEW_ARB_create_context &amp;amp;&amp;amp; WGLEW_ARB_pixel_format){    wglMakeCurrent(NULL, NULL);    wglDeleteContext(tempContext);    PIXELFORMATDESCRIPTOR pfd;    memset(&amp;amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR));    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);    pfd.nVersion = 1;    pfd.dwFlags = PFD_DOUBLEBUFFER | PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;    pfd.iPixelType = PFD_TYPE_RGBA;    pfd.cColorBits = DesiredColorBits;    pfd.cDepthBits = DesiredDepthBits;    pfd.iLayerType = PFD_MAIN_PLANE;    int iPixelFormatAttribList[30];    iPixelFormatAttribList[0] = WGL_DRAW_TO_WINDOW_ARB;    iPixelFormatAttribList[1] = GL_TRUE;    iPixelFormatAttribList[2] = WGL_SUPPORT_OPENGL_ARB;    iPixelFormatAttribList[3] = GL_TRUE;    iPixelFormatAttribList[4] = WGL_DOUBLE_BUFFER_ARB;    iPixelFormatAttribList[5] = GL_TRUE;    iPixelFormatAttribList[6] = WGL_PIXEL_TYPE_ARB;    iPixelFormatAttribList[7] = WGL_TYPE_RGBA_ARB;    iPixelFormatAttribList[8] = WGL_COLOR_BITS_ARB;    iPixelFormatAttribList[9] = DesiredColorBits;    iPixelFormatAttribList[10] = WGL_DEPTH_BITS_ARB;    iPixelFormatAttribList[11] = DesiredDepthBits;    iPixelFormatAttribList[12] = WGL_STENCIL_BITS_ARB;    iPixelFormatAttribList[13] = 0;    iPixelFormatAttribList[14] = WGL_SAMPLE_BUFFERS_ARB;    iPixelFormatAttribList[15] = GL_TRUE;    iPixelFormatAttribList[16] = WGL_SAMPLES_ARB;    iPixelFormatAttribList[17] = NumAASamples;    iPixelFormatAttribList[18] = 0;    int iPixelFormat, iNumFormats;    wglChoosePixelFormatARB(hDC, iPixelFormatAttribList, NULL, 1, &amp;amp;iPixelFormat, (GLuint*)&amp;amp;iNumFormats);    if( iNumFormats == 0 )    {        debugprintf(TEXT(&quot;Couldn&#x27;t support multisampling&quot;));    }    else debugprintf(TEXT(&quot;Available formats: %i %i&quot;),iNumFormats,iPixelFormat);    int iContextAttribs[] =    {        WGL_CONTEXT_MAJOR_VERSION_ARB, MajorVersion,        WGL_CONTEXT_MINOR_VERSION_ARB, MinorVersion,        WGL_CONTEXT_FLAGS_ARB, ContextFlags,        0 // End of attributes list    };    // pfd oldstyle crap...    debugprintf(TEXT(&quot;DesiredColorBits: %i&quot;), DesiredColorBits);    debugprintf(TEXT(&quot;DesiredDepthBits: %i&quot;), DesiredDepthBits);    if (!SetPixelFormat(hDC, iPixelFormat, &amp;amp;pfd))    {        debugprintf(TEXT(&quot;Setting PixelFormat %i failed!&quot;), iPixelFormat);        iPixelFormat = ChoosePixelFormat(hDC, &amp;amp;pfd);         if (!SetPixelFormat(hDC, iPixelFormat, &amp;amp;pfd))            errorprintf(TEXT(&quot;Error: SetPixelFormat %i failed.&quot;),iPixelFormat);    }    hRC = wglCreateContextAttribsARB(hDC, 0, iContextAttribs);}else  errorprintf(TEXT(&quot;Error: Init glew failed: %s&quot;), glewGetErrorString(err)));if(hRC){    MakeCurrent();    debugprintf( TEXT(&quot;GL_VENDOR     : %s&quot;), glGetString(GL_VENDOR));    debugprintf( TEXT(&quot;GL_RENDERER   : %s&quot;), glGetString(GL_RENDERER));    debugprintf( TEXT(&quot;GL_VERSION    : %s&quot;), glGetString(GL_VERSION));    debugprintf( TEXT(&quot;GLEW Version  : %s&quot;), glewGetString(GLEW_VERSION));    int NumberOfAASamples=0, NumberOfSampleBufers;    glGetintegerv(GL_SAMPLE_BUFFERS,&amp;amp;NumberOfSampleBufers);    glGetintegerv(GL_SAMPLES,&amp;amp;NumberOfAASamples);    debugprintf(TEXT(&quot;SampleBuffers: %i, NumAASamples: (%i/%i)&quot;),NumberOfSampleBufers, NumberOfAASamples,NumAASamples);    int NumberOfExtensions=0;    glGetintegerv(GL_NUM_EXTENSIONS, &amp;amp;NumberOfExtensions);    for (int i = 0; i&amp;lt;NumberOfExtensions; i++)    {        FString ExtensionString = glGetStringi(GL_EXTENSIONS, i));        debugprintf(NAME_DevLoad, TEXT(&quot;GL_EXTENSIONS(%i) : %s&quot;), i, ExtensionString);    }    debugprintf( TEXT(&quot;OpenGL %i.%i context initialized!&quot;), MajorVersion,MinorVersion);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So far, so good, I am getting my tempcontext to init glew, it initializes correctly and is ready to use, also no problems with SetPixelFormat- without sample buffers at least. Now if I am adding WGL_SAMPLE_BUFFERS_ARB and WGL_SAMPLES_ARB I still get a pixelformat back from wglChoosePixelFormatARB (indeed iNumFormats returns 32), but SetPixelFormat always fails with the pixelformat returned from it.I tried various color and depth bits, but no matter what I do, I can&#x27;t seem to find a way to make this work. I also tried this on my NVidia and an Intel card, no AA preset is forced either.&lt;/p&gt;&lt;p&gt;Now- is there a different way to get this result? I take it that SetPixelformat is &quot;deprecated&quot;, partially even obsolete from what I read, yet I seem to need it here to enable MSAA, which is a kinda annoying dependency.Did I miss something?&lt;/p&gt;</Body>
<Tags>c++,opengl</Tags>
</question>
<answer>
<Body>&lt;p&gt;I solved it by changing one thing, I created a completely standalone window for glew init like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;LRESULT CALLBACK WndProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam){    switch(uiMsg)    {        case WM_CLOSE:            PostQuitMessage(0);            break;        default:            return DefWindowProc(hWnd, uiMsg, wParam, lParam);    }    return 0;}PIXELFORMATDESCRIPTOR temppfd ={    sizeof(PIXELFORMATDESCRIPTOR),    1,    PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,    PFD_TYPE_RGBA,    DesiredColorBits,    0, 0, 0, 0, 0, 0,    0, 0,    0, 0, 0, 0, 0,    DesiredDepthBits,    0,//DesiredStencilBits,    0,    PFD_MAIN_PLANE,    0,    0, 0, 0};DWORD Style = WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;WNDCLASSEX WndClassEx;memset(&amp;amp;WndClassEx, 0, sizeof(WNDCLASSEX));WndClassEx.cbSize = sizeof(WNDCLASSEX);WndClassEx.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;WndClassEx.lpfnWndProc = WndProc;WndClassEx.hInstance = hInstance;WndClassEx.hIcon = LoadIcon(NULL, IDI_APPLICATION);WndClassEx.hIconSm = LoadIcon(NULL, IDI_APPLICATION);WndClassEx.hCursor = LoadCursor(NULL, IDC_ARROW);WndClassEx.lpszClassName = L&quot;Win32OpenGLWindow&quot;;if(RegisterClassEx(&amp;amp;WndClassEx) == 0){    debugprintf(TEXT(&quot;RegisterClassEx failed!&quot;));}HWND TemphWnd = CreateWindowEx(WS_EX_APPWINDOW, WndClassEx.lpszClassName,  L&quot;InitWIndow&quot;, Style, 0, 0, SizeX, SizeY, NULL, NULL, hInstance, NULL);HDC TemphDC = GetDC( TemphWnd );INT nPixelFormat = ChoosePixelFormat( TemphDC, &amp;amp;temppfd );check(nPixelFormat);verify(SetPixelFormat( TemphDC, nPixelFormat, &amp;amp;temppfd ));// oldstyle context to init glew.HGLRC tempContext = wglCreateContext(TemphDC);wglMakeCurrent(TemphDC, tempContext);//init glewglewExperimental = GL_TRUE;GLenum err = glewInit();if (GLEW_OK != err)    errorprintf(TEXT(&quot;Error: Init glew failed: %s&quot;),glewGetErrorString(err));else debugprintf(TEXT(&quot;Glew successfully initialized.&quot;));//Now init pure OpenGL &amp;gt;= 3.3 context.if (WGLEW_ARB_create_context &amp;amp;&amp;amp; WGLEW_ARB_pixel_format){    wglMakeCurrent(NULL, NULL);    wglDeleteContext(tempContext);    ReleaseDC(TemphWnd, TemphDC);    DestroyWindow(TemphWnd);...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After destroying this temp window and then using the actual one for the game like shown above it was possible to use SetPixelFormat with the new options. Why it didn&#x27;t cause any trouble like this when not adding WGL_SAMPLE_BUFFERS_ARB / WGL_SAMPLES_ARB I don&#x27;t know, I assume that it is not possible to really change the pixelformat for a window afterwards, unrelated to any hWnd, hDC or context and if those are destroyed or renewed in between. Many examples and tutorials in the web are not clear about that and are showing this indeed the wrong way too. In short, create a tempwindow, temphWnd and temphDC, then init glew, destroy all temporary stuff, then go on creating the context you really want with the real window, hWnd and hDC, otherwise you&#x27;ll buy some trouble.&lt;/p&gt;&lt;p&gt;Yes, I think it is a real mess to get clean context in windows. &lt;/p&gt;&lt;p&gt;Either way, I hope this will help others.&lt;/p&gt;</Body>
</answer>
</qroot>
