<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Why is a const std::random_device not possible?</Title>
<Body>&lt;p&gt;I am asking myself the question why&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;random&amp;gt;struct A{        std::random_device rd; // or any other generator std::mersenne_twister...   void doStuff() const {       auto v = rd();   }};const A a;  a.doStuff(); &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;does not work since &lt;code&gt;random_device::operator()&lt;/code&gt; is not &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;I thought maybe the random device can still be used when constant but it cannot be seeded again but that is not the case (internal state is obviously not mutable in &lt;code&gt;std::random_device&lt;/code&gt;)...&lt;/p&gt;&lt;p&gt;I want to make class A being properly defined (&lt;code&gt;doStuff()&lt;/code&gt; is a const method) and now I suddenly need to use &lt;code&gt;mutable std::random_device rd;&lt;/code&gt; isn&#x27;t that ugly?&lt;/p&gt;&lt;p&gt;Is there any reason for this design?&lt;/p&gt;</Body>
<Tags>c++,random</Tags>
</question>
<answer>
<Body>&lt;p&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/random_device/operator()&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;std::randome_device::operator()()&lt;/code&gt;&lt;/a&gt; is non-&lt;code&gt;const&lt;/code&gt; since it might modify the internal state of the object. &lt;code&gt;std::random_device&lt;/code&gt; may be a pseudo random number generator, which uses an internal state for generating numbers. Each time you generate a number you have to modify the internal state, otherwise you would get the same number every single time.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;&lt;code&gt;const&lt;/code&gt; can mean many things. It could mean any or all of the following:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Given the same object state and parameters, the same result will happen.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The function will not change the internal state of the object on which it operates.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The function accesses the state of the object in a &lt;a href=&quot;https://stackoverflow.com/questions/14127379/does-const-mean-thread-safe-in-c11&quot;&gt;thread-safe way&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;em&gt;None of these&lt;/em&gt; are true for &lt;code&gt;random_device::operator()&lt;/code&gt;. You will get different results back; &lt;em&gt;that&#x27;s the whole point of the function&lt;/em&gt;. State that is internal to the object will be affected by requesting it (in one way or another). And the function is most assuredly &lt;em&gt;not&lt;/em&gt; thread-safe; calling it on the same object from different threads can cause all manor of badness.&lt;/p&gt;&lt;p&gt;The same is true of any RNG. Getting a random number from an RNG is &lt;em&gt;inherently&lt;/em&gt; a non-constant process. That&#x27;s why the design of C++11 RNGs require the &lt;code&gt;operator()&lt;/code&gt; to not be declared &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;As for your goal:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;I want to make class A being properly defined (&lt;code&gt;doStuff()&lt;/code&gt; is a const method) and now I suddenly need to use &lt;code&gt;mutable std::random_device rd;&lt;/code&gt; isn&#x27;t that ugly?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;That depends on what you mean by &lt;code&gt;const&lt;/code&gt;. Obviously #2 is out, since you will be changing the &lt;code&gt;mutable&lt;/code&gt; state. However, you can still provide #1, for a particular definition of &quot;same result&quot;. That is, the &quot;stuff&quot; that &lt;code&gt;doStuff&lt;/code&gt; does will be logically consistent. Not binary identical obviously, but within the bounds of the behavior of the function. That&#x27;s sufficient to be &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;And you can even provide #3, by wrapping your access to your &lt;code&gt;mutable&lt;/code&gt; RNG object in a mutex.&lt;/p&gt;&lt;p&gt;Cases like this are exactly why &lt;code&gt;mutable&lt;/code&gt; was invented. It&#x27;s not ugly; you&#x27;re simply using the feature for what it is designed for. To allow you to access some non-&lt;code&gt;const&lt;/code&gt; objects in a way that is logically &lt;code&gt;const&lt;/code&gt; &lt;em&gt;to the caller&lt;/em&gt;.&lt;/p&gt;</Body>
</answer>
</qroot>
