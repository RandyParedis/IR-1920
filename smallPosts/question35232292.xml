<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Transform and remap an equirectangular image with a 90° roll</Title>
<Body>&lt;p&gt;I have to &lt;strong&gt;transform and remap an equirectangular image&lt;/strong&gt; to an other equirectangular image with a 90° roll.&lt;/p&gt;&lt;p&gt;I did it with &lt;a href=&quot;http://ggnome.com/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Pano2VR&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;The problem is that I have to do it &lt;strong&gt;programmatically from the server side&lt;/strong&gt;. So I can&#x27;t use a G.U.I. to do it.&lt;/p&gt;&lt;p&gt;First, I oriented my research to &lt;em&gt;imagemagick&lt;/em&gt;. I tried the &lt;a href=&quot;http://www.fmwconcepts.com/imagemagick/&quot; rel=&quot;nofollow noreferrer&quot;&gt;Fred ImageMagick scripts&lt;/a&gt; but could not find anyone to do what I want to do. Moreover, the processing time of an image appears very long compared to &lt;em&gt;Pano2VR&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;I directed my investigations to &lt;em&gt;OpenCV&lt;/em&gt; and the &lt;a href=&quot;https://www.github.com/FoxelSA/libgnomonic&quot; rel=&quot;nofollow noreferrer&quot;&gt;libgnomonic&lt;/a&gt;. It&#x27;s presently the most interesting way. This library allows te user to transform projections (equirectangular to rectilinear and vice versa) or &lt;a href=&quot;https://www.github.com/FoxelSA/libgnomonic/wiki/Equirectangular%20mapping%20transformation&quot; rel=&quot;nofollow noreferrer&quot;&gt;make equirectangular mapping transformation&lt;/a&gt;. I played with &lt;a href=&quot;https://www.github.com/FoxelSA/norama-suite&quot; rel=&quot;nofollow noreferrer&quot;&gt;Norama-suite&lt;/a&gt; wich contains some scripts to deal with the library. For example, I would to convert an rectilinear image to an equirectangular but &lt;strong&gt;the output was just a black background image&lt;/strong&gt; (why ? I didn&#x27;t find the answer).&lt;/p&gt;&lt;p&gt;However, this second link could resolve my problem. I have this image : &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/FoxelSA/libgnomonic/raw/master/doc/image/release-v0_4/rot-yz-equirectangular.jpg?raw=true&quot; /&gt;&lt;/p&gt;&lt;p&gt;and I want to transform it to this image &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/FoxelSA/libgnomonic/raw/master/doc/image/release-v0_4/equirectangular.jpg?raw=true&quot; /&gt;&lt;/p&gt;&lt;p&gt;Well, I&#x27;m not comfortable at all with C. I think I should use this two files :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.github.com/FoxelSA/libgnomonic/blob/master/src/gnomonic-transform.h&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.github.com/FoxelSA/libgnomonic/blob/master/src/gnomonic-transform.h&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.github.com/FoxelSA/libgnomonic/blob/master/src/gnomonic-transform.c&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.github.com/FoxelSA/libgnomonic/blob/master/src/gnomonic-transform.c&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;But I don&#x27;t know how. And above all, I want to understand.&lt;/p&gt;&lt;p&gt;Am I on the right way ? What transformation is applied on the first image ? Is there a way to do it with python or a bash script ? &lt;/p&gt;&lt;p&gt;Well, thank you for your help.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;**EDIT Transposition of C in python **The following code didn&#x27;t work and return and IndexError.However I tried to catch and pass the exception and the first right part of the image did not seem changed.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import mathfrom PIL import Imageimg = Image.open(&quot;img1.jpg&quot;)img = img.convert(&#x27;RGB&#x27;)pixel = img.load()width, height = img.sizeimg2 = img.copy()for y in xrange(height):    for x in xrange(width):        xx = 2*(y+0.5) / width - 1.0        yy = 2*(y+0.5)/ height - 1.0        lng = math.pi * xx        lat = 0.5 * math.pi * yy        # NOTE!  These axes are transposed because that&#x27;s what the question is about        Z = math.cos(lat) * math.cos(lng)  # normally X        Y = math.cos(lat) * math.sin(lng)  # normally Y        X = -math.sin(lat)                 # normally -Z        D = math.sqrt(X*X+Y*Y)        lat = math.atan2(Z, D)             # ? normally lat = math.asin(Z)        lng = math.atan2(Y, X)        #ix and iy must be integers        ix = int((0.5 * lng / math.pi + 0.5) * width - 0.5)        iy = int((lat/math.pi + 0.5) * height  - 0.5)        #not sure of this part to remap the image        newpixel = pixel[ix, iy]        img2.putpixel([(x+width/4) % width, y], newpixel)        #I tries as mentionned in the following code to invert x and y in the two previous lines but the index error out of range comes back img2.show()&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>python,c,image,opencv</Tags>
</question>
<answer>
<Body>&lt;p&gt;Your transformation has two steps. The first step is a transformation of the projection sphere, the second is the 90° roll.&lt;/p&gt;&lt;p&gt;A 90° roll of an equirectangular image is just a horizontal shift of a quarter of the image width. The first transformation is more complicated: You basically want to rotate the sphere so that the north pole is at latitude 0 and longitude 0 (somewhere in the Gulf of Guinea, if you take thze Earth as reference.)&lt;/p&gt;&lt;p&gt;You can go about this transformation with these steps;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Translate the x and y position of each pixel into a longitude, &amp;minus;&amp;pi; &amp;le; long &amp;le; &amp;pi;, and a latitude, &amp;minus;&amp;pi;/2 &amp;le; lat &amp;le; &amp;pi;/2. This is a linear transformation.&lt;/li&gt;&lt;li&gt;Create x, y, and z coordinates of the corresponding longitude and latitude on a unit sphere; positive z is the north pole.&lt;/li&gt;&lt;li&gt;Rotate these Cartesian coordinates. In your case, you just have to swap some dimensions, but this could be a general transformation with any transformation matrix.&lt;/li&gt;&lt;li&gt;Calculate the longituide and latitude of the rotated coordinates.&lt;/li&gt;&lt;li&gt;Transform the new longitude and latitude to a pixel position.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Here&#x27;s C code that works. (I know that you have tagged the question with Python, but the code below is mostly formulas that work similarly in python. You have to take care: All of the number are floating point numbers except the pixel indixes &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;ix&lt;/code&gt;and &lt;code&gt;iy&lt;/code&gt;. I would have done this in Python, but I have no experience with the Python Image Library.)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;for (y = 0; y &amp;lt; height; y++) {    for (x = 0; x &amp;lt; width; x++) {        double xx = 2 * (x + 0.5) / width - 1.0;        double yy = 2 * (y + 0.5) / height - 1.0;        double lng = pi * xx;        double lat = 0.5 * pi * yy;        double X, Y, Z;        double D;        int ix, iy;        Z = cos(lat) * cos(lng);    // corresponds to original x        Y = cos(lat) * sin(lng);    // corresponds to original y        X = -sin(lat);              // corresponds to original z        D = sqrt(X*X + Y*Y);        // distance in the XY plane        lat = atan2(Z, D);        lng = atan2(Y, X);        ix = (0.5 * lng / pi + 0.5) * width - 0.5;        iy = (lat / pi + 0.5) * height - 0.5;        dest[y][(x + width / 4) % width] = src[iy][ix];                                    // width/4 offset ist the 90° roll                                    // % width wraps the longitude    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The quality of the resulting image is okay, but not as good as that of your reference image, especially near the poles. A better algorithm woul average and smoothze the colour values. The algorithm above just maps one destination pixel to a source pixel.&lt;/p&gt;</Body>
</answer>
</qroot>
