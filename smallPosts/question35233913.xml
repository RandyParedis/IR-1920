<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>getting not-full answer as the output of the function</Title>
<Body>&lt;p&gt;I wrote this code for a function that implements the sqrt function using a technique known as the Babylonian function. It approximates the square root of a number, n, by repeatedly performing a calculation using the following formula:&lt;/p&gt;&lt;p&gt;nextGuess = (lastGuess + (n / lastGuess)) / 2&lt;/p&gt;&lt;p&gt;When nextGuess and lastGuess are very close, nextGuess is the approximated square root. The initial guess can be any positive value (e.g., 1). This value will be the starting value for lastGuess. If the difference between nextGuess and lastGuess is less than a very small number, such as 0.0001, then nextGuess is the approximated square root of n. If not, nextGuess becomes lastGuess and the approximation process continues. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;def babyl(n):    lastGuess=1.0    while True:        nextGuess=float(lastGuess+float(n/lastGuess))/2.0        if abs(lastGuess-nextGuess)&amp;lt;0.0001:            return nextGuess        else:            lastGuess=nextGuess            nextGuess=float(lastGuess+float(n/lastGuess))/2.0            if abs(lastGuess-nextGuess)&amp;lt;0.0001:                return nextGuess&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The output of the function is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; babyl(9)3.000000001396984&amp;gt;&amp;gt;&amp;gt; babyl(16)4.000000000000051&amp;gt;&amp;gt;&amp;gt; babyl(81)9.000000000007091&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Very long after the dot as you see.&lt;/p&gt;&lt;p&gt;I want to write a test program where the user enters a positive integerAnd the functions return its approx. sqrt value.&lt;/p&gt;&lt;p&gt;So I coded:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;n=input(&quot;Please sir, enter a positive integer number and you&#x27;ll get the approximated sqrt:&quot;)print babyl(n)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And the answer for that is very short:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Please sir, enter a positive integer number and you&#x27;ll get the approximated sqrt:164.0&amp;gt;&amp;gt;&amp;gt; ================================ RESTART ================================&amp;gt;&amp;gt;&amp;gt; Please sir, enter a positive integer number and you&#x27;ll get the approximated sqrt:42.0&amp;gt;&amp;gt;&amp;gt; ================================ RESTART ================================&amp;gt;&amp;gt;&amp;gt; Please sir, enter a positive integer number and you&#x27;ll get the approximated sqrt:93.0000000014&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Can someone tell me what is the difference between the function and the test?&lt;/p&gt;</Body>
<Tags>python,function,while-loop,output,floating</Tags>
</question>
<answer>
<Body>&lt;p&gt;The console uses &lt;code&gt;repr( )&lt;/code&gt; to show the result. &lt;code&gt;print&lt;/code&gt; uses &lt;code&gt;str( )&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import math; f = math.sqrt(10)&amp;gt;&amp;gt;&amp;gt; str(f)&#x27;3.16227766017&#x27;&amp;gt;&amp;gt;&amp;gt; repr(f)&#x27;3.1622776601683795&#x27;&amp;gt;&amp;gt;&amp;gt; print f3.16227766017&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It&#x27;s strange you miss the precision in the output. Your epsilon is 0.0001, several digits shorter, which will result in a very poor precision, at least for these small numbers. Why worry about the output then?&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;&lt;code&gt;print&lt;/code&gt; calls &lt;code&gt;__str__()&lt;/code&gt; on the &lt;code&gt;float&lt;/code&gt; object. Just calling the function at the Python prompt and letting Python show you the result calls &lt;code&gt;__repr__()&lt;/code&gt;. The &lt;code&gt;__str__()&lt;/code&gt; uses a little less precision precisely because of issues with floating-point accuracy: many fractional values can&#x27;t be stored precisely and this causes inaccuracies in calculations involving them.&lt;/p&gt;</Body>
</answer>
</qroot>
