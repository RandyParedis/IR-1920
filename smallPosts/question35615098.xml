<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>gsl::span fails to compile with std::regex</Title>
<Body>&lt;p&gt;I&#x27;m trying to use &lt;code&gt;gsl::span&lt;/code&gt; to pass some data from a packed structure of mixed binary/ascii data (hence no &lt;code&gt;vector&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;) to a function, where I want to operate on it with a regex, but I get the following errors:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;error C2784: &#x27;bool std::regex_match(_BidIt,_BidIt,std::match_results&amp;lt;_BidIt,_Alloc&gt; &amp;amp;,const std::basic_regex&amp;lt;_Elem,_RxTraits&gt; &amp;amp;,std::regex_constants::match_flag_type)&#x27; : could not deduce template argument for &#x27;std::match_results&gt;,_Alloc&gt; &amp;amp;&#x27; from &#x27;std::cmatch&#x27;&lt;/p&gt;    &lt;p&gt;see declaration of &#x27;std::regex_match&#x27;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Here&#x27;s what I&#x27;m trying to do:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;regex&amp;gt;#include &quot;gsl.h&quot;using namespace std;using namespace gsl;int main(int argc, const char **argv) {    char lat[8] = { &#x27;0&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;E&#x27; };    span&amp;lt;char&amp;gt; s = lat;    // in a complex implementation this would be in a function,    // hence the desire for span&amp;lt;&amp;gt;    std::cmatch match;    std::regex_match(s.begin(), s.end(), match, std::regex(&quot;[0-9]+&quot;));}&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++,regex,c++11,guideline-support-library</Tags>
</question>
<answer>
<Body>&lt;p&gt;The problem is that &lt;code&gt;std::regex_match&lt;/code&gt; cannot resolve the function overload when the iterator type is &lt;code&gt;gsl::continuous_span_iterator&lt;/code&gt; because &lt;code&gt;std::cmatch&lt;/code&gt; uses a &lt;code&gt;const char*&lt;/code&gt; as the iterator type. Neither &lt;code&gt;std::smatch&lt;/code&gt; or &lt;code&gt;std::cmatch&lt;/code&gt; is appropriate in this case, you need your own &lt;code&gt;std::match_results&lt;/code&gt; type. Here&#x27;s how it should be done:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;regex&amp;gt;#include &quot;gsl.h&quot;using namespace std;using namespace gsl;int main(int argc, const char **argv) {    char lat[8] = { &#x27;0&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;E&#x27; };    span&amp;lt;char&amp;gt; s = lat;    std::match_results&amp;lt;decltype(s)::iterator&amp;gt; match;    std::regex_match(s.begin(), s.end(), match, std::regex(&quot;.*&quot;));}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That said, at the time of this writing, the revised iterator approach still won&#x27;t compile due to &lt;a href=&quot;https://github.com/Microsoft/GSL/issues/271&quot; rel=&quot;nofollow&quot;&gt;issue #271&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;Until that&#x27;s fixed, another workaround is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int main(int argc, const char **argv) {    char lat[8] = { &#x27;0&#x27;, &#x27;1&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;E&#x27; };    span&amp;lt;char&amp;gt; s = lat;    std::cmatch match;    std::regex_match(&amp;amp;s[0], &amp;amp;s[s.length_bytes()], match, std::regex(&quot;.*&quot;));}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The workaround approach cover cases where spans of the same or different extents are passed to the function.&lt;/p&gt;</Body>
</answer>
</qroot>
