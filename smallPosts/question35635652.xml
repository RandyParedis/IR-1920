<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Is this inter-thread object sharing strategy sound?</Title>
<Body>&lt;p&gt;I&#x27;m trying to come up with a fast way of solving the following problem:&lt;/p&gt;&lt;p&gt;I have a thread which produces data, and several threads which consume it. I don&#x27;t need to queue produced data, because data is produced much more slowly than it is consumed (and even if this failed to be the case occasionally, it wouldn&#x27;t be a problem if a data point were skipped occasionally). So, basically, I have an object that encapsulates the &quot;most recent state&quot;, which only the producer thread is allowed to update. &lt;/p&gt;&lt;p&gt;My strategy is as follows (please let me know if I&#x27;m completely off my rocker):&lt;/p&gt;&lt;p&gt;I&#x27;ve created three classes for this example: &lt;code&gt;Thing&lt;/code&gt; (the actual state object), &lt;code&gt;SharedObject&amp;lt;Thing&amp;gt;&lt;/code&gt; (an object that can be local to each thread, and gives that thread access to the underlying Thing), and &lt;code&gt;SharedObjectManager&amp;lt;Thing&amp;gt;&lt;/code&gt;, which wraps up a &lt;code&gt;shared_ptr&lt;/code&gt; along with a &lt;code&gt;mutex&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The instance of the &lt;code&gt;SharedObjectManager&lt;/code&gt; (SOM) is a global variable.When the producer starts, it instantiates a Thing, and tells the global SOM about it. It then makes a copy, and does all of it&#x27;s updating work on that copy. When it is ready to commit it&#x27;s changes to the Thing, it passes the new Thing to the global SOM, which locks it&#x27;s mutex, updates the shared pointer it keeps, and then releases the lock.&lt;/p&gt;&lt;p&gt;Meanwhile, the consumer threads all intsantiate &lt;code&gt;SharedObject&amp;lt;Thing&amp;gt;&lt;/code&gt;. these objects each keep a pointer to the global SOM, as well as a cached copy of the &lt;code&gt;shared_ptr&lt;/code&gt; kept by the SOM... It keeps this cached until &lt;code&gt;update()&lt;/code&gt; is explicitly called. &lt;/p&gt;&lt;p&gt;I believe this is getting hard to follow, so here&#x27;s some code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;mutex&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt;class Thing{    private:        int _some_member = 10;    public:        int some_member() const { return _some_member; }        void some_member(int val) {_some_member = val; }};// one global instancetemplate&amp;lt;typename T&amp;gt;class SharedObjectManager{    private:        std::shared_ptr&amp;lt;T&amp;gt; objPtr;        std::mutex objLock;    public:        std::shared_ptr&amp;lt;T&amp;gt; get_sptr()        {            std::lock_guard&amp;lt;std::mutex&amp;gt; lck(objLock);            return objPtr;        }        void commit_new_object(std::shared_ptr&amp;lt;T&amp;gt; new_object)        {            std::lock_guard&amp;lt;std::mutex&amp;gt; lck (objLock);            objPtr = new_object;        }};// one instance per consumer thread.template&amp;lt;typename T&amp;gt;class SharedObject{    private:        SharedObjectManager&amp;lt;T&amp;gt; * som;        std::shared_ptr&amp;lt;T&amp;gt; cache;    public:        SharedObject(SharedObjectManager&amp;lt;T&amp;gt; * backend) : som(backend)        {update();}        void update()        {            cache = som-&amp;gt;get_sptr();        }        T &amp;amp; operator *()        {            return *cache;        }        T * operator-&amp;gt;()        {            return cache.get();        }};// no actual threads in this test, just a quick sanity check.SharedObjectManager&amp;lt;Thing&amp;gt; glbSOM;int main(void){    glbSOM.commit_new_object(std::make_shared&amp;lt;Thing&amp;gt;());    SharedObject&amp;lt;Thing&amp;gt; myobj(&amp;amp;glbSOM);    std::cout&amp;lt;&amp;lt;myobj-&amp;gt;some_member()&amp;lt;&amp;lt;std::endl;    // prints &quot;10&quot;.}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The idea for use by the producer thread is: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;// initialization - on startupauto firstStateObj = std::make_shared&amp;lt;Thing&amp;gt;();glbSOM.commit_new_object(firstStateObj);// main loopwhile (1){    // invoke copy constructor to copy the current live Thing object    auto nextState = std::make_shared&amp;lt;Thing&amp;gt;(*(glbSOM.get_sptr()));    // do stuff to nextState, gradually filling out it&#x27;s new value     //    based on incoming data from other sources, etc.    ...    // commit the changes to the shared memory location    glbSOM.commit_new_object(nextState);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The use by consumers would be:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;SharedObject&amp;lt;Thing&amp;gt; thing(&amp;amp;glbSOM);while(1){    // think about the data contained in thing, and act accordingly...    doStuffWith(thing-&amp;gt;some_member());            // re-cache the thing    thing.update();}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thanks!&lt;/p&gt;</Body>
<Tags>c++,multithreading,thread-safety,shared-memory</Tags>
</question>
<answer>
<Body>&lt;p&gt;That is way overengineered. Instead, I&#x27;d suggest to do following:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Create a pointer to &lt;code&gt;Thing* theThing&lt;/code&gt; together with protection mutex. Either a global one, or shared by some other means. Initialize it to nullptr.&lt;/li&gt;&lt;li&gt;In your producer: use two local objects of &lt;code&gt;Thing&lt;/code&gt; type - &lt;code&gt;Thing thingOne&lt;/code&gt; and &lt;code&gt;Thing thingTwo&lt;/code&gt; (remember, &lt;code&gt;thingOne&lt;/code&gt; is no better than &lt;code&gt;thingTwo&lt;/code&gt;, but one is called &lt;code&gt;thingOne&lt;/code&gt; for a reason, but this is a thing thing. Watch out for cats.). Start with populating &lt;code&gt;thingOne&lt;/code&gt;. When done, lock the mutex, copy &lt;code&gt;thingOne&lt;/code&gt; address to &lt;code&gt;theThing&lt;/code&gt;, unlock the mutex. Start populating &lt;code&gt;thingTwo&lt;/code&gt;. When done, see above. Repeat untill killed.&lt;/li&gt;&lt;li&gt;In every listener: (make sure the pointer is not nullptr). Lock the mutex. Make a copy of the object pointed two by the &lt;code&gt;theThing&lt;/code&gt;. Unlock the mutex. Work with your copy. Burn after reading. Repeat untill killed.&lt;/li&gt;&lt;/ul&gt;</Body>
</answer>
</qroot>
