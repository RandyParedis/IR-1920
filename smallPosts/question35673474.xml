<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Using abc.ABCMeta in a way it is compatible both with Python 2.7 and Python 3.5</Title>
<Body>&lt;p&gt;I&#x27;d like to create a class which has &lt;code&gt;abc.ABCMeta&lt;/code&gt; as a metaclass and is compatible both with Python 2.7 and Python 3.5. Until now, I only succeeded doing this either on 2.7 or on 3.5 - but never on both versions simultaneously. Could someone give me a hand?&lt;/p&gt;&lt;p&gt;Python 2.7:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import abcclass SomeAbstractClass(object):    __metaclass__ = abc.ABCMeta    @abc.abstractmethod    def do_something(self):        pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Python 3.5:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import abcclass SomeAbstractClass(metaclass=abc.ABCMeta):    @abc.abstractmethod    def do_something(self):        pass&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Testing&lt;/h2&gt;&lt;p&gt;If we run the following test using the suitable version of the Python interpreter (Python 2.7 -&gt; Example 1, Python 3.5 -&gt; Example 2), it succeeds in both scenarios:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import unittestclass SomeAbstractClassTestCase(unittest.TestCase):    def test_do_something_raises_exception(self):        with self.assertRaises(TypeError) as error:            processor = SomeAbstractClass()        msg = str(error.exception)        expected_msg = &quot;Can&#x27;t instantiate abstract class SomeAbstractClass with abstract methods do_something&quot;        self.assertEqual(msg, expected_msg)&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Problem&lt;/h2&gt;&lt;p&gt;While running the test using Python 3.5, the expected behavior doesn&#x27;t happen (&lt;code&gt;TypeError&lt;/code&gt; is not raised while instantiating &lt;code&gt;SomeAbstractClass&lt;/code&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;======================================================================FAIL: test_do_something_raises_exception (__main__.SomeAbstractClassTestCase)----------------------------------------------------------------------Traceback (most recent call last):  File &quot;/home/tati/sample_abc.py&quot;, line 22, in test_do_something_raises_exception    processor = SomeAbstractClass()AssertionError: TypeError not raised----------------------------------------------------------------------&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Whereas running the test using Python 2.7 raises a &lt;code&gt;SyntaxError&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt; Python 2.7 incompatible Raises exception:  File &quot;/home/tati/sample_abc.py&quot;, line 24    class SomeAbstractClass(metaclass=abc.ABCMeta):                                     ^ SyntaxError: invalid syntax&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>python,python-2.7,metaclass,python-3.5,abc</Tags>
</question>
<answer>
<Body>&lt;p&gt;You could use &lt;a href=&quot;https://pythonhosted.org/six/#six.add_metaclass&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;six.add_metaclass&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://pythonhosted.org/six/#six.with_metaclass&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;six.with_metaclass&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import abc, six@six.add_metaclass(abc.ABCMeta)class SomeAbstractClass():    @abc.abstractmethod    def do_something(self):        pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;six&lt;/code&gt; is a &lt;a href=&quot;https://github.com/benjaminp/six&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Python 2 and 3 compatibility library&lt;/em&gt;&lt;/a&gt;. You can install it by running &lt;code&gt;pip install six&lt;/code&gt; or by downloading the latest version of &lt;code&gt;six.py&lt;/code&gt; to your project directory.&lt;/p&gt;&lt;p&gt;For those of you who prefer &lt;code&gt;future&lt;/code&gt; over &lt;code&gt;six&lt;/code&gt;, the relevant function is &lt;a href=&quot;http://python-future.org/reference.html#future.utils.with_metaclass&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;future.utils.with_metaclass&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;blockquote&gt;  &lt;h1&gt;Using abc.ABCMeta in a way it is compatible both with Python 2.7 and Python 3.5&lt;/h1&gt;&lt;/blockquote&gt;&lt;p&gt;If we were only using Python 3 (this is &lt;a href=&quot;https://docs.python.org/3/library/abc.html#abc.ABC&quot; rel=&quot;noreferrer&quot;&gt;new in 3.4&lt;/a&gt;) we could do:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;from abc import ABC&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and inherit from &lt;code&gt;ABC&lt;/code&gt; instead of &lt;code&gt;object&lt;/code&gt;. That is:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class SomeAbstractClass(ABC):    ...etc&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You still don&#x27;t need an extra dependence (the six module) - you can use the metaclass to create a parent (this is essentially what the six module does in with_metaclass):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import abc# compatible with Python 2 *and* 3:ABC = abc.ABCMeta(&#x27;ABC&#x27;, (object,), {&#x27;__slots__&#x27;: ()}) class SomeAbstractClass(ABC):    @abc.abstractmethod    def do_something(self):        pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or you could just do it in-place (but this is more messy, and doesn&#x27;t contribute as much to reuse):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# use ABCMeta compatible with Python 2 *and* 3 class SomeAbstractClass(abc.ABCMeta(&#x27;ABC&#x27;, (object,), {&#x27;__slots__&#x27;: ()})):    @abc.abstractmethod    def do_something(self):        pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the signature looks a little messier than &lt;a href=&quot;https://pythonhosted.org/six/#six.with_metaclass&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;six.with_metaclass&lt;/code&gt;&lt;/a&gt; but it is substantially the same semantics, without the extra dependence.&lt;/p&gt;&lt;h2&gt;Either solution&lt;/h2&gt;&lt;p&gt;and now, when we try to instantiate without implementing the abstraction, we get precisely what we expect:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; SomeAbstractClass()Traceback (most recent call last):  File &quot;&amp;lt;pyshell#31&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;    SomeAbstractClass()TypeError: Can&#x27;t instantiate abstract class SomeAbstractClass with abstract methods do_something&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Note on &lt;code&gt;__slots__ = ()&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;We &lt;a href=&quot;http://bugs.python.org/issue30463&quot; rel=&quot;noreferrer&quot;&gt;just added empty &lt;code&gt;__slots__&lt;/code&gt;&lt;/a&gt; to the ABC convenience class in Python 3&#x27;s standard library, and my answer is updated to include it.&lt;/p&gt;&lt;p&gt;Not having &lt;code&gt;__dict__&lt;/code&gt; and &lt;code&gt;__weakref__&lt;/code&gt; available in the &lt;code&gt;ABC&lt;/code&gt; parent allows users to deny their creation for child classes and save memory - there are no downsides, unless you were using &lt;code&gt;__slots__&lt;/code&gt; in child classes already and relying on implicit &lt;code&gt;__dict__&lt;/code&gt; or &lt;code&gt;__weakref__&lt;/code&gt; creation from the &lt;code&gt;ABC&lt;/code&gt; parent. &lt;/p&gt;&lt;p&gt;The fast fix would be to declare &lt;code&gt;__dict__&lt;/code&gt; or &lt;code&gt;__weakref__&lt;/code&gt; in your child class as appropriate. Better (for &lt;code&gt;__dict__&lt;/code&gt;) might be to declare all your members explicitly.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I prefer &lt;a href=&quot;https://stackoverflow.com/a/38668373/2437514&quot;&gt;Aaron Hall&#x27;s answer&lt;/a&gt;, but it&#x27;s important to note that in this case the comment that is part of the line: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;ABC = abc.ABCMeta(&#x27;ABC&#x27;, (object,), {}) # compatible with Python 2 *and* 3 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;...is every bit as important as the code itself. Without the comment, there is nothing to prevent some future cowboy down the road deleting the line and changing the class inheritance to: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;class SomeAbstractClass(abc.ABC):&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;...thus breaking everything pre Python 3.4. &lt;/p&gt;&lt;p&gt;One tweak that may be a little more explicit/clear to someone else- in that it is self documenting- regarding what it is you are trying to accomplish: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;import sysimport abcif sys.version_info &amp;gt;= (3, 4):    ABC = abc.ABCelse:    ABC = abc.ABCMeta(&#x27;ABC&#x27;, (), {})class SomeAbstractClass(ABC):    @abc.abstractmethod    def do_something(self):        pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Strictly speaking, this isn&#x27;t necessary to do, but it is absolutely clear, even without commentary, what is going on. &lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Just to say that you must explicitly pass &lt;code&gt;str(&#x27;ABC&#x27;)&lt;/code&gt; to &lt;code&gt;abc.ABCMeta&lt;/code&gt; in Python 2 if you use &lt;code&gt;from __future__ import unicode_literals&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Otherwise Python raises &lt;code&gt;TypeError: type() argument 1 must be string, not unicode&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;See corrected code below.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import sysimport abcfrom __future__ import unicode_literalsif sys.version_info &amp;gt;= (3, 4):    ABC = abc.ABCelse:    ABC = abc.ABCMeta(str(&#x27;ABC&#x27;), (), {})&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This would not require a separate answer but sadly I cannot comment yours (need more rep).&lt;/p&gt;</Body>
</answer>
</qroot>
