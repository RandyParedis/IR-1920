<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Flatbuffers encoding then decoding C++ double array + table + union returns junk</Title>
<Body>&lt;p&gt;I&#x27;m filling out some flatbuffer messages but when I encode then decode them I get junk back out. I&#x27;ve not included the full message to avoid extraneous information, but I&#x27;m able to extract the enum value of the union component successfully. However, when I go to extract the type identified by the enum the double array I print out contains junk as illustrated below.&lt;/p&gt;&lt;p&gt;Here are the important parts of the buffers:&lt;/p&gt;&lt;p&gt;Input/Output:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;KukaJAVAdriver sending armposition command:[1, 0, 0, 0, 0, 0, 1]re-extracted 7 joint angles: 0 11 02 03 04 05 06 1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JointState.fbs:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;table JointState {  // @todo consider adding name string  position:[double]; // angle in radians  velocity:[double]; // velocity in radians/second  acceleration:[double]; // acceleration in radians/(second^2)  torque:[double]; // Newton Meters (N*m)}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArmControlState.fbs:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;include &quot;JointState.fbs&quot;;include &quot;Geometry.fbs&quot;;namespace grl.flatbuffer;table StartArm {}table StopArm {}table PauseArm {}table TeachArm {}table ShutdownArm {}table MoveArmTrajectory {  traj:[JointState];}table MoveArmJointServo {  goal:JointState;}table MoveArmCartesianServo {  parent:string; // Object/Frame/Coordinate System to move wrt. Empty default is robot base  goal:Pose;}union ArmState { StartArm, StopArm, PauseArm, ShutdownArm, TeachArm, MoveArmTrajectory, MoveArmJointServo, MoveArmCartesianServo }table ArmControlState {  name:string;   // entity to move  sequenceNumber:long;  timeStamp:double;  state:ArmState;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;encode:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;          flatbuffers::Offset&amp;lt;flatbuffer::ArmControlState&amp;gt; controlState;          switch (armControlMode_) {              case flatbuffer::ArmState::ArmState_StartArm: {                 controlState = flatbuffer::CreateArmControlState(*fbbP,bns,sequenceNumber++,duration,armControlMode_,flatbuffer::CreateStartArm(*fbbP).Union());                 break;              }              case flatbuffer::ArmState::ArmState_MoveArmJointServo: {                /// @todo when new                JointScalar                          armPosVelAccelEmpty;                auto armPositionBuffer = fbbP-&amp;gt;CreateVector(armPosition_.data(),armPosition_.size());                auto goalJointState = grl::flatbuffer::CreateJointState(*fbbP,armPositionBuffer);                auto moveArmJointServo = grl::flatbuffer::CreateMoveArmJointServo(*fbbP,goalJointState);                controlState = flatbuffer::CreateArmControlState(*fbbP,bns,sequenceNumber++,duration,armControlMode_,moveArmJointServo.Union());                std::cout &amp;lt;&amp;lt; &quot;KukaJAVAdriver sending armposition command:&quot; &amp;lt;&amp;lt;armPosition_&amp;lt;&amp;lt;&quot;\n&quot;;                 break;              }//...snip...}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;decode:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;          auto states = flatbuffer::CreateKUKAiiwaStates(*fbbP,kukaiiwaStateVec);          grl::flatbuffer::FinishKUKAiiwaStatesBuffer(*fbbP, states);          flatbuffers::Verifier verifier(fbbP-&amp;gt;GetBufferPointer(),fbbP-&amp;gt;GetSize());          BOOST_VERIFY(grl::flatbuffer::VerifyKUKAiiwaStatesBuffer(verifier));          if(armControlMode_ == flatbuffer::ArmState::ArmState_MoveArmJointServo)          {              auto states2 = flatbuffer::GetKUKAiiwaStates(fbbP-&amp;gt;GetBufferPointer());              auto movearm = static_cast&amp;lt;const flatbuffer::MoveArmJointServo*&amp;gt;(states2-&amp;gt;states()-&amp;gt;Get(0)-&amp;gt;armControlState()-&amp;gt;state());              std::cout &amp;lt;&amp;lt; &quot;re-extracted &quot; &amp;lt;&amp;lt; movearm-&amp;gt;goal()-&amp;gt;position()-&amp;gt;size() &amp;lt;&amp;lt; &quot; joint angles: &quot;;              for(std::size_t i = 0; i &amp;lt;  movearm-&amp;gt;goal()-&amp;gt;position()-&amp;gt;size(); ++i)              {                std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; movearm-&amp;gt;goal()-&amp;gt;position()-&amp;gt;Get(i);              }              std::cout &amp;lt;&amp;lt; &quot;\n&quot;;          }          kukaJavaDriverP-&amp;gt;async_send_flatbuffer(fbbP);&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++,flatbuffers</Tags>
</question>
<answer>
<Body>&lt;p&gt;You don&#x27;t get junk out, the data is actually correct. The bug is in this statement: &lt;code&gt;std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; movearm-&amp;gt;goal()-&amp;gt;position()-&amp;gt;Get(i);&lt;/code&gt;&lt;/p&gt;&lt;p&gt;If instead you wrote something like: &lt;code&gt;std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;=&quot; &amp;lt;&amp;lt; movearm-&amp;gt;goal()-&amp;gt;position()-&amp;gt;Get(i) &amp;lt;&amp;lt; &quot;, &quot;;&lt;/code&gt; it be more readable :)&lt;/p&gt;</Body>
</answer>
</qroot>
