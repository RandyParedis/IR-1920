<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Class name does not name a type in C++</Title>
<Body>&lt;p&gt;I just started programming in C++, and I&#x27;ve tried to create 2 classes where one will contain the other.&lt;/p&gt;&lt;p&gt;File &lt;code&gt;A.h&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#ifndef _A_h#define _A_hclass A{    public:        A(int id);    private:        int _id;        B _b; // HERE I GET A COMPILATION ERROR: B does not name a type};#endif&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;File &lt;code&gt;A.cpp&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &quot;A.h&quot;#include &quot;B.h&quot;#include &amp;lt;cstdio&amp;gt;A::A(int id): _id(id), _b(){    printf(&quot;hello\n the id is: %d\n&quot;, _id);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;File &lt;code&gt;B.h&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#ifndef _B_h#define _B_hclass B{    public:        B();};#endif&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;File &lt;code&gt;B.cpp&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &quot;B.h&quot;#include &amp;lt;cstdio&amp;gt;B::B(){    printf(&quot;this is hello from B\n&quot;);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I first compile the B class and then the A class, but then I get the error message:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;A.h:9: error: ‘B’ does not name a type&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;How do I fix this problem?&lt;/p&gt;</Body>
<Tags>c++</Tags>
</question>
<answer>
<Body>&lt;p&gt;Include &quot;B.h&quot; in &quot;A.h&quot;. That brings in the declaration of &#x27;B&#x27; for the compiler while compiling &#x27;A&#x27;.&lt;/p&gt;&lt;p&gt;The first bullet holds in the case of OP.&lt;/p&gt;&lt;p&gt;$3.4.1/7 - &lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;&quot;A name used in the definition of a  class X outside of a member function  body or nested class definition27)  shall be declared in one of the  following ways: &lt;/p&gt;    &lt;p&gt;— &lt;strong&gt;before its use in  class X or be a member of a base class  of X (10.2),&lt;/strong&gt; or &lt;/p&gt;    &lt;p&gt;— if X is a nested  class of class Y (9.7), before the  definition of X in Y, or shall be a  member of a base class of Y (this  lookup applies in turn to Y’s  enclosing classes, starting with the  innermost enclosing class),28) or &lt;/p&gt;    &lt;p&gt;— if  X is a local class (9.8) or is a  nested class of a local class, before  the definition of class X in a block  enclosing the definition of class X,  or &lt;/p&gt;    &lt;p&gt;— if X is a member of namespace N,  or is a nested class of a class that  is a member of N, or is a local class  or a nested class within a local class  of a function that is a member of N,  before the definition of class X in  namespace N or in one of N’s enclosing  namespaces.&quot;&lt;/p&gt;&lt;/blockquote&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;You must first include &lt;code&gt;B.h&lt;/code&gt; from &lt;code&gt;A.h&lt;/code&gt;. &lt;code&gt;B b&lt;/code&gt;; makes no sense until you have included &lt;code&gt;B.h&lt;/code&gt;.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The problem is that you need to include &lt;code&gt;B.h&lt;/code&gt; in your &lt;code&gt;A.h&lt;/code&gt; file. The problem is that in the definition of &lt;code&gt;A&lt;/code&gt;, the compiler still doesn&#x27;t know what &lt;code&gt;B&lt;/code&gt; is. You should include all the definitions of all the types you are using.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;when you define the class A, in A.h, you explicitely say that the class has a member B.&lt;/p&gt;&lt;p&gt;You MUST include &quot;B.h&quot; in &quot;A.h&quot;&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Aren&#x27;t you missing the #include &quot;B.h&quot; in A.h?&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The preprocessor inserts the contents of the files &lt;code&gt;A.h&lt;/code&gt; and &lt;code&gt;B.h&lt;/code&gt; exactly where the &lt;code&gt;include&lt;/code&gt; statement occurs (this is really just copy/paste). When the compiler then parses &lt;code&gt;A.cpp&lt;/code&gt;, it finds the declaration of class &lt;code&gt;A&lt;/code&gt; before it knows about class &lt;code&gt;B&lt;/code&gt;. This causes the error you see. There are two ways to solve this:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Include &lt;code&gt;B.h&lt;/code&gt; in &lt;code&gt;A.h&lt;/code&gt;. It is generally a good idea to include header files in the files where they are needed. If you rely on indirect inclusion though another header, or a special order of includes in the compilation unit (cpp-file), this will only confuse you and others as the project gets bigger.&lt;/li&gt;&lt;li&gt;&lt;p&gt;If you use member variable of type &lt;code&gt;B&lt;/code&gt; in class &lt;code&gt;A&lt;/code&gt;, the compiler needs to know the exact and complete declaration of &lt;code&gt;B&lt;/code&gt;, because it needs to create the memory-layout for &lt;code&gt;A&lt;/code&gt;. If, on the other hand, you were using a pointer or reference to &lt;code&gt;B&lt;/code&gt;, then a forward declaration would suffice, because the memory the compiler needs to reserve for a pointer or reference is independent of the class definition. This would look like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class B; // forward declaration        class A {public:    A(int id);private:    int _id;    B &amp;amp; _b;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is very useful to avoid circular dependencies among headers.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;I hope this helps.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;error &#x27;Class&#x27; does not name a type&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just in case someone does the same idiotic thing I did ...I was creating a small test program from scratch and I typed &lt;strong&gt;Class&lt;/strong&gt; instead of &lt;strong&gt;class&lt;/strong&gt; (with a small C). I didn&#x27;t take any notice of the quotes in the error message and spent a little too long not understanding my problem.&lt;/p&gt;&lt;p&gt;My search for a solution brought me here so I guess the same could happen to someone else.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The solution to my problem today was slightly different that the other answers here.  &lt;/p&gt;&lt;p&gt;In my case, the problem was caused by a missing close bracket (&lt;code&gt;}&lt;/code&gt;) at the end of one of the header files in the include chain.  &lt;/p&gt;&lt;p&gt;Essentially, what was happening was that &lt;code&gt;A&lt;/code&gt; was including &lt;code&gt;B&lt;/code&gt;. Because &lt;code&gt;B&lt;/code&gt; was missing a &lt;code&gt;}&lt;/code&gt; somewhere in the file, the definitions in &lt;code&gt;B&lt;/code&gt; were not correctly found in &lt;code&gt;A&lt;/code&gt;. &lt;/p&gt;&lt;p&gt;At first I thought I have circular dependency and added the forward declaration &lt;code&gt;B&lt;/code&gt;. But then it started complaining about the fact that something in &lt;code&gt;B&lt;/code&gt; was an incomplete type. That&#x27;s how I thought of double checking the files for syntax errors.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Because people searching with the same keyword will land on this page, I am adding this answer which is not the cause for this compiler error in the above mentioned case.&lt;/p&gt;&lt;p&gt;I was facing this error when I had an &lt;code&gt;enum&lt;/code&gt; declared in some file which had one of the elements having the same symbol as my class name.&lt;/p&gt;&lt;p&gt;e.g. if I declare an &lt;code&gt;enum = {A, B, C}&lt;/code&gt; in some file which is included in another file where I declare an object of &lt;code&gt;class A&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;This was throwing the same compiler error message mentioning that &lt;code&gt;Class A does not name a type&lt;/code&gt;. There was no circular dependency in my case.&lt;/p&gt;&lt;p&gt;So, be careful while naming classes and declaring enums (which might be visible, imported and used externally in other files) in C++.&lt;/p&gt;</Body>
</answer>
</qroot>
