<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>How to create different files for each time a function is performed on an item in a for loop?</Title>
<Body>&lt;p&gt;So building off of a code below that a community member here helped me fine-tune to create a function that takes a dictionary value from a text file and looks then looks through that value for a list of files. This was the code where I was appending all the values found to the same sheet. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;import csvimport globimport astfrom os.path import isfilefrom lxml import etreedef look_for_speaker_in_files(speakerAttrib):    speakerDict = ast.literal_eval(speakerAttrib)    l_file_exists = False    if isfile(&quot;allspeakers.csv&quot;):        l_file_exists = True    c = csv.writer(open(&quot;allspeakers.csv&quot;,&quot;a&quot;))    if not l_file_exists:        c.writerow([&quot;Name&quot;, &quot;Filename&quot;, &quot;Text&quot;])    lparser = etree.XMLParser(recover=True)    for cr_file in glob.iglob(&#x27;parsed/*.xml&#x27;):        try:          tree = etree.parse(cr_file,parser=lparser)          for node in tree.iter(&#x27;speaking&#x27;):             if node.keys() == speakerDict.keys():                c.writerow([node.attrib, cr_file, node.text])             else:                 continue        except:          print &quot;bad string &quot; + cr_file          raisedef main():    with open(&quot;speaking-basic.txt&quot;,&quot;r&quot;) as speaker_list:        for x in speaker_list:            print x            look_for_speaker_in_files(x)if __name__ == &quot;__main__&quot;:    main()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now I am looking to create a different file for each item from the text file, and only deposit the matches for the nodes in the files, to that item from the text file. &lt;/p&gt;&lt;p&gt;I tried the code below, where I altered the function that reads through the files to try to get it to take both the argument for the file name and the argument for the item from the text file to be searched for. I then altered the code that takes the item from the list to both read the item from the list, and get it to create a file name that&#x27;s the value of the dictionary items in the file.  &lt;/p&gt;&lt;pre&gt;&lt;code&gt;import csvimport globimport astfrom os.path import isfilefrom lxml import etreedef look_for_speaker_in_files(speakerAttrib,file_name):    speakerDict = ast.literal_eval(speakerAttrib)    l_file_exists = False    if isfile( file_name + &quot;.csv&quot;):        l_file_exists = True    c = csv.writer(open( file_name + &quot;.csv&quot;,&quot;a&quot;))    print c    if not l_file_exists:        c.writerow([&quot;Name&quot;, &quot;Filename&quot;, &quot;Text&quot;])    lparser = etree.XMLParser(recover=True)    for cr_file in glob.iglob(&#x27;parsed/*.xml&#x27;):        try:          tree = etree.parse(cr_file,parser=lparser)          for node in tree.iter(&#x27;speaking&#x27;):             if node.keys() == speakerDict.keys():                c.writerow([node.attrib, cr_file, node.text])             else:                 continue        except:          print &quot;bad string &quot; + cr_file          raisedef main():    with open(&quot;speaking.txt&quot;,&quot;r&quot;) as speaker_list:        for x in speaker_list:            print x            dictx = ast.literal_eval(x)            valuex = str(dictx.values()).format()            print valuex            look_for_speaker_in_files(x,valuex)if __name__ == &quot;__main__&quot;:    main()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I also tried to keep the looking through the files function to the same single argument, but adding a variable that came up with the file name from that argument, but that also didn&#x27;t work.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import csvimport globimport astfrom os.path import isfilefrom lxml import etreedef look_for_speaker_in_files(speakerAttrib):    speakerDict = ast.literal_eval(speakerAttrib)    file_name = str(speakerDict.values()).format()    l_file_exists = False    if isfile(file_name + &quot;.csv&quot;):        l_file_exists = True    c = csv.writer(open(file_name + &quot;.csv&quot;,&quot;a&quot;))    if not l_file_exists:        c.writerow([&quot;Name&quot;, &quot;Filename&quot;, &quot;Text&quot;])    lparser = etree.XMLParser(recover=True)    for cr_file in glob.iglob(&#x27;parsed/*.xml&#x27;):        try:          tree = etree.parse(cr_file,parser=lparser)          for node in tree.iter(&#x27;speaking&#x27;):             if node.keys() == speakerDict.keys():                c.writerow([node.attrib, cr_file, node.text])             else:                 continue        except:          print &quot;bad string &quot; + cr_file          raisedef main():    with open(&quot;speaking-basic.txt&quot;,&quot;r&quot;) as speaker_list:        for x in speaker_list:            print x            look_for_speaker_in_files(x)if __name__ == &quot;__main__&quot;:    main()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While these codes create the files, with all my futzing with it I seem to only be able to get it to either put nothing in the files but the column headers, or put all the speakers from the xml files within each one, not just the one I&#x27;ve put into the function. Additionally I can&#x27;t get it to create the file name without the [&#x27;&#x27;] around it.&lt;/p&gt;&lt;p&gt;I have the xml files the function is searching through and the text file with the values I am looking for at the google link here:&lt;a href=&quot;https://drive.google.com/open?id=0B7lGA34vOZItREhRbmF6Z3YtTnM&quot; rel=&quot;nofollow&quot;&gt;https://drive.google.com/open?id=0B7lGA34vOZItREhRbmF6Z3YtTnM&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Any help on this would be super appreciated, thank you!&lt;/p&gt;</Body>
<Tags>python-2.7,function,for-loop,dictionary,user-defined-functions</Tags>
</question>
<answer>
<Body>&lt;p&gt;I am not sure, if I understood your requirement correctly. Now what this code does is, with respect to the attribute given in the speaking-basic.txt, find the attributes in the parsed xml&#x27;s. If the attribute name and its values match in both speaking-basic.txt and the xml&#x27;s, then output it to a file with the name of the Speaker.&lt;/p&gt;&lt;p&gt;Check if this is what you were looking for, maybe I might not have understood it correctly. If so, please provide a clear understanding of the expected output with screenshots or samples.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import csvimport globimport astfrom os.path import isfilefrom lxml import etreedef look_for_speaker_in_files(speakerAttrib):    speakerDict = ast.literal_eval(speakerAttrib)    file_name = str(speakerDict.values()[0]).format()    l_file_exists = False    if isfile(file_name + &quot;.csv&quot;):        l_file_exists = True    c = csv.writer(open(file_name + &quot;.csv&quot;,&quot;a&quot;))    if not l_file_exists:        c.writerow([&quot;Name&quot;, &quot;Filename&quot;, &quot;Text&quot;])    lparser = etree.XMLParser(recover=True)    for cr_file in glob.iglob(&#x27;parsed/*.xml&#x27;):        try:          tree = etree.parse(cr_file,parser=lparser)          for node in tree.iter(&#x27;speaking&#x27;):             if node.keys() == speakerDict.keys():                if node.values() == speakerDict.values():                    c.writerow([node.attrib, cr_file, node.text])                else:                    continue             else:                 continue        except:          print &quot;bad string &quot; + cr_file          raisedef main():    with open(&quot;speaking-basic.txt&quot;,&quot;r&quot;) as speaker_list:        for x in speaker_list:            print x            look_for_speaker_in_files(x)if __name__ == &quot;__main__&quot;:    main()&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
