<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Detecting Overlapping Circles in OpenCV</Title>
<Body>&lt;p&gt;I&#x27;m using the OpenCV library for Python to detect the circles in an image. As a test case, I&#x27;m using the following image:&lt;/p&gt;&lt;p&gt;bottom of can:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/dd5XC.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/dd5XC.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;I&#x27;ve written the following code, which should display the image before detection, then display the image with the detected circles added:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import cv2import numpy as npimage = cv2.imread(&#x27;can.png&#x27;)image_rgb = image.copy()image_copy = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)grayscaled_image = cv2.cvtColor(image_copy, cv2.COLOR_GRAY2BGR)cv2.imshow(&quot;confirm&quot;, grayscaled_image)cv2.waitKey(0)cv2.destroyAllWindows()circles = cv2.HoughCircles(image_copy, cv2.HOUGH_GRADIENT, 1.3, 20, param1=60, param2=33, minRadius=10,maxRadius=28)if circles is not None:    print(&quot;FOUND CIRCLES&quot;)    circles = np.round(circles[0, :]).astype(&quot;int&quot;)    print(circles)    for (x, y, r) in circles:        cv2.circle(image, (x, y), r, (255, 0, 0), 4)        cv2.rectangle(image, (x - 5, y - 5), (x + 5, y + 5), (0, 128, 255), -1)    cv2.imshow(&quot;Test&quot;, image + image_rgb)    cv2.waitKey(0)cv2.destroyAllWindows()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I get this:resultant image&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/WJNJV.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/WJNJV.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;I feel that my problem lies in the usage of the &lt;code&gt;HoughCircles()&lt;/code&gt; function. It&#x27;s usage is:&lt;/p&gt;&lt;p&gt;&lt;code&gt;cv2.HoughCircles(image, method, dp, minDist[, circles[, param1[, param2[, minRadius[, maxRadius]]]]])&lt;/code&gt;&lt;/p&gt;&lt;p&gt;where &lt;code&gt;minDist&lt;/code&gt; is a value greater than 0 that requires detected circles to be a certain distance from one another. With this requirement, it would be impossible for me to properly detect all of the circles on the bottom of the can, as the center of each circle is in the same place. Would contours be a solution? How can I convert contours to circles so that I may use the coordinates of their center points? What should I do to best detect the circle objects for each ring in the bottom of the can?&lt;/p&gt;</Body>
<Tags>python,opencv</Tags>
</question>
<answer>
<Body>&lt;p&gt;Not all but a majority of the circles can be detected by adaptive thresholding the image, finding the contours and then fitting a minimum enclosing circle for contours having area greater than a threshold&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import cv2import numpy as npblock_size,constant_c ,min_cnt_area = 9,1,400img = cv2.imread(&#x27;viMmP.png&#x27;)img_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)thresh = cv2.adaptiveThreshold(img_gray,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV,block_size,constant_c)thresh_copy = thresh.copy()contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)for cnt in contours:    if cv2.contourArea(cnt)&amp;gt;min_cnt_area:        (x,y),radius = cv2.minEnclosingCircle(cnt)        center = (int(x),int(y))        radius = int(radius)        cv2.circle(img,center,radius,(255,0,0),1)cv2.imshow(&quot;Thresholded Image&quot;,thresh_copy)cv2.imshow(&quot;Image with circles&quot;,img)cv2.waitKey(0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now this script yields the result:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/CExaM.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/CExaM.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/MBIPU.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/MBIPU.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;But there are certain trade-offs like, if the &lt;code&gt;block_size&lt;/code&gt; and &lt;code&gt;constant_c&lt;/code&gt; are changed to 11 and 2 respectively then the script yields:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/pBb0O.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/pBb0O.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/xPDAu.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/xPDAu.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;You should try applying erosion with a kernel of proper shape to separate the overlapping circles in the thresholded image&lt;/p&gt;&lt;p&gt;You may look at the following links to understand more about adaptive thresholding and contours:&lt;/p&gt;&lt;p&gt;Threshlding examples: &lt;a href=&quot;http://docs.opencv.org/3.1.0/d7/d4d/tutorial_py_thresholding.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://docs.opencv.org/3.1.0/d7/d4d/tutorial_py_thresholding.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Thresholding reference: &lt;a href=&quot;http://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://docs.opencv.org/2.4/modules/imgproc/doc/miscellaneous_transformations.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Contour Examples:&lt;a href=&quot;http://docs.opencv.org/3.1.0/dd/d49/tutorial_py_contour_features.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://docs.opencv.org/3.1.0/dd/d49/tutorial_py_contour_features.html&lt;/a&gt;&lt;/p&gt;</Body>
</answer>
</qroot>
