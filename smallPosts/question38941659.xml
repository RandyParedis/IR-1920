<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Slicing every nth range within a list with a for and a while loop</Title>
<Body>&lt;p&gt;So I have a short list called &lt;strong&gt;someList&lt;/strong&gt; with some numbers in it. What I want to do is output every 3 elements of the list while iterating over it every 3rd slice range.&lt;/p&gt;&lt;p&gt;So if I have &lt;/p&gt;&lt;pre&gt;&lt;code&gt;someList = [1,2,3,4,5,6,7,8,9,10]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The output of my &lt;strong&gt;someList&lt;/strong&gt; should be like this&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10]]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is my code where I have defined a new &lt;strong&gt;temp&lt;/strong&gt; list to store the output values&lt;/p&gt;&lt;pre&gt;&lt;code&gt;someList = [1,2,3,4,5,6,7,8,9,10]lookupRange = 3temp = []for index,i in enumerate(someList):    while index &amp;lt;= len(someList):        temp.append(someList[index:index+lookupRange])        index += 1            print(temp)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However upon running this code I get some rather unexpected results...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10], [9, 10], [10], [], [2, 3, 4, 5, 6, 7, 8, 9, 10], [3, 4, 5, 6, 7, 8, 9, 10], [4, 5, 6, 7, 8, 9, 10], [5, 6, 7, 8, 9, 10], [6, 7, 8, 9, 10], [7, 8, 9, 10], [8, 9, 10], [9, 10], [10], [], [3, 4, 5, 6, 7, 8, 9, 10], [4, 5, 6, 7, 8, 9, 10], [5, 6, 7, 8, 9, 10], [6, 7, 8, 9, 10], [7, 8, 9, 10], [8, 9, 10], [9, 10], [10], [], [4, 5, 6, 7, 8, 9, 10], [5, 6, 7, 8, 9, 10], [6, 7, 8, 9, 10], [7, 8, 9, 10], [8, 9, 10], [9, 10], [10], [], [5, 6, 7, 8, 9, 10], [6, 7, 8, 9, 10], [7, 8, 9, 10], [8, 9, 10], [9, 10], [10], [], [6, 7, 8, 9, 10], [7, 8, 9, 10], [8, 9, 10], [9, 10], [10], [], [7, 8, 9, 10], [8, 9, 10], [9, 10], [10], [], [8, 9, 10], [9, 10], [10], [], [9, 10], [10], [], [10], []]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, for the first few lines, I do indeed get the desired output with slice range period of 3. But after that it just goes crazy...&lt;/p&gt;&lt;p&gt;Any ideas on whats going wrong here?&lt;/p&gt;&lt;p&gt;PS:I know there are probably simpler one liner ways to do this (such as the numpy.convolve function), but this problem in particular requires I do it with just for and while loops.&lt;/p&gt;</Body>
<Tags>python,iteration,slice</Tags>
</question>
<answer>
<Body>&lt;p&gt;You have nested loops, but you only need one loop.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;someList = [1,2,3,4,5,6,7,8,9,10]lookupRange = 3temp = []for index in range(len(someList) - lookupRange + 1):    temp.append(someList[index:index+lookupRange])&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Using list comprehension:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; someList = [1,2,3,4,5,6,7,8,9,10]&amp;gt;&amp;gt;&amp;gt; chunk = 3&amp;gt;&amp;gt;&amp;gt; [someList[i : i + chunk] for i in range(len(someList) - chunk + 1)][[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10]]&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Here&#x27;s a pure Python one-liner; Numpy isn&#x27;t required.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;someList = [1,2,3,4,5,6,7,8,9,10]lookupRange = 3temp = list(zip(*(someList[i:] for i in range(lookupRange))))print(temp)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;output&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (5, 6, 7), (6, 7, 8), (7, 8, 9), (8, 9, 10)]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In Python 2, the assignment to &lt;code&gt;temp&lt;/code&gt; can be simplified to&lt;/p&gt;&lt;pre&gt;&lt;code&gt;temp = zip(*(someList[i:] for i in range(lookupRange)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you &lt;em&gt;really&lt;/em&gt; need a list of lists instead of a list of tuples, you can change it to&lt;/p&gt;&lt;pre&gt;&lt;code&gt;temp = [list(u) for u in zip(*(someList[i:] for i in range(lookupRange)))]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which works equally well in Python 2 or 3. &lt;/p&gt;&lt;p&gt;But I&#x27;d stick with the tuples (unless you need to mutate those inner lists): tuples use less RAM, and code that uses tuples is often faster than the equivalent list-based code.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Here&#x27;s that last version done with a couple of traditional &lt;code&gt;for&lt;/code&gt; loops instead of a generator expression nested inside a list comprehension.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;someList = [1,2,3,4,5,6,7,8,9,10]lookupRange = 3offset_lists = []for i in range(lookupRange):    offset_lists.append(someList[i:])temp = []for u in zip(*offset_lists):    temp.append(list(u))print(temp)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;output&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9], [8, 9, 10]]&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
