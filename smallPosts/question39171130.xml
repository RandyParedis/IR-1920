<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Share std::map between processes with mmap()</Title>
<Body>&lt;p&gt;I&#x27;m trying to share a &lt;code&gt;std::map&amp;lt;std::string, std::chrono::system_clock::time_point&amp;gt; map&lt;/code&gt;: each string is a hostname identifying a site, and the time_point is the last time a process visited that site.&lt;/p&gt;&lt;p&gt;I was trying with &lt;code&gt;mmap&lt;/code&gt; but each process still see its own copy of the map.&lt;/p&gt;&lt;p&gt;Here&#x27;s my code (I took away all the methods and variables not concerning my problem):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;chrono&amp;gt;typedef std::map&amp;lt;std::string, std::chrono::system_clock::time_point&amp;gt; mymap;typedef mymap::iterator iter;typedef mymap* mapPointer;class MmapManager {    private:        MmapManager() {            frequency = (mapPointer) mmap(NULL, sizeof(frequency), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);            if (frequency == MAP_FAILED) {                std::cout &amp;lt;&amp;lt; &quot;mapping failed&quot; &amp;lt;&amp;lt; std::endl;            }        };        ~MmapManager() {            std::cout &amp;lt;&amp;lt; &quot;~MmapManager()&quot; &amp;lt;&amp;lt; std::endl;        }    public:        // my class was designed with the singleton pattern        static MmapManager&amp;amp; getInstance() {            static MmapManager instance;            return instance;        }    private:        // pointer to my map        mapPointer frequency;    public:        // check if the process already visited site &quot;host&quot;        bool isHostAlreadyVisited(std::string host) {            return frequency-&amp;gt;find(host) != frequency-&amp;gt;end();        }        // add new visited site and time of the visit        void addHost(std::string host) {            (*frequency)[host] = std::chrono::system_clock::now();            std::cout &amp;lt;&amp;lt; &quot;PROC &quot; &amp;lt;&amp;lt; getpid() &amp;lt;&amp;lt; &quot; added &quot; &amp;lt;&amp;lt; host &amp;lt;&amp;lt; std::endl;        }        // get time of the visit for site &quot;host&quot;        std::chrono::system_clock::time_point getElement(std::string host) {            return (*frequency)[host];        }        // print the map        void showMap(void) {            std::cout &amp;lt;&amp;lt; &quot;PROC &quot; &amp;lt;&amp;lt; getpid() &amp;lt;&amp;lt; &quot; prints map keys&quot; &amp;lt;&amp;lt; std::endl;            for (auto it = frequency-&amp;gt;begin(); it != frequency-&amp;gt;end(); ++it) {                std::cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; std::endl;            }        }};int main(void) {    // simulate the processes    for (int i=0; i&amp;lt;5; i++) {        // child process        if (fork() == 0) {            // if child never visited this site...            if (! MmapManager::getInstance().isHostAlreadyVisited(&quot;www.google.com&quot;)) {                std::cout &amp;lt;&amp;lt; &quot;PID &quot; &amp;lt;&amp;lt; getpid() &amp;lt;&amp;lt; &quot; www.google.com is new&quot; &amp;lt;&amp;lt; std::endl;                // ...add it to the map                MmapManager::getInstance().addHost(&quot;www.google.com&quot;);            }            else {                // if child already visited it, calculate                 // how much time passed since last visit                auto now = std::chrono::system_clock::now();                auto before = MmapManager::getInstance().getElement(&quot;www.google.com&quot;);                std::chrono::duration&amp;lt;double&amp;gt; diff = now-before;                std::cout &amp;lt;&amp;lt; &quot;PID &quot; &amp;lt;&amp;lt; getpid() &amp;lt;&amp;lt; &quot; visited www.google.com &quot; &amp;lt;&amp;lt; diff.count() &amp;lt;&amp;lt; &quot; seconds ago&quot; &amp;lt;&amp;lt; std::endl;            }            MmapManager::getInstance().showMap();            _exit(EXIT_SUCCESS);        }    }    return 0;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here&#x27;s one of the possible outputs:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;PID 12457 www.google.com is newPID 12459 www.google.com is newPID 12458 www.google.com is newPID 12460 www.google.com is newPID 12461 www.google.com is new&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I can&#x27;t use other external libraries like Boost or use threads: I know they share memory, but the program was designed this way (with child processes doing stuff) and I can&#x27;t modify it (original code is not mine).&lt;/p&gt;&lt;p&gt;Why does each process still see its own copy of the map?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Edit&lt;/strong&gt;: I think I did all the things you suggested me:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;insertion in &lt;code&gt;map&lt;/code&gt; is protected with a lock mechanism (thanks kfsone);&lt;/li&gt;&lt;li&gt;created a custom allocator for &lt;code&gt;string&lt;/code&gt; and another for &lt;code&gt;map&lt;/code&gt; (thanks Maxim Egorushkin for these two);&lt;/li&gt;&lt;li&gt;&lt;code&gt;map&lt;/code&gt; is allocated before forking (thanks Zan Lynx).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The output is not different and &lt;code&gt;map&lt;/code&gt; is still not shared:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;MmapManager()printMapmap emptyPID 5085 www.google.com is newPID 5086 www.google.com is newPROC 5086 added www.goole.comPROC 5085 added www.goole.comPID 5087 www.google.com is newPROC 5087 added www.goole.com&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You suggested me to use Boost but I&#x27;d like to use it after my code will work: I&#x27;m not reinventing the wheel, just learning the hard way.&lt;/p&gt;&lt;p&gt;Here follows my new code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/mman.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/shm.h&amp;gt;        /* shmat(), IPC_RMID        */#include &amp;lt;semaphore.h&amp;gt;      /* sem_open(), sem_destroy(), sem_wait().. */#include &amp;lt;fcntl.h&amp;gt;          /* O_CREAT, O_EXEC          */#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;chrono&amp;gt;#include &amp;lt;cstddef&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;limits&amp;gt;#include &amp;lt;memory&amp;gt;template&amp;lt;typename T&amp;gt; class stringAllocator {    public :         typedef T value_type;        typedef size_t size_type;        typedef ptrdiff_t difference_type;        typedef T* pointer;        typedef T const * const_pointer;        typedef T&amp;amp; reference;        typedef T const &amp;amp; const_reference;        template&amp;lt;typename U&amp;gt; struct rebind {            typedef stringAllocator&amp;lt;U&amp;gt; other;        };        pointer address (reference value ) const {            return &amp;amp;value;        }        const_pointer address (const_reference value) const {            return &amp;amp;value;        }        size_type max_size () const throw() {            return std::numeric_limits &amp;lt;size_type&amp;gt;::max() / sizeof(T);        }        stringAllocator () throw () {}        stringAllocator (stringAllocator const &amp;amp;) throw () {}        template &amp;lt;typename U&amp;gt;        stringAllocator(stringAllocator &amp;lt;U&amp;gt; const &amp;amp;) throw () {}        ~stringAllocator() throw () {}        pointer allocate (size_type n) {            pointer ptr = (pointer)malloc(n * sizeof(value_type));            return ptr;        }        void deallocate (pointer p, size_type n) {            free(p);        }        void construct (pointer p, const_reference value) {            new(p) T(value);        }        void destroy (pointer p) {            p-&amp;gt;~T();        }};template &amp;lt;class T1, class T2&amp;gt;    bool operator==(const stringAllocator&amp;lt;T1&amp;gt;&amp;amp;, const stringAllocator&amp;lt;T2&amp;gt;&amp;amp;) throw() {        return true;    }template &amp;lt;class T1, class T2&amp;gt;    bool operator!=(const stringAllocator&amp;lt;T1&amp;gt;&amp;amp;, const stringAllocator&amp;lt;T2&amp;gt;&amp;amp;) throw() {        return false;    }typedef std::basic_string&amp;lt;    char,     std::char_traits&amp;lt;char&amp;gt;,     stringAllocator&amp;lt;char&amp;gt;&amp;gt; myString;/*************************************** map allocator ****************************************/template&amp;lt;typename T&amp;gt; class mapAllocator{    public :        typedef T value_type;        typedef value_type* pointer;        typedef const value_type* const_pointer;        typedef value_type&amp;amp; reference;        typedef const value_type&amp;amp; const_reference;        typedef std::size_t size_type;        typedef std::ptrdiff_t difference_type;        template&amp;lt;typename U&amp;gt;        struct rebind {            typedef mapAllocator&amp;lt;U&amp;gt; other;        };        mapAllocator() throw() {}        mapAllocator (mapAllocator const &amp;amp;) throw () {}         ~mapAllocator() throw () {}        template&amp;lt;typename U&amp;gt;        mapAllocator(mapAllocator&amp;lt;U&amp;gt; const&amp;amp;) {}        pointer address(reference r) { return &amp;amp;r; }        const_pointer address(const_reference r) { return &amp;amp;r; }        pointer allocate(size_type cnt, typename std::allocator&amp;lt;void&amp;gt;::const_pointer = 0) {            pointer new_memory = reinterpret_cast&amp;lt;pointer&amp;gt;(::operator new(cnt * sizeof (T)));            return new_memory;        }        void deallocate(pointer p, size_type n) {            ::operator delete(p);        }        size_type max_size() const {            return std::numeric_limits&amp;lt;size_type&amp;gt;::max() / sizeof(T);        }        void construct(pointer p, const T&amp;amp; t) {            new(p) T(t);        }        void destroy(pointer p) {            p-&amp;gt;~T();        }    };template &amp;lt;class T1, class T2&amp;gt;    bool operator==(const mapAllocator&amp;lt;T1&amp;gt;&amp;amp;, const mapAllocator&amp;lt;T2&amp;gt;&amp;amp;) throw() {        return true;    }template &amp;lt;class T1, class T2&amp;gt;    bool operator!=(const mapAllocator&amp;lt;T1&amp;gt;&amp;amp;, const mapAllocator&amp;lt;T2&amp;gt;&amp;amp;) throw() {        return false;    }/*************************************** end map allocator ****************************************/// class compare for map with std::string as Keyclass strless {    public:        bool operator() (const myString first, const myString second ) const {             return first.compare(second) &amp;lt; 0;         }};template&amp;lt;typename Key, typename T&amp;gt;    using Map = std::map&amp;lt;        Key,                                    // class Key        T,                                      // class T        strless,                                // class Compare = std::less&amp;lt;Key&amp;gt;        mapAllocator&amp;lt;std::pair&amp;lt;const Key, T&amp;gt;    // class Allocator = std::allocator&amp;lt;std::pair&amp;lt;const Key, T&amp;gt; &amp;gt;    &amp;gt;&amp;gt;;// typedef for the actual map I need to share between processestypedef Map&amp;lt;myString, std::chrono::system_clock::time_point&amp;gt; frequencyMap;class MmapManager {    private:        MmapManager() {            std::cout &amp;lt;&amp;lt; &quot;MmapManager()&quot; &amp;lt;&amp;lt; std::endl;            semMmap = sem_open(&quot;semaphore&quot;, O_CREAT|O_EXCL, 0644, 1);            sem_unlink(&quot;semaphore&quot;);        };        ~MmapManager() {            std::cout &amp;lt;&amp;lt; &quot;~MmapManager()&quot; &amp;lt;&amp;lt; std::endl;        }    public:        static MmapManager&amp;amp; getInstance() {            static MmapManager instance;            return instance;        }    private:        frequencyMap fmap;        sem_t *semMmap;    public:        void start(void) {}        bool isHostAlreadyVisited(myString host) {            return fmap.find(host) != fmap.end();        }        void addHost(myString host) {            sem_wait(semMmap);            fmap[host] = std::chrono::system_clock::now();            sem_post(semMmap);            std::cout &amp;lt;&amp;lt; &quot;PROC &quot; &amp;lt;&amp;lt; getpid() &amp;lt;&amp;lt; &quot; added &quot; &amp;lt;&amp;lt; host &amp;lt;&amp;lt; std::endl;        }        // get time of the visit for site &quot;host&quot;        std::chrono::system_clock::time_point getElement(myString host) {            return fmap[host];        }        void printMap(void) {            std::cout &amp;lt;&amp;lt; &quot;printMap&quot; &amp;lt;&amp;lt; std::endl;            if (!fmap.empty()) {                for (auto it : fmap) {                    std::cout &amp;lt;&amp;lt; it.first &amp;lt;&amp;lt; &#x27; &#x27;;                }                std::cout &amp;lt;&amp;lt; std::endl;            } else {                std::cout &amp;lt;&amp;lt; &quot;map empty&quot; &amp;lt;&amp;lt; std::endl;            }        }};int main(void) {    MmapManager::getInstance().start();    for (int i=0; i&amp;lt;3; i++) {        if (fork() == 0) {            if (!MmapManager::getInstance().isHostAlreadyVisited(&quot;www.google.com&quot;)) {                std::cout &amp;lt;&amp;lt; &quot;PID &quot; &amp;lt;&amp;lt; getpid() &amp;lt;&amp;lt; &quot; www.google.com is new&quot; &amp;lt;&amp;lt; std::endl;                           MmapManager::getInstance().addHost(&quot;www.goole.com&quot;);            }            else {                // if child already visited it, calculate                // how much time passed since last visit                auto now = std::chrono::system_clock::now();                auto before = MmapManager::getInstance().getElement(&quot;www.google.com&quot;);                std::chrono::duration&amp;lt;double&amp;gt; diff = now-before;                std::cout &amp;lt;&amp;lt; &quot;PID &quot; &amp;lt;&amp;lt; getpid() &amp;lt;&amp;lt; &quot; visited www.google.com &quot; &amp;lt;&amp;lt; diff.count() &amp;lt;&amp;lt; &quot; seconds ago&quot; &amp;lt;&amp;lt; std::endl;            }            _exit(EXIT_SUCCESS);        }    }    MmapManager::getInstance().printMap();    return 0;}&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>linux,c++11,shared-memory,mmap</Tags>
</question>
<answer>
<Body>&lt;p&gt;This does not work because although you placed the container object into the shared memory, the elements are still allocated from the heap and thus they are not accessible by other processes.&lt;/p&gt;&lt;p&gt;You need a custom allocator that allocates elements in the shared memory. See &lt;a href=&quot;http://www.boost.org/doc/libs/1_61_0/doc/html/interprocess/quick_guide.html#interprocess.quick_guide.qg_interprocess_map&quot; rel=&quot;nofollow&quot;&gt;Creating maps in shared memory&lt;/a&gt; for how it is done.&lt;/p&gt;&lt;p&gt;Note that the string class you use must also allocate memory from the shared memory. &lt;/p&gt;&lt;p&gt;In other words, you cannot have pointers to heap memory in the shared memory, because heap memory is not shared between processes. &lt;code&gt;std&lt;/code&gt; classes have an allocator template argument, the default one allocates memory from the heap. This needs to be changed to a &lt;a href=&quot;http://www.boost.org/doc/libs/1_61_0/doc/html/interprocess/allocators_containers.html&quot; rel=&quot;nofollow&quot;&gt;shared memory allocator&lt;/a&gt; to be able to share such objects via shared memory.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Another reason your code doesn&#x27;t work is that you only create the maps &lt;em&gt;after&lt;/em&gt; you called &lt;code&gt;fork()&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;If you want your &lt;code&gt;MAP_SHARED|MAP_ANONYMOUS&lt;/code&gt; map to be seen by all the children then you have to call &lt;code&gt;mmap()&lt;/code&gt; &lt;em&gt;before forking&lt;/em&gt;.&lt;/p&gt;</Body>
</answer>
</qroot>
