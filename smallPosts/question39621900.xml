<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Using a DLL exported from D</Title>
<Body>&lt;p&gt;I&#x27;ve created a simple encryption program in D, and I had the idea to make a DLL from it and try to import it to, for example, Python.&lt;/p&gt;&lt;p&gt;I&#x27;ve could simply call my &lt;code&gt;main&lt;/code&gt; function, becouse it dosn&#x27;t need any params. But when I get to my encrytion method, &lt;strong&gt;it uses dynamic-lenght &lt;code&gt;ubyte[]&lt;/code&gt; arrays&lt;/strong&gt;, but as far as I know, they &lt;strong&gt;don&#x27;t exist in other C/C++ based langs&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;For example, there&#x27;s the first line of one of my funcs:&lt;br&gt;&lt;code&gt;ubyte[] encode(ubyte[] data, ubyte[] key){&lt;/code&gt;&lt;/p&gt;&lt;p&gt;But I can&#x27;t use an array without fixed lenght in other languages!How can I import that function, for example, in Python?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;EDIT:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;I know that I can create a wrapper that takes a pointer and the lenght of the array, but isn&#x27;t there a more elegant solution?&lt;br&gt;(Where I don&#x27;t need to use D to use a lib written in D)&lt;/p&gt;</Body>
<Tags>python,dll,d</Tags>
</question>
<answer>
<Body>&lt;p&gt;Well tbh. there&#x27;s no real elegant way other than wrapping a pointer with a length or wrapping to C arrays and then to D.&lt;/p&gt;&lt;p&gt;However you can make a somewhat elegant purpose with the first way using a struct that has a pointer, a length and a property that converts it to a D array.&lt;/p&gt;&lt;p&gt;Then the function you export takes your struct, all that function should do is call an internal function that takes an actual D array and you&#x27;d simply pass the array to it and the conversion would happen at that moment through alias this and the conversion property.&lt;/p&gt;&lt;p&gt;An example usage is here:    module main;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import core.stdc.stdlib : malloc;import std.stdio;struct DArray(T) {    T* data;    size_t length;    /// This field can be removed, only used for testing purpose    size_t offset;    @property T[] array() {        T[] arr;        foreach(i; 0 .. length) {            arr ~= data[i];        }        return arr;    }    alias array this;    /// This function can be removed, only used for testing purpose    void init(size_t size) {        data = cast(T*)malloc(size * T.sizeof);        length = size;    }    /// This function can be removed, only used for testing purpose    void append(T value) {        data[offset] = value;        offset++;    }}// This function is the one exportedvoid externalFoo(DArray!int intArray) {    writeln(&quot;Calling extern foo&quot;);    internalFoo(intArray);}// This function is the one you useprivate void internalFoo(int[] intArray) {    writeln(&quot;Calling internal foo&quot;);    writeln(intArray);}void main() {    // Constructing our test array    DArray!int arrayTest;    arrayTest.init(10);    foreach (int i; 0 .. 10) {        arrayTest.append(i);    }    // Testing the exported function     externalFoo(arrayTest);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is an absolute minimum version of how to do it&lt;/p&gt;&lt;pre&gt;&lt;code&gt;struct DArray(T) {    T* data;    size_t length;    @property T[] array() {        T[] arr;        foreach(i; 0 .. length) {            arr ~= data[i];        }        return arr;    }    alias array this;}// This function is the one exportedvoid externalFoo(DArray!int intArray) {    writeln(&quot;Calling extern foo&quot;);    internalFoo(intArray);}// This function is the one you useprivate void internalFoo(int[] intArray) {    writeln(&quot;Calling internal foo&quot;);    writeln(intArray);}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
