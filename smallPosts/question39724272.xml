<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>error: call to implicitly-deleted copy constructor of &#x27;std::__1::unique_ptr&lt;A, std::__1::default_delete&lt;A&gt; &gt;&#x27;</Title>
<Body>&lt;p&gt;I&#x27;m constructing an object that takes a &lt;code&gt;std::vector&amp;lt;std::unique_ptr&amp;lt;A&amp;gt; &amp;gt;&lt;/code&gt; as an argument. The constructor is defined like this&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class B {    std::vector &amp;lt;std::unique_ptr&amp;lt;A&amp;gt; &amp;gt; e_;public:    B(std::vector &amp;lt;std::unique_ptr&amp;lt;A&amp;gt; &amp;gt; e) : e_(std::move(e)){}};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and then used as&lt;/p&gt;&lt;pre&gt;&lt;code&gt;std::vector &amp;lt;std::unique_ptr&amp;lt;A&amp;gt; &amp;gt; e;B b(e);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and Xcode presents the error &lt;/p&gt;&lt;pre&gt;&lt;code&gt;error: call to implicitly-deleted copy constructor of &#x27;std::__1::unique_ptr&amp;lt;A, std::__1::default_delete&amp;lt;A&amp;gt; &amp;gt;&#x27;:new((void*)__p) _Up(_VSTD::forward&amp;lt;_Args&amp;gt;(__args)...);                 ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Why is the error still persisting even though i am using &lt;code&gt;std::move()&lt;/code&gt;?&lt;/p&gt;&lt;p&gt;EDIT: the error seems to vanish if i use &lt;code&gt;B b(std::move(e))&lt;/code&gt; instead of &lt;code&gt;B b(e))&lt;/code&gt;, is there any way to move the &lt;code&gt;move&lt;/code&gt; logic to the implementation of the function?&lt;/p&gt;</Body>
<Tags>c++,xcode,c++11</Tags>
</question>
<answer>
<Body>&lt;p&gt;Your constructor argument is pass by value which will make a copy, but you cannot copy a std::unique_ptr. Passing by reference should work:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class B {    std::vector &amp;lt;std::unique_ptr&amp;lt;float&amp;gt; &amp;gt; e_;public:    B(std::vector &amp;lt;std::unique_ptr&amp;lt;float&amp;gt; &amp;gt;&amp;amp; e) : e_(std::move(e)){}};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But...I agree with the other comments that this is bad design. If you want &lt;code&gt;B&lt;/code&gt; to own &lt;code&gt;e&lt;/code&gt; but also want to manipulate &lt;code&gt;e&lt;/code&gt; outside of &lt;code&gt;B&lt;/code&gt; then it should be a public member, no fancy constructor needed:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class B {public:    std::vector &amp;lt;std::unique_ptr&amp;lt;float&amp;gt; &amp;gt; e_;};&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;Why is the error still persisting even though i am using std::move()?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Because you are moving argument of ctor of &lt;code&gt;B&lt;/code&gt; into member, which does not mean that variable &lt;code&gt;e&lt;/code&gt; should or could be moved.&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;is there any way to move the move logic to the implementation of the function?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Even if it is possible, you should not do it. It should be clear for reader of code where &lt;code&gt;e&lt;/code&gt; is used, that it was moved and cannot be used anymore.&lt;/p&gt;</Body>
</answer>
</qroot>
