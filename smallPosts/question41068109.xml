<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Postgres: Could not choose a best candidate function</Title>
<Body>&lt;p&gt;Can someone explain how to fix this query?&lt;/p&gt;&lt;pre&gt;&lt;code&gt;SELECT date_part(&#x27;month&#x27;, scheduler_scheduleevents.date), sum(price)    FROM user_settings_userservices    JOIN scheduler_scheduleevents    ON scheduler_scheduleevents.service_type_id = user_settings_userservices.id    WHERE user_settings_userservices.salonid_id = %s    AND is_start_time = True and is_active = False    AND ( date &amp;lt; %s or ( date = %s and time &amp;lt; %s ) )    AND date_part(&#x27;year&#x27;, scheduler_scheduleevents.date) = date_part(&#x27;year&#x27;, %s)    GROUP BY date_part(&#x27;month&#x27;, scheduler_scheduleevents.date),    (request.user.id, now_date, now_date, now_time, now_date, )    )&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When I try execute this query in django app I get this warning:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;function date_part(unknown, unknown) is not uniqueLINE 9: ...ate_part(&#x27;year&#x27;, scheduler_scheduleevents.date) = date_part(...                                                         ^HINT:  Could not choose a best candidate function. You might need to add explicit type casts.&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>python,sql,django,postgresql</Tags>
</question>
<answer>
<Body>&lt;p&gt;You should add an explicit cast:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;AND date_part(&#x27;year&#x27;, scheduler_scheduleevents.date::date) = date_part(&#x27;year&#x27;, %s::date)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You get this error when postgres can&#x27;t figure out which actual function execute.&lt;/p&gt;&lt;p&gt;Postgres has the &lt;code&gt;date_part&lt;/code&gt; function overloaded, it has a version for a &lt;em&gt;timestamp&lt;/em&gt; as second parameter, and another for an &lt;em&gt;interval&lt;/em&gt; second parameter: &lt;code&gt;date_part(text, timestamp)&lt;/code&gt; and &lt;code&gt;date_part(text, interval)&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;When you say &lt;code&gt;date_part(&#x27;year&#x27;, %s)&lt;/code&gt; postgres doesn&#x27;t know if it should interprete your &lt;code&gt;%s&lt;/code&gt; parameter as a &lt;em&gt;timestamp&lt;/em&gt; or as a &lt;em&gt;interval&lt;/em&gt;. So it needs you to cast your %s parameter to a type that only matches one of those two versions of the date_part function. When you cast %s to &lt;em&gt;date&lt;/em&gt;  (i.e. when you write &lt;code&gt;%s::date&lt;/code&gt;) postgres can only use the first overload of the function, because a &lt;em&gt;date&lt;/em&gt; can be casted automatically to &lt;em&gt;timestamp&lt;/em&gt; but can&#x27;t be casted automatically to &lt;em&gt;interval&lt;/em&gt;&lt;/p&gt;</Body>
</answer>
</qroot>
