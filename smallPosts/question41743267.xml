<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>How to wait for unknown number of processes to end</Title>
<Body>&lt;p&gt;&lt;strong&gt;The scenario:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;There are several processes running on a machine. Names and handles unknown, but they all have a piece of code running in them that&#x27;s under our control.&lt;/p&gt;&lt;p&gt;A command line process is run. It signals to the other processes that they need to end (SetEvent), which our code picks up and handles within the other processes.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;The goal:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;The command line process needs to &lt;em&gt;wait&lt;/em&gt; until the other processes have ended. How can this be achieved?&lt;/p&gt;&lt;p&gt;All that&#x27;s coming to mind is to set up some shared memory or something and have each process write its handle into it so the command line process can wait on them, but this seems like so much effort for what it is. There must be some kernel level reference count that can be waited on?&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Edit 1:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;I&#x27;m thinking maybe assigning the processes to a job object, then the command line processes can wait on that? Not ideal though...&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Edit 2:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Can&#x27;t use job objects as it would interfere with other things using jobs. So now I&#x27;m thinking that the processes would obtain a handle to some/any sync object (semaphore, event, etc), and the command line process would poll for its existance. It would have to poll as if it waited it would keep the object alive. The sync object gets cleaned up by windows when the processes die, so the next poll would indicate that there are no processes. Not the niceset, cleanest method, but simple enough for the job it needs to do. Any advance on that?&lt;/p&gt;</Body>
<Tags>c++,winapi,synchronization</Tags>
</question>
<answer>
<Body>&lt;p&gt;You can do either of following ways.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Shared Memory (memory mapped object)&lt;/strong&gt; : CreateFileMapping, then  MapViewOfFile --&gt; Proceed the request. UnmapViewFile. Close the file,&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Named Pipe&lt;/strong&gt; : Create a nameed pipe for each application. And keep running a thread to read the file. So, You can write end protocol from your application by connecting to that named pipe. ( U can implement a small database as like same )&lt;/p&gt;&lt;p&gt;&lt;strong&gt;WinSock&lt;/strong&gt; : (Dont use if you have more number of processes. Since you need to send end request to the other process. Either the process should bind to your application or it should be listening in a port.)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Create a file/DB&lt;/strong&gt; : Share the file between the processes. ( You can have multiple files if u needed ). Make locking before reading or writing.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I would consider a solution using two objects:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a shared semaphore object, created by the main (controller?) app, with an initial count of 0, just before requesting the other processes to terminate (calling &lt;code&gt;SetEvent()&lt;/code&gt;) - I assume that the other processes don&#x27;t create this event object, neither they fail if it has not been created yet.&lt;/li&gt;&lt;li&gt;a mutex object, created by the other (child?) processes, used not for waiting on it, but for allowing the main process to check for its existence (if all child processes terminate it should be destroyed). Mutex objects have the distinction that can be &quot;created&quot; by more than one processes (according to the documentation).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Synchronization would be as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The child processes on initialization should create the Mutex object (set initial ownership to &lt;code&gt;FALSE&lt;/code&gt;).&lt;/li&gt;&lt;li&gt;The child processes upon receiving the termination request should increase the semaphore count by one (&lt;code&gt;ReleaseSemaphore()&lt;/code&gt;) and then exit normally.&lt;/li&gt;&lt;li&gt;The main process would enter a loop calling &lt;code&gt;WaitForSingleObject()&lt;/code&gt; on the semaphore with a reasonably small timeout (eg some 250 msec), and then check not whether the object was granted or a timeout has occurred, but whether the mutex still exists - if not, this means that all child processes terminated.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This setup avoids making an interprocess communication scheme (eg having the child processes communicating their handles back - the number of which is unknown anyway), while it&#x27;s not strictly speaking &quot;polling&quot; either. Well, there is some timeout involved (and some may argue that this alone is polling), but the check is also performed after each process has reported that it&#x27;s terminating (you can employ some tracing to see how many times the timeout has actually elapsed).&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The simple approach: you already have an event object that every subordinate process has open, so you can use that.  After setting the event in the master process, close the handle, and then poll until you discover that the event object no longer exists.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;The better approach:&lt;/strong&gt; named pipes as a synchronization object, as already suggested.  &lt;strong&gt;That sounds complicated, but it isn&#x27;t.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;The idea is that each of the subordinate processes creates an instance of the named pipe (i.e., all with the same name) when starting up.  There&#x27;s no need for a listening thread, or indeed any I/O logic at all; you just need to create the instance using &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365150(v=vs.85).aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;CreateNamedPipe&lt;/a&gt;, then throw away the handle without closing it.  When the process exits, the handle is closed automatically, and that&#x27;s all we need.&lt;/p&gt;&lt;p&gt;To see whether there are any subordinate processes, the master process would attempt to connect to that named pipe using &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;CreateFile&lt;/a&gt;.  If it gets a file not found error, there are no subordinate processes, so we&#x27;re done.&lt;/p&gt;&lt;p&gt;If the connection succeeded, there&#x27;s at least one subordinate process that we need to wait for.  (When you attempt to connect to a named pipe with more than one available instance, Windows chooses which instance to connect you to.  It doesn&#x27;t matter to us which one it is.)&lt;/p&gt;&lt;p&gt;The master process would then call &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa365467(v=vs.85).aspx&quot; rel=&quot;nofollow noreferrer&quot;&gt;ReadFile&lt;/a&gt; (just a simple synchronous read, one byte will do) and wait for it to fail.  Once you&#x27;ve confirmed that the error code is &lt;code&gt;ERROR_BROKEN_PIPE&lt;/code&gt; (it will be, unless something has gone seriously wrong) you know that the subordinate process in question has exited.  You can then loop around and attempt another connection, until no more subordinate processes remain.&lt;/p&gt;&lt;p&gt;(I&#x27;m assuming here that the user will have to intervene if one or more subordinates have hung.  It isn&#x27;t impossible to keep track of the process IDs and do something programmatically if that is desirable, but it&#x27;s not entirely trivial and should probably be a separate question.)&lt;/p&gt;</Body>
</answer>
</qroot>
