<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Forcing class instances to be const</Title>
<Body>&lt;p&gt;Is there any way to force to only allow const instances of class to be instantiated, and have non-const instances be detected as an error by the compiler?&lt;/p&gt;</Body>
<Tags>c++</Tags>
</question>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;Is there any way to force to only allow const instances of class to be instantiated, and have non-const instances be detected as an error by the compiler?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;No.&lt;/p&gt;&lt;p&gt;But you can declare all members as const. Then both const and non-const instances would behave largely in the same way and it shouldn&#x27;t matter whether the instances are const.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;is there any generic way to take an existing class, and &quot;constify&quot; it by removing all non-const functionality?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;One possible workaround is to create a wrapper class that holds an instance of the class and only gives access to a &lt;code&gt;const&lt;/code&gt; reference to it.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;class T&amp;gt;class Immutable {public:    template&amp;lt;typename... Args&amp;gt;    Immutable(Args&amp;amp;&amp;amp;... args) : instance(forward&amp;lt;Args&amp;gt;(args)...) {    }    operator const T&amp;amp;() {        return instance;    }    const T&amp;amp; get() const {        return instance;    }private:    Immutable&amp;amp; operator=(const Immutable&amp;amp; other) = delete;    T instance;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Suppose you have a mutable class &lt;code&gt;Class&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Class {public:    Class() : m_value(0) {    }    Class(const Class&amp;amp; other) : m_value(other.m_value) {    }    Class(int value) : m_value(value) {    }    Class(int x, int y) : m_value(x + y) {    }    void change(int value) {        m_value = value;    }    int value() const {        return m_value;    }private:    int m_value;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how &lt;code&gt;Immutable&amp;lt;Class&amp;gt;&lt;/code&gt; can be used:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void functionTakingConstReference(const Class&amp;amp; x) {}void functionTakingNonConstReference(Class&amp;amp; x) {}void functionTakingImmutableClass(Immutable&amp;lt;Class&amp;gt;&amp;amp; x) {}void functionTakingValue(Class x) {}int main(int argc, char *argv[]){    // Any constructor of Class can also be used with Immutable&amp;lt;Class&amp;gt;.    Immutable&amp;lt;Class&amp;gt; a;    Immutable&amp;lt;Class&amp;gt; b(1);    Immutable&amp;lt;Class&amp;gt; c(2, 3);    Immutable&amp;lt;Class&amp;gt; d(c);    // Compiles and works as expected.    functionTakingConstReference(a);    functionTakingImmutableClass(a);    functionTakingValue(a);    cout &amp;lt;&amp;lt; a.get().value() &amp;lt;&amp;lt; endl;    // Doesn&#x27;t compile because operator= is deleted.    // b = a;    // Doesn&#x27;t compile because &quot;change&quot; is a non-const method.    // a.get().change(4);    // Doesn&#x27;t compile because the function takes a non-const reference to Class as an argument.    // functionTakingNonConstReference(a);    return 0;}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I think you are looking for an immutable class. An easy way to get immutability is to declare all member variables as &lt;code&gt;const&lt;/code&gt;. This way you ensure that the state of your objects will not change after construction. This guarantee is independent of whether your object is &lt;code&gt;const&lt;/code&gt; and even if you have &lt;code&gt;non-const&lt;/code&gt; member functions for that class.For example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Foo{public:    Foo(int id, double value) : m_id(id), m_value(value) { }    int Id() const { return m_id; }    double Value() const { return m_value; }private:    const int m_id;    const double m_value;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another way you could generate an immutable object of any type is through a template class. Something like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Bar{public:    Bar(int id, double value) : m_id(id), m_value(value) { }    int Id() const { return m_id; }    double Value() const { return m_value; }    void SetId(int id) { m_id = id; }private:    int m_id;    double m_value;};template&amp;lt;typename T&amp;gt;class MyImmutable{public:    const T m_obj;    MyImmutable(const T&amp;amp; obj) : m_obj(obj)    { }};int main(){    cout &amp;lt;&amp;lt; &quot;Hello World!&quot; &amp;lt;&amp;lt; endl;    Foo a(1,2.0);    Bar x(2,3.0);    MyImmutable&amp;lt;Bar&amp;gt; y(x);    cout &amp;lt;&amp;lt; &quot;a.id    = &quot; &amp;lt;&amp;lt; a.Id() &amp;lt;&amp;lt; endl;    cout &amp;lt;&amp;lt; &quot;a.value = &quot; &amp;lt;&amp;lt; a.Value() &amp;lt;&amp;lt; endl;    cout &amp;lt;&amp;lt; &quot;y.id    = &quot; &amp;lt;&amp;lt; y.m_obj.Id() &amp;lt;&amp;lt; endl;    cout &amp;lt;&amp;lt; &quot;y.value = &quot; &amp;lt;&amp;lt; y.m_obj.Value() &amp;lt;&amp;lt; endl;    y.m_obj.SetId(2); // calling non-const member throws an error.    return 0;}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
