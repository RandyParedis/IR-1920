<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>No matching function std::forward with lambdas</Title>
<Body>&lt;p&gt;Consider the following code, inspired from Barry&#x27;s answer to &lt;a href=&quot;https://stackoverflow.com/a/42036525/882932&quot;&gt;this&lt;/a&gt; question:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Include#include &amp;lt;tuple&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;type_traits&amp;gt;// Generic overload ranktemplate &amp;lt;std::size_t N&amp;gt; struct overload_rank : overload_rank&amp;lt;N - 1&amp;gt; {};// Default overload ranktemplate &amp;lt;&amp;gt; struct overload_rank&amp;lt;0&amp;gt; {};// Prepend argument to functiontemplate &amp;lt;std::size_t N, class F&amp;gt;auto prepend_overload_rank(F&amp;amp;&amp;amp; f) {    using rank = overload_rank&amp;lt;N&amp;gt;;    return [f = std::forward&amp;lt;F&amp;gt;(f)](rank, auto&amp;amp;&amp;amp;... args) -&amp;gt; decltype(auto) {        return std::forward&amp;lt;F&amp;gt;(f)(std::forward&amp;lt;decltype(args)&amp;gt;(args)...); // here    };}// Mainint main(int argc, char* argv[]){    auto f = [](int i){return i;};    prepend_overload_rank&amp;lt;5&amp;gt;(f)(overload_rank&amp;lt;5&amp;gt;(), 1);    return 0;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is not compiling because of line noted &lt;code&gt;here&lt;/code&gt;, and I don&#x27;t understand why:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;With g++:error: no matching function for call to &#x27;forward&amp;lt;main(int, char**)::&amp;lt;lambda(int)&amp;gt;&amp;amp;&amp;gt;(const main(int, char**)::&amp;lt;lambda(int)&amp;gt;&amp;amp;)&#x27;With clang:error: no matching function for call to &#x27;forward&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Replacing &lt;/p&gt;&lt;pre&gt;&lt;code&gt;return std::forward&amp;lt;F&amp;gt;(f)(std::forward&amp;lt;decltype(args)&amp;gt;(args)...); &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;by&lt;/p&gt;&lt;pre&gt;&lt;code&gt;return f(std::forward&amp;lt;decltype(args)&amp;gt;(args)...); &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;apparently makes it work, but again, I don&#x27;t understand why, and my goal is to achieve a perfect forwarding of the function.&lt;/p&gt;</Body>
<Tags>c++,templates,lambda,c++14,perfect-forwarding</Tags>
</question>
<answer>
<Body>&lt;p&gt;Apparently compilers are either bugged or allowed to declare variables captured by copy as &lt;code&gt;const&lt;/code&gt; when the &lt;code&gt;mutable&lt;/code&gt; specifier is not present.&lt;br&gt;Ironically, the following compiles with GCC, but it doesn&#x27;t with clang:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;type_traits&amp;gt;int main(int argc, char* argv[]) {    int i = 0;    [j = i](){ static_assert(std::is_same&amp;lt;decltype(j), const int&amp;gt;::value, &quot;!&quot;); }();}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To work around the issue in both cases you can do this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;return [f = std::forward&amp;lt;F&amp;gt;(f)](auto&amp;amp;&amp;amp;... args) -&amp;gt; decltype(auto) {    return std::forward&amp;lt;decltype(f)&amp;gt;(f)(std::forward&amp;lt;decltype(args)&amp;gt;(args)...); // here};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is, you can omit the &lt;code&gt;mutable&lt;/code&gt; keyword, but you have to use the actual type of the copy of &lt;code&gt;f&lt;/code&gt; within the lambda. Note that the &lt;em&gt;original&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; is a non-const reference to a lambda function, thus &lt;code&gt;F&lt;/code&gt; can differ from the type &lt;code&gt;decltype(f)&lt;/code&gt; within the lambda.&lt;br&gt;This is valid in any case, even for &lt;code&gt;mutable&lt;/code&gt; lambda. As an example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;type_traits&amp;gt;#include&amp;lt;utility&amp;gt;struct S {};template&amp;lt;typename T&amp;gt;void f(T &amp;amp;&amp;amp;t) {    [t = std::forward&amp;lt;T&amp;gt;(t)]()mutable{ static_assert(std::is_same&amp;lt;decltype(t), S&amp;gt;::value, &quot;!&quot;); }();    // the following doesn&#x27;t compile for T is S&amp;amp; that isn&#x27;t the type of t within the lambda    //[t = std::forward&amp;lt;T&amp;gt;(t)]()mutable{ static_assert(std::is_same&amp;lt;decltype(t), T&amp;gt;::value, &quot;!&quot;); }();}int main() {    S s;    f(s);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In general, you should use the actual type of the captured variable instead of the type given in a surrounding context.&lt;br&gt;In the specific case, even though the compiler wrongly declares the captured variable as &lt;code&gt;const&lt;/code&gt;, you can make it work without the &lt;code&gt;mutable&lt;/code&gt; specifier as long as the function operator of &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;const&lt;/code&gt; (that is your case, for &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;main&lt;/code&gt; isn&#x27;t &lt;code&gt;mutable&lt;/code&gt; as well).&lt;/p&gt;&lt;p&gt;Another way to let your snippet work is this (as suggested in the comments to the question):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;return [f = std::forward&amp;lt;F&amp;gt;(f)](auto&amp;amp;&amp;amp;... args) mutable -&amp;gt; decltype(auto) {    return std::forward&amp;lt;F&amp;gt;(f)(std::forward&amp;lt;decltype(args)&amp;gt;(args)...); // here};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, variables captured by copy cannot be forced to be &lt;code&gt;const&lt;/code&gt; and the type is the expected one.&lt;br&gt;Anyway, I&#x27;d suggest to take the advice above even if you are planning to use the &lt;code&gt;mutable&lt;/code&gt; specifier.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;Note.&lt;br&gt;As discussed in &lt;a href=&quot;https://stackoverflow.com/questions/42046021/non-mutable-lambda-function-are-copy-captured-variables-allowed-to-be-const&quot;&gt;this question&lt;/a&gt; the problem arose because of a bug of GCC. The suggestion to use &lt;code&gt;decltype(f)&lt;/code&gt; still stands. It addresses also other types of problems and works for the specific case. Moreover, in case the bug is fixed, the code will continue to work properly.&lt;/p&gt;</Body>
</answer>
</qroot>
