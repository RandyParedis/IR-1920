<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Why is there a 0 floating point in my Quicksort algorithm list and how to include a NaN into my Quicksort algorithm?</Title>
<Body>&lt;p&gt;The following is my code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;limits&amp;gt;#define INFINITY std::numeric_limits&amp;lt;float&amp;gt;::infinity()#define NEGINFINITY -std::numeric_limits&amp;lt;float&amp;gt;::infinity()int floatcomp(const void* elem1, const void* elem2){    if (*(const float*)elem1 &amp;lt; *(const float*)elem2)        return -1;    return *(const float*)elem1 &amp;gt; *(const float*)elem2;}int main(){    float array[10] = {INFINITY, 3.5f, 144.4f, NAN, 12.4f, NEGINFINITY, 1.4f, -0.0f, 5.9f};    int i;    for (i = 0; i &amp;lt; 10; i++)        printf(&quot;%f\n&quot;, array[i]);    printf(&quot;\n&quot;);    qsort(array, 10, sizeof(float), floatcomp);    for (i = 0; i &amp;lt; 10; i++)        printf(&quot;%f\n&quot;, array[i]);    return 0;}       &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The quicksort algorithm sorts the numbers entered in the correct order however, there is a 0.00000 always present in the list.&lt;/p&gt;&lt;p&gt;Also while adding the NaN to the array, the NaN is not sorted properly as it should be and I&#x27;m not able to correctly add in two different mantissa&#x27;s for the NaN into my code as a string at the top.&lt;/p&gt;</Body>
<Tags>c++,algorithm,quicksort,nan</Tags>
</question>
<answer>
<Body>&lt;p&gt;To answer why there is a zero always included, that&#x27;s because you are declaring an array of 10 elements, but you initialize it with only 9, so the 10th is zero.&lt;/p&gt;&lt;p&gt;As for the NaN, you should explain precisely what your definition of sorting a NaN &quot;properly&quot; is, and how the result differs from what you expected.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Using the normal operator rules for comparing doubles, sorting a list containing Nans is technically undefined behaviour as a &amp;lt; b and b &amp;lt; a may not be consistent. So you have to detect Nan and make it either the highest or lowest value explicitly. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;int myisnan(float x){   return (x == x) ? 0 : 1;}int floatcomp(const void* elem1, const void* elem2){    int nan1= myisnan( *(const float *) elem1);    int nan2 = myisnan( *(const float *) elem2);     if(nan1 &amp;amp;&amp;amp; nan2)        return 0;     if(nan1 &amp;amp;&amp;amp; !nan2)        return -1;     if(!nan1 &amp;amp;&amp;amp; nan2)        return 1;    if (*(const float*)elem1 &amp;lt; *(const float*)elem2)        return -1;    return *(const float*)elem1 &amp;gt; *(const float*)elem2; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Use a &quot;my&quot; function to prevent name clashes with other isnan() functions which may or may not have been defined. nans do not equal each other, all operations with them return NaN or false.&lt;/p&gt;</Body>
</answer>
</qroot>
