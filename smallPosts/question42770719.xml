<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>pyqt how to create a wait popup for running a long function/calulation</Title>
<Body>&lt;p&gt;I am trying to create a dialog window that pops up, runs a function and then automatically closes when the function is done.  In the code below, the function runs before popping up the dialog and I cannot automatically close otherwise the dialog window will pop up and not respond to clicking the &quot;x&quot; button.&lt;/p&gt;&lt;p&gt;How can I create a pop-up, run a function after the pop-up is visible, and then close the pop-up when the function is done running.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# from PyQt4 import QtGui# QtWidgets = QtGuifrom PyQt5 import QtWidgets, QtCoreimport sys, timeapp = QtWidgets.QApplication(sys.argv)def print_every_3_seconds():    print(0)    for i in range(1, 4):        time.sleep(1)        print(i)class RunFunctionDialog(QtWidgets.QDialog):    def __init__(self, function, parent=None):        super(RunFunctionDialog, self).__init__(parent)        self.layout = QtWidgets.QVBoxLayout(self)        self.textBrowser = QtWidgets.QTextBrowser()        self.textBrowser.setText(&quot;Wait 3 seconds&quot;)        self.layout.addWidget(self.textBrowser)        self.function = function    def showEvent(self, QShowEvent):        self.function()        # self.close()  # dialog freezes in an unresponsive statedef show_dialog():    dialog = RunFunctionDialog(print_every_3_seconds)    dialog.exec_()widget = QtWidgets.QWidget(None)button = QtWidgets.QPushButton(&quot;Show Dialog&quot;, widget)button.clicked.connect(show_dialog)widget.show()app.exec_()&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>python,pyqt</Tags>
</question>
<answer>
<Body>&lt;p&gt;Create a worker thread and put your worker function in there. This will prevent your main (gui) thread from getting blocked by the worker function. You can use the QThread class for this. This has the advantage of having a &lt;em&gt;finished&lt;/em&gt; signal that you can use to close your dialog if work is finished.&lt;/p&gt;&lt;p&gt;First you need to create a WorkerThread by simply subclassing QThread:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class WorkerThread(QtCore.QThread):    def run(self):        print_every_3_seconds()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then you create an instance of the Worker class in your &lt;code&gt;RunFunctionDialog.__init__()&lt;/code&gt;, connect the &lt;code&gt;finished&lt;/code&gt; signal to your &lt;code&gt;close&lt;/code&gt; slot and start the thread.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class RunFunctionDialog(QtWidgets.QDialog):    def __init__(self, function, parent=None):        super(RunFunctionDialog, self).__init__(parent)        # ...        self.function = function        self.thread = WorkerThread()        self.thread.finished.connect(self.close)        self.thread.start()&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
