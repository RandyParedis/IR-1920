<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Can we create unnamed socket with boost.asio to emulate anonymous pipe?</Title>
<Body>&lt;p&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man2/socketpair.2.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;socketpair()&lt;/a&gt; on Linux lets you create unnamed socket. Is something similar in boost.asio library possible? I&#x27;m trying to emulate anonymous pipe with boost.asio library. I know boost.process supports this but I want to use boost.asio library. By-the-way why is anonymous pipe missing from boost.asio?&lt;/p&gt;</Body>
<Tags>c++,boost,ipc,boost-asio</Tags>
</question>
<answer>
<Body>&lt;p&gt;I wrote the code below to emulate pipe using boost.asio library. Its only demo code and there is no message boundary checking, error checking etc.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;boost/asio.hpp&amp;gt;#include &amp;lt;boost/bind.hpp&amp;gt;#include &amp;lt;boost/date_time/posix_time/posix_time.hpp&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cctype&amp;gt;#include &amp;lt;boost/array.hpp&amp;gt;using boost::asio::local::stream_protocol;int main(){    try    {        boost::asio::io_service io_service;        stream_protocol::socket parentSocket(io_service);        stream_protocol::socket childSocket(io_service);        //create socket pair        boost::asio::local::connect_pair(childSocket, parentSocket);        std::string request(&quot;Dad I am your child, hello!&quot;);        std::string dadRequest(&quot;Hello son!&quot;);        //Create child process        pid_t pid = fork();        if( pid &amp;lt; 0 ){            std::cerr &amp;lt;&amp;lt; &quot;fork() erred\n&quot;;        } else if (pid == 0 ) { //child process            parentSocket.close(); // no need of parents socket handle, childSocket is bidirectional stream socket unlike pipe that has different handles for read and write            boost::asio::write(childSocket, boost::asio::buffer(request)); //Send data to the parent            std::vector&amp;lt;char&amp;gt; dadResponse(dadRequest.size(),0);            boost::asio::read(childSocket, boost::asio::buffer(dadResponse)); //Wait for parents response            std::cout &amp;lt;&amp;lt; &quot;Dads response: &quot;;            std::cout.write(&amp;amp;dadResponse[0], dadResponse.size());            std::cout &amp;lt;&amp;lt; std::endl;        } else { //parent            childSocket.close(); //Close childSocket here use one bidirectional socket            std::vector&amp;lt;char&amp;gt; reply(request.size());            boost::asio::read(parentSocket, boost::asio::buffer(reply)); //Wait for child process to send message            std::cout &amp;lt;&amp;lt; &quot;Child message: &quot;;            std::cout.write(&amp;amp;reply[0], request.size());            std::cout &amp;lt;&amp;lt; std::endl;            sleep(5); //Add 5 seconds delay before sending response to parent            boost::asio::write(parentSocket, boost::asio::buffer(dadRequest)); //Send child process response        }    }    catch (std::exception&amp;amp; e)    {        std::cerr &amp;lt;&amp;lt; &quot;Exception: &quot; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; &quot;\n&quot;;        std::exit(1);    }}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
