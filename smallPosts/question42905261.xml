<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Reading block by block from file then split test line by line</Title>
<Body>&lt;p&gt;I am reading from a file into a buffer then I am dividing the read text into string where each text ends by a new line forms a new string. &lt;/p&gt;&lt;p&gt;Here is my code: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;int ysize = 20000;char buffer2[ysize];int flag = 0;string temp_str;vector&amp;lt;string&amp;gt; temp;while(fread(buffer2, ysize, 1, fp2)&amp;gt;0){    //printf(&quot;%s&quot;, buffer2);    std::string str(buffer2);    //push the data into the vect    std::string::size_type pos = 0;    std::string::size_type prev = 0;    /*means the last read did not read a full sentence*/    if (flag == 1) {        if (buffer[0] == &#x27;\n&#x27;) {          //this means we have read the last senstense correctly, directly go to the next        }        else{            if((pos = str.find(&quot;\n&quot;, prev)) != std::string::npos){                temp_str+=str.substr(prev, pos - prev);                temp.push_back(temp_str);                prev = pos + 1;            }            while ((pos = str.find(&quot;\n&quot;, prev)) != std::string::npos)            {                temp.push_back(str.substr(prev, pos - prev));                prev = pos + 1;            }            // To get the last substring (or only, if delimiter is not found)            temp.push_back(str.substr(prev));            if (buffer2[19999] != &#x27;\n&#x27;) {                //we did not finish readind that query                flag = 1;                temp_str = temp.back();                temp.pop_back();            }            else{                flag = 0;            }        }    }    else{        while ((pos = str.find(&quot;\n&quot;, prev)) != std::string::npos)        {            temp.push_back(str.substr(prev, pos - prev));            prev = pos + 1;        }        // To get the last substring (or only, if delimiter is not found)        temp.push_back(str.substr(prev));        if (buffer2[19999] != &#x27;\n&#x27;) {            //we did not finish readind that query            flag = 1;            temp_str = temp.back();            temp.pop_back();        }        else{            flag = 0;        }}}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The problem is this doesn&#x27;t read the data correctly, it almost eliminates half of text. &lt;/p&gt;&lt;p&gt;I&#x27;m not sure what I am missing in here. My idea is to read the data block by block then divide it line by line which is what is happing in the while loop. I am handling the overflow cases using the flag. &lt;/p&gt;</Body>
<Tags>c++,c++11,iostream</Tags>
</question>
<answer>
<Body>&lt;p&gt;First note, that &lt;em&gt;fread&lt;/em&gt; does not magically create a null-terminated string, which means that &lt;em&gt;std::string str(buffer2)&lt;/em&gt; will result in undefined behaviour. So you should do something like &lt;/p&gt;&lt;pre&gt;&lt;code&gt;int nread = 0; while( (nread =fread(buffer2, ysize-1, 1, fp2)) &amp;gt; 0 ){    buffer2[nread] = 0;     std::string str(buffer2);    ...     &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To avoid the buffering approach you implemented here you could use &lt;a href=&quot;https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm&quot; rel=&quot;nofollow noreferrer&quot;&gt;fgets&lt;/a&gt; to read line by line, then you would have only to worry about concatenating lines that are longer than the read buffer.&lt;/p&gt;&lt;p&gt;Apart from the I&#x27;ve spotted one problem: If the first char in the buffer is newline and &lt;em&gt;flag==1&lt;/em&gt; you skip the whole current buffer and read the next one if there is still data available. (I assume that with &lt;em&gt;buffer[0]&lt;/em&gt; you actually mean buffer2[0]).&lt;/p&gt;</Body>
</answer>
</qroot>
