<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Determining if a number is prime</Title>
<Body>&lt;p&gt;I have perused a lot of code on this topic, but most of them produce the numbers that are prime all the way up to the input number.  However, I need code which only checks whether the given input number is prime.&lt;/p&gt;&lt;p&gt;Here is what I was able to write, but it does not work:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void primenumber(int number){    if(number%2!=0)      cout&amp;lt;&amp;lt;&quot;Number is prime:&quot;&amp;lt;&amp;lt;endl;    else       cout&amp;lt;&amp;lt;&quot;number is NOt prime&quot;&amp;lt;&amp;lt;endl;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I would appreciate if someone could give me advice on how to make this work properly.&lt;/p&gt;&lt;h3&gt;Update&lt;/h3&gt;&lt;p&gt;I modified it to check on all the numbers in a for loop.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void primenumber(int number){    for(int i=1; i&amp;lt;number; i++)    {       if(number%i!=0)          cout&amp;lt;&amp;lt;&quot;Number is prime:&quot;&amp;lt;&amp;lt;endl;       else           cout&amp;lt;&amp;lt;&quot;number is NOt prime&quot;&amp;lt;&amp;lt;endl;    }  }&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++,algorithm,primes</Tags>
</question>
<answer>
<Body>&lt;p&gt;You need to do some more checking. Right now, you are only checking if the number is divisible by 2. Do the same for 2, 3, 4, 5, 6, ... up to &lt;code&gt;number&lt;/code&gt;. Hint: use a &lt;strong&gt;loop&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;After you resolve this, try looking for optimizations.Hint: You only have to check all numbers up to the square root of the number&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I would guess taking sqrt and running foreach frpm 2 to sqrt+1 if(input% number!=0) return false;once you reach sqrt+1 you can be sure its prime. &lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;This code only checks if the number is divisible by two. For a number to be prime, it must not be evenly divisible by &lt;em&gt;all integers less than itself&lt;/em&gt;. This can be naively implemented by checking if it is divisible by all integers less than &lt;code&gt;floor(sqrt(n))&lt;/code&gt; in a loop. If you are interested, there are a number of &lt;a href=&quot;http://en.wikipedia.org/wiki/Primality_test#Fast_deterministic_tests&quot; rel=&quot;nofollow&quot;&gt;much faster algorithms&lt;/a&gt; in existence.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;If you know the range of the inputs (which you do since your function takes an &lt;code&gt;int&lt;/code&gt;), you can precompute a table of primes less than or equal to the square root of the max input (2^31-1 in this case), and then test for divisibility by each prime in the table less than or equal to the square root of the number given.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;There are several different approches to this problem.&lt;br&gt;The &quot;Naive&quot; Method: Try all (odd) numbers up to (the root of) the number.&lt;br&gt;Improved &quot;Naive&quot; Method: Only try every 6n Â± 1.&lt;br&gt;Probabilistic tests: Miller-Rabin, Solovay-Strasse, etc.  &lt;/p&gt;&lt;p&gt;Which approach suits you depends and what you are doing with the prime.&lt;br&gt;You should atleast read up on &lt;a href=&quot;http://en.wikipedia.org/wiki/Primality_test&quot; rel=&quot;nofollow&quot;&gt;Primality Testing&lt;/a&gt;.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;My own IsPrime() function, written and based on the deterministic variant of the famous Rabin-Miller algorithm, combined with optimized step brute forcing, giving you one of the fastest prime testing functions out there. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;__int64 power(int a, int n, int mod){ __int64 power=a,result=1; while(n) {  if(n&amp;amp;1)    result=(result*power)%mod;  power=(power*power)%mod;  n&amp;gt;&amp;gt;=1; } return result;}bool witness(int a, int n){ int t,u,i; __int64 prev,curr; u=n/2; t=1; while(!(u&amp;amp;1)) {  u/=2;  ++t; } prev=power(a,u,n); for(i=1;i&amp;lt;=t;++i) {  curr=(prev*prev)%n;  if((curr==1)&amp;amp;&amp;amp;(prev!=1)&amp;amp;&amp;amp;(prev!=n-1))    return true;  prev=curr; } if(curr!=1)   return true; return false;}inline bool IsPrime( int number ){ if ( ( (!(number &amp;amp; 1)) &amp;amp;&amp;amp; number != 2 ) || (number &amp;lt; 2) || (number % 3 == 0 &amp;amp;&amp;amp; number != 3) )  return (false); if(number&amp;lt;1373653) {  for( int k = 1; 36*k*k-12*k &amp;lt; number;++k)  if ( (number % (6*k+1) == 0) || (number % (6*k-1) == 0) )   return (false);  return true; } if(number &amp;lt; 9080191) {  if(witness(31,number)) return false;  if(witness(73,number)) return false;  return true; } if(witness(2,number)) return false; if(witness(7,number)) return false; if(witness(61,number)) return false; return true; /*WARNING: Algorithm deterministic only for numbers &amp;lt; 4,759,123,141 (unsigned int&#x27;s max is 4294967296)   if n &amp;lt; 1,373,653, it is enough to test a = 2 and 3.   if n &amp;lt; 9,080,191, it is enough to test a = 31 and 73.   if n &amp;lt; 4,759,123,141, it is enough to test a = 2, 7, and 61.   if n &amp;lt; 2,152,302,898,747, it is enough to test a = 2, 3, 5, 7, and 11.   if n &amp;lt; 3,474,749,660,383, it is enough to test a = 2, 3, 5, 7, 11, and 13.   if n &amp;lt; 341,550,071,728,321, it is enough to test a = 2, 3, 5, 7, 11, 13, and 17.*/}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To use, copy and paste the code into the top of your program. Call it, and it returns a BOOL value, either true or false.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if(IsPrime(number)){    cout &amp;lt;&amp;lt; &quot;It&#x27;s prime&quot;;}else{    cout&amp;lt;&amp;lt;&quot;It&#x27;s composite&quot;;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you get a problem compiling with &quot;__int64&quot;, replace that with &quot;long&quot;. It compiles fine under VS2008 and VS2010.&lt;/p&gt;&lt;p&gt;How it works:There are three parts to the function. Part checks to see if it is one of the rare exceptions (negative numbers, 1), and intercepts the running of the program.&lt;/p&gt;&lt;p&gt;Part two starts if the number is smaller than 1373653, which is the theoretically number where the Rabin Miller algorithm will beat my optimized brute force function. Then comes two levels of Rabin Miller, designed to minimize the number of witnesses needed. As most numbers that you&#x27;ll be testing are under 4 billion, the probabilistic Rabin-Miller algorithm can be made deterministic by checking witnesses 2, 7, and 61. If you need to go over the 4 billion cap, you will need a large number library, and apply a modulus or bit shift modification to the power() function.&lt;/p&gt;&lt;p&gt;If you insist on a brute force method, here is just my optimized brute force IsPrime() function:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;inline bool IsPrime( int number ){ if ( ( (!(number &amp;amp; 1)) &amp;amp;&amp;amp; number != 2 ) || (number &amp;lt; 2) || (number % 3 == 0 &amp;amp;&amp;amp; number != 3) )  return (false); for( int k = 1; 36*k*k-12*k &amp;lt; number;++k)  if ( (number % (6*k+1) == 0) || (number % (6*k-1) == 0) )   return (false);  return true; }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How this brute force piece works:All prime numbers (except 2 and 3) can be expressed in the form 6k+1 or 6k-1, where k is a positive whole number. This code uses this fact, and tests all numbers in the form of 6k+1 or 6k-1 less than the square root of the number in question. This piece is integrated into my larger IsPrime() function (the function shown first). &lt;/p&gt;&lt;p&gt;If you need to find all the prime numbers below a number, find all the prime numbers below 1000, look into the Sieve of Eratosthenes. Another favorite of mine.&lt;/p&gt;&lt;p&gt;As an additional note, I would love to see anyone implement the Eliptical Curve Method algorithm, been wanting to see that implemented in C++ for a while now, I lost my implementation of it. Theoretically, it&#x27;s even faster than the deterministic Rabin Miller algorithm I implemented, although I&#x27;m not sure if that&#x27;s true for numbers under 4 billion.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;If you are lazy, and have a lot of RAM, create a &lt;a href=&quot;http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot; rel=&quot;nofollow&quot;&gt;sieve of Eratosthenes&lt;/a&gt; which is practically a giant array from which you kicked all numbers that are not prime. From then on every prime &quot;probability&quot; test will be super quick.The upper limit for this solution for fast results is the amount of you RAM. The upper limit for this solution for superslow results is your hard disk&#x27;s capacity.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I follow same algorithm but different implementation that loop to sqrt(n) with step 2 only odd numbers because I check that if it is divisible by 2 or 2*k it is false. Here is my code &lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class PrimeTest {    public static boolean isPrime(int i) {        if (i &amp;lt; 2) {            return false;        } else if (i % 2 == 0 &amp;amp;&amp;amp; i != 2) {            return false;        } else {            for (int j = 3; j &amp;lt;= Math.sqrt(i); j = j + 2) {                if (i % j == 0) {                    return false;                }            }            return true;        }    }    /**     * @param args     */    public static void main(String[] args) {        for (int i = 1; i &amp;lt; 100; i++) {            if (isPrime(i)) {                System.out.println(i);            }        }    }}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;#define TRUE 1#define FALSE -1int main(){/* Local variables declaration */int num = 0;int result = 0;/* Getting number from user for which max prime quadruplet value is to be found */printf(&quot;\nEnter the number :&quot;);scanf(&quot;%d&quot;, &amp;amp;num);result = Is_Prime( num );/* Printing the result to standard output */if (TRUE == result)    printf(&quot;\n%d is a prime number\n&quot;, num);else    printf(&quot;\n%d is not a prime number\n&quot;, num);return 0;}int Is_Prime( int num ){int i = 0;/* Checking whether number is negative. If num is negative, makingit positive */if( 0 &amp;gt; num )    num = -num;/* Checking whether number is less than 2 */if( 2 &amp;gt; num )    return FALSE;/* Checking if number is 2 */if( 2 == num )    return TRUE;/* Checking whether number is even. Even numbersare not prime numbers */if( 0 == ( num % 2 ))    return FALSE;/* Checking whether the number is divisible by a smaller number1 += 2, is done to skip checking divisibility by even numbers.Iteration reduced to half */for( i = 3; i &amp;lt; num; i += 2 )    if( 0 == ( num % i ))        /* Number is divisible by some smaller number,         hence not a prime number */        return FALSE;return TRUE;}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;bool isPrime(int number){    if(number &amp;lt; 2) return false;    if(number == 2) return true;    if(number % 2 == 0) return false;    for(int i=3; (i*i)&amp;lt;=number; i+=2){        if(number % i == 0 ) return false;    }    return true;}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Use mathematics first find square root of number then start loop  till the number ends which you get after square rooting.check for each value whether the given number is divisible by the iterating value .if any value divides the given number then it is not a prime number otherwise prime.Here is the code&lt;/p&gt;&lt;pre&gt;&lt;code&gt; bool is_Prime(int n) {   int square_root = sqrt(n); // use math.h   int toggle = 1;   for(int i = 2; i &amp;lt;= square_root; i++)   {     if(n%i==0)     {         toggle = 0;        break;     }   }   if(toggle)     return true;   else     return false; } &lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;if(number%2!=0)      cout&amp;lt;&amp;lt;&quot;Number is prime:&quot;&amp;lt;&amp;lt;endl;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code is incredibly false. 33 divided by 2 is 16 with reminder of 1 but it&#x27;s not a prime number...&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;bool check_prime(int num) {    for (int i = num - 1; i &amp;gt; 1; i--) {        if ((num % i) == 0)            return false;    }    return true;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;checks for any number if its a prime number&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bool isPrime(int number){    if (number != 2){        if (number &amp;lt; 2 || number % 2 == 0) {            return false;        }        for(int i=3; (i*i)&amp;lt;=number; i+=2){            if(number % i == 0 ){                return false;            }        }    }    return true;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Javascript&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;function isPrime(number){    if (number !== 2) {        if (number &amp;lt; 2 || number % 2 === 0) {            return false;        }        for (var i=3; (i*i)&amp;lt;=number; i+=2)        {            if (number % 2 === 0){                return false;            }        }    }    return true;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def isPrime(number):    if (number != 2):        if (number &amp;lt; 2 or number % 2 == 0):            return False        i = 3        while (i*i) &amp;lt;= number:            if(number % i == 0 ):                return False;            i += 2    return True;&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;If n is 2, it&#x27;s prime.&lt;/p&gt;&lt;p&gt;If n is 1, it&#x27;s not prime.&lt;/p&gt;&lt;p&gt;If n is even, it&#x27;s not prime.&lt;/p&gt;&lt;p&gt;If n is odd, bigger than 2, we must check all odd numbers 3..sqrt(n)+1, if any of this numbers can divide n, n is not prime, else, n is prime.&lt;/p&gt;&lt;p&gt;For better performance i recommend sieve of eratosthenes.&lt;/p&gt;&lt;p&gt;Here is the code sample:&lt;/p&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;code&gt;bool is_prime(int n){  if (n == 2) return true;  if (n == 1 || n % 2 == 0) return false;  for (int i = 3; i*i &amp;lt; n+1; i += 2) {      if (n % i == 0) return false;  }  return true;}&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I came up with this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int counter = 0;bool checkPrime(int x) {   for (int y = x; y &amp;gt; 0; y--){      if (x%y == 0) {         counter++;      }   }   if (counter == 2) {      counter = 0; //resets counter for next input      return true; //if its only divisible by two numbers (itself and one) its a prime   }   else counter = 0;        return false;}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I Have Use This Idea For Finding If The No. Is Prime or Not:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;conio.h&amp;gt; #include &amp;lt;iostream&amp;gt;using namespace std;int main() {  int x, a;  cout &amp;lt;&amp;lt; &quot;Enter The No. :&quot;;  cin &amp;gt;&amp;gt; x;  int prime(unsigned int);  a = prime(x);  if (a == 1)    cout &amp;lt;&amp;lt; &quot;It Is A Prime No.&quot; &amp;lt;&amp;lt; endl;  else  if (a == 0)    cout &amp;lt;&amp;lt; &quot;It Is Composite No.&quot; &amp;lt;&amp;lt; endl;  getch();}int prime(unsigned int x) {  if (x == 1) {    cout &amp;lt;&amp;lt; &quot;It Is Neither Prime Nor Composite&quot;;    return 2;  }  if (x == 2 || x == 3 || x == 5 || x == 7)    return 1;  if (x % 2 != 0 &amp;amp;&amp;amp; x % 3 != 0 &amp;amp;&amp;amp; x % 5 != 0 &amp;amp;&amp;amp; x % 7 != 0)    return 1;  else    return 0;}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Someone above had the following.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bool check_prime(int num) {for (int i = num - 1; i &amp;gt; 1; i--) {    if ((num % i) == 0)        return false;}return true;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This mostly worked.  I just tested it in Visual Studio 2017.  It would say that anything less than 2 was also prime (so 1, 0, -1, etc.)&lt;/p&gt;&lt;p&gt;Here is a slight modification to correct this.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bool check_prime(int number){    if (number &amp;gt; 1)    {        for (int i = number - 1; i &amp;gt; 1; i--)        {            if ((number % i) == 0)                return false;        }        return true;    }    return false;}&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;This is a quick efficient one:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bool isPrimeNumber(int n) {    int divider = 2;    while (n % divider != 0) {        divider++;    }    if (n == divider) {        return true;    }    else {        return false;    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will start finding a divisible number of n, starting by 2. As soon as it finds one, if that number is equal to n then &lt;strong&gt;it&#x27;s prime&lt;/strong&gt;, otherwise it&#x27;s not.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;//simple function to determine if a number is a prime number//to state if it is a prime number#include &amp;lt;iostream&amp;gt;using namespace std;int isPrime(int x);  //functioned defined after int main()int main(){ int y;    cout&amp;lt;&amp;lt;&quot;enter value&quot;&amp;lt;&amp;lt;endl;    cin&amp;gt;&amp;gt;y;    isPrime(y);      return 0; } //end of main function//-------------function  int isPrime(int x) {   int counter =0;     cout&amp;lt;&amp;lt;&quot;factors of &quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&quot; are &quot;&amp;lt;&amp;lt;&quot;\n\n&quot;;    //print factors of the number     for (int i =0; i&amp;lt;=x; i++)     {       for (int j =0; j&amp;lt;=x; j++)         {           if (i * j == x)      //check if the number has multiples;                {                  cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; ,  &quot;;  //output provided for the reader to see the                                    // muliples                  ++counter;        //counts the number of factors                 }          }    }  cout&amp;lt;&amp;lt;&quot;\n\n&quot;;  if(counter&amp;gt;2)      {       cout&amp;lt;&amp;lt;&quot;value is not a prime number&quot;&amp;lt;&amp;lt;&quot;\n\n&quot;;     }  if(counter&amp;lt;=2)     {       cout&amp;lt;&amp;lt;&quot;value is a prime number&quot;&amp;lt;&amp;lt;endl;     } }&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
