<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Why does Python&#x27;s grammar specification not include docstrings and comments?</Title>
<Body>&lt;p&gt;I am consulting the official &lt;a href=&quot;https://docs.python.org/3/reference/grammar.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;Python grammar specification as of Python 3.6&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;I am unable to find any syntax for comments (they appear prepended with a &lt;code&gt;#&lt;/code&gt;) and docstrings (they should appear with &lt;code&gt;&#x27;&#x27;&#x27;&lt;/code&gt;). A quick look at &lt;a href=&quot;https://docs.python.org/3/reference/lexical_analysis.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;the lexical analysis&lt;/a&gt; page didn&#x27;t help either - docstrings are defined there as &lt;code&gt;longstrings&lt;/code&gt; but do not appear in the grammar specifications. A type named &lt;code&gt;STRING&lt;/code&gt; appears further, but no reference to its definition takes place.&lt;/p&gt;&lt;p&gt;Given this, I am curious about how the CPython compiler knows what comments and docstrings are. How is this feat accomplished? &lt;/p&gt;&lt;p&gt;I originally guessed that comments and docstrings are removed in a first pass by the CPython compiler, but then that beggars the question of how &lt;code&gt;help()&lt;/code&gt; is able to render the relevant docstrings. &lt;/p&gt;</Body>
<Tags>python,grammar,python-internals</Tags>
</question>
<answer>
<Body>&lt;h2&gt;Section 1&lt;/h2&gt;&lt;h3&gt;What happens to comments?&lt;/h3&gt;&lt;p&gt;Comments (anything preceded by a &lt;code&gt;#&lt;/code&gt;) are ignored during tokenization/lexical analysis, so there is no need to write rules to parse them. They do not provide any semantic information to the interpreter/compiler, since they only serve to improve the verbosity of your program for the reader&#x27;s sake, and so they are ignored.&lt;/p&gt;&lt;p&gt;Here&#x27;s the lex specification for the ANSI C programming language: &lt;a href=&quot;http://www.quut.com/c/ANSI-C-grammar-l-1998.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://www.quut.com/c/ANSI-C-grammar-l-1998.html&lt;/a&gt;. I&#x27;d like to draw your attention to the way comments are being processed here:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&quot;/*&quot;            { comment(); }&quot;//&quot;[^\n]*      { /* consume //-comment */ }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, take a look at the rule for &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&quot;int&quot;           { count(); return(INT); }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here&#x27;s the lex function to process &lt;code&gt;int&lt;/code&gt; and other tokens:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void count(void){    int i;    for (i = 0; yytext[i] != &#x27;\0&#x27;; i++)        if (yytext[i] == &#x27;\n&#x27;)            column = 0;        else if (yytext[i] == &#x27;\t&#x27;)            column += 8 - (column % 8);        else            column++;    ECHO;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You see here it ends with the &lt;code&gt;ECHO&lt;/code&gt; statement, meaning it is a valid token and must be parsed.&lt;/p&gt;&lt;p&gt;Now, here&#x27;s the lex function to process comments:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void comment(void){    char c, prev = 0;    while ((c = input()) != 0)      /* (EOF maps to 0) */    {        if (c == &#x27;/&#x27; &amp;amp;&amp;amp; prev == &#x27;*&#x27;)            return;        prev = c;    }    error(&quot;unterminated comment&quot;);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There&#x27;s no &lt;code&gt;ECHO&lt;/code&gt; here. So, nothing is returned.&lt;/p&gt;&lt;p&gt;This is a representative example, but python does the exact same thing.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Section 2&lt;/h2&gt;&lt;h3&gt;What happens to docstrings?&lt;/h3&gt;&lt;p&gt;Note: This section of my answer is meant to be a complement to @MartijnPieters&#x27; answer. It is not meant to replicate any of the information he has furnished in his post. Now, with that said,... &lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;&lt;em&gt;I originally guessed that comments and docstrings are removed in a  first pass by the CPython compiler[...]&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Docstrings (string literals that are not assigned to any variable name, anything within &lt;code&gt;&#x27;...&#x27;&lt;/code&gt;, &lt;code&gt;&quot;...&quot;&lt;/code&gt;, &lt;code&gt;&#x27;&#x27;&#x27;...&#x27;&#x27;&#x27;&lt;/code&gt;, or &lt;code&gt;&quot;&quot;&quot;...&quot;&quot;&quot;&lt;/code&gt;) are indeed processed. They are parsed as simple string literals (&lt;code&gt;STRING+&lt;/code&gt; token), as  Martijn Pieters mentions in &lt;a href=&quot;https://stackoverflow.com/a/44717667/4909087&quot;&gt;his answer&lt;/a&gt;. As of the current docs, it is only mentioned in passing that docstrings are assigned to the function/class/module&#x27;s &lt;code&gt;__doc__&lt;/code&gt; attribute. How it is done is not really mentioned in depth anywhere. &lt;/p&gt;&lt;p&gt;What actually happens is that they are tokenised and parsed as string literals and the resultant parse tree generated will contain them. From the parse tree the byte code is generated, with the docstrings in their rightful place in the &lt;code&gt;__doc__&lt;/code&gt; attribute (they are not explicitly a part of the byte code as illustrated below). I won&#x27;t go into details since the answer I linked above describes the same in very nice detail.&lt;/p&gt;&lt;p&gt;Of course, it is possible to ignore them completely. If you use &lt;code&gt;python -OO&lt;/code&gt; (the &lt;code&gt;-OO&lt;/code&gt; flag stands for &quot;optimize intensely&quot;, as opposed to &lt;code&gt;-O&lt;/code&gt; which stands for &quot;optimize mildly&quot;), with the resultant byte code stored in &lt;code&gt;.pyo&lt;/code&gt; files, which exclude the docstrings. &lt;/p&gt;&lt;p&gt;An illustration can be seen below:&lt;/p&gt;&lt;p&gt;Create a file &lt;code&gt;test.py&lt;/code&gt; with the following code:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def foo():    &quot;&quot;&quot; docstring &quot;&quot;&quot;    pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, we&#x27;ll compile this code with the normal flags set.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; code = compile(open(&#x27;test.py&#x27;).read(), &#x27;&#x27;, &#x27;single&#x27;)&amp;gt;&amp;gt;&amp;gt; import dis&amp;gt;&amp;gt;&amp;gt; dis.dis(code)  1           0 LOAD_CONST               0 (&amp;lt;code object foo at 0x102b20ed0, file &quot;&quot;, line 1&amp;gt;)              2 LOAD_CONST               1 (&#x27;foo&#x27;)              4 MAKE_FUNCTION            0              6 STORE_NAME               0 (foo)              8 LOAD_CONST               2 (None)             10 RETURN_VALUE&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, there is no mention of our docstring in the byte code. However, they &lt;em&gt;are&lt;/em&gt; there. To get the docstring, you can do...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; code.co_consts[0].co_consts(&#x27; docstring &#x27;, None)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, as you can see, the docstring &lt;em&gt;does&lt;/em&gt; remain, just not as a part of the main bytecode. Now, let&#x27;s recompile this code, but with the optimisation level set to 2 (equivalent of the &lt;code&gt;-OO&lt;/code&gt; switch):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; code = compile(open(&#x27;test.py&#x27;).read(), &#x27;&#x27;, &#x27;single&#x27;, optimize=2)&amp;gt;&amp;gt;&amp;gt; dis.dis(code)  1           0 LOAD_CONST               0 (&amp;lt;code object foo at 0x102a95810, file &quot;&quot;, line 1&amp;gt;)              2 LOAD_CONST               1 (&#x27;foo&#x27;)              4 MAKE_FUNCTION            0              6 STORE_NAME               0 (foo)              8 LOAD_CONST               2 (None)             10 RETURN_VALUE&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;No, difference, but...&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; code.co_consts[0].co_consts(None,)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The docstrings have gone now. &lt;/p&gt;&lt;p&gt;The &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-OO&lt;/code&gt; flag only remove things (optimisation of byte code is done by default... &lt;code&gt;-O&lt;/code&gt; removes assert statements and &lt;code&gt;if __debug__:&lt;/code&gt; suites from the generated bytecode, while &lt;code&gt;-OO&lt;/code&gt; ignores docstrings in addition). The resultant compile time will decrease slightly. In addition, the speed of execution remains the same, unless you have a large amount of &lt;code&gt;assert&lt;/code&gt; and &lt;code&gt;if __debug__:&lt;/code&gt; statements, otherwise making no difference to performance.&lt;/p&gt;&lt;p&gt;Also, do remember that the docstrings are preserved only if they are the first thing in the function/class/module definition. All additional strings are simply dropped during compilation. If you change &lt;code&gt;test.py&lt;/code&gt; to the following:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def foo():    &quot;&quot;&quot; docstring &quot;&quot;&quot;    &quot;&quot;&quot;test&quot;&quot;&quot;    pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then repeat the same process with &lt;code&gt;optimization=0&lt;/code&gt;, this is is stored in the &lt;code&gt;co_consts&lt;/code&gt; variable upon compilation:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; code.co_consts[0].co_consts(&#x27; docstring &#x27;, None)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Meaning, &lt;code&gt;&quot;&quot;&quot; test &quot;&quot;&quot;&lt;/code&gt; has been ignored. It&#x27;ll interest you to know that this removal is done as part of the base optimisation on the byte code.&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;Section 3&lt;/h2&gt;&lt;h3&gt;Additional reading&lt;/h3&gt;&lt;p&gt;(You may find these references as interesting as I did.)&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4777113/what-does-python-optimization-o-or-pythonoptimize-do&quot;&gt;What does Python optimization (-O or PYTHONOPTIMIZE) do?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8822335/what-do-the-python-file-extensions-pyc-pyd-pyo-stand-for&quot;&gt;What do the python file extensions, .pyc .pyd .pyo stand for?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1983177/are-python-docstrings-and-comments-stored-in-memory-when-a-module-is-loaded&quot;&gt;Are Python docstrings and comments stored in memory when a module is loaded?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.programiz.com/python-programming/methods/built-in/compile&quot; rel=&quot;nofollow noreferrer&quot;&gt;Working with compile()&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The &lt;a href=&quot;https://docs.python.org/2/library/dis.html&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;dis&lt;/code&gt;&lt;/a&gt; module&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/python/cpython/blob/v3.6.1/Python/peephole.c&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;peephole.c&lt;/code&gt;&lt;/a&gt; (courtesy Martijn) - The source code for all compiler optimisations. This is particularly fascinating, if you can understand it!&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;A docstring is not a separate grammar entity. It is just a regular &lt;code&gt;simple_stmt&lt;/code&gt; (following that rule down all the way to &lt;code&gt;atom&lt;/code&gt; and &lt;code&gt;STRING+&lt;/code&gt; &lt;sup&gt;*&lt;/sup&gt;. If it is the &lt;em&gt;first&lt;/em&gt; statement in a function body, class or module, then it &lt;em&gt;used&lt;/em&gt; as the docstring by the compiler.&lt;/p&gt;&lt;p&gt;This is documented in the reference documentation as footnotes to the &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#id8&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#id7&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;def&lt;/code&gt;&lt;/a&gt; compound statements:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;[3] A string literal appearing as the first statement in the function body is transformed into the function’s &lt;code&gt;__doc__&lt;/code&gt; attribute and therefore the function’s docstring.&lt;/p&gt;    &lt;p&gt;[4] A string literal appearing as the first statement in the class body is transformed into the namespace’s &lt;code&gt;__doc__&lt;/code&gt; item and therefore the class’s docstring.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;There currently is no reference documentation that specifies the same for modules, I regard this as a documentation bug.&lt;/p&gt;&lt;p&gt;Comments are removed by the tokenizer and never need to be parsed as grammar. Their whole &lt;em&gt;point&lt;/em&gt; is to not have meaning on a grammar level. See the &lt;a href=&quot;https://docs.python.org/3/reference/lexical_analysis.html#comments&quot; rel=&quot;noreferrer&quot;&gt;&lt;em&gt;Comments&lt;/em&gt; section&lt;/a&gt; of the Lexical Analysis documentation:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;A comment starts with a hash character (#) that is not part of a string literal, and ends at the end of the physical line. A comment signifies the end of the logical line unless the implicit line joining rules are invoked. &lt;strong&gt;Comments are ignored by the syntax; they are not tokens&lt;/strong&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Bold emphasis mine. So the &lt;a href=&quot;https://github.com/python/cpython/blob/v3.6.1/Parser/tokenizer.c#L1496-L1501&quot; rel=&quot;noreferrer&quot;&gt;tokenizer&lt;/a&gt; skips comments altogether:&lt;/p&gt;&lt;pre class=&quot;lang-c prettyprint-override&quot;&gt;&lt;code&gt;/* Skip comment */if (c == &#x27;#&#x27;) {    while (c != EOF &amp;amp;&amp;amp; c != &#x27;\n&#x27;) {        c = tok_nextc(tok);    }}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that Python source code goes through 3 steps:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Tokenizing&lt;/li&gt;&lt;li&gt;Parsing&lt;/li&gt;&lt;li&gt;Compilation&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;The grammar only applies to the parsing stage; comments are dropped in the tokenizer, and docstrings are only special to the compiler.&lt;/p&gt;&lt;p&gt;To illustrate how the parser doesn&#x27;t treat docstrings as anything other than a string literal expression, you can access any Python parse results as an &lt;em&gt;Abstract Syntax Tree&lt;/em&gt;, via the &lt;a href=&quot;https://docs.python.org/3/library/ast.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;ast&lt;/code&gt; module&lt;/a&gt;. This produces Python objects that &lt;em&gt;directly&lt;/em&gt; reflect the parse tree that the Python grammar parser produces, from which Python bytecode is then compiled:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import ast&amp;gt;&amp;gt;&amp;gt; function = &#x27;def foo():\n    &quot;docstring&quot;\n&#x27;&amp;gt;&amp;gt;&amp;gt; parse_tree = ast.parse(function)&amp;gt;&amp;gt;&amp;gt; ast.dump(parse_tree)&quot;Module(body=[FunctionDef(name=&#x27;foo&#x27;, args=arguments(args=[], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s=&#x27;docstring&#x27;))], decorator_list=[], returns=None)])&quot;&amp;gt;&amp;gt;&amp;gt; parse_tree.body[0]&amp;lt;_ast.FunctionDef object at 0x107b96ba8&amp;gt;&amp;gt;&amp;gt;&amp;gt; parse_tree.body[0].body[0]&amp;lt;_ast.Expr object at 0x107b16a20&amp;gt;&amp;gt;&amp;gt;&amp;gt; parse_tree.body[0].body[0].value&amp;lt;_ast.Str object at 0x107bb3ef0&amp;gt;&amp;gt;&amp;gt;&amp;gt; parse_tree.body[0].body[0].value.s&#x27;docstring&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So you have &lt;code&gt;FunctionDef&lt;/code&gt; object, which has, as the first element in the body, an expression that is a &lt;code&gt;Str&lt;/code&gt; with value &lt;code&gt;&#x27;docstring&#x27;&lt;/code&gt;. It is the &lt;em&gt;compiler&lt;/em&gt; that then generates a code object, storing that docstring in a separate attribute.&lt;/p&gt;&lt;p&gt;You can compile the AST into bytecode with the &lt;a href=&quot;https://docs.python.org/3/library/functions.html#compile&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;compile()&lt;/code&gt; function&lt;/a&gt;; again, this is using the actual codepaths the Python interpreter uses. We&#x27;ll use the &lt;a href=&quot;https://docs.python.org/3/library/dis.html&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;dis&lt;/code&gt; module&lt;/a&gt; to decompile the bytecode for us:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; codeobj = compile(parse_tree, &#x27;&#x27;, &#x27;exec&#x27;)&amp;gt;&amp;gt;&amp;gt; import dis&amp;gt;&amp;gt;&amp;gt; dis.dis(codeobj)  1           0 LOAD_CONST               0 (&amp;lt;code object foo at 0x107ac9d20, file &quot;&quot;, line 1&amp;gt;)              2 LOAD_CONST               1 (&#x27;foo&#x27;)              4 MAKE_FUNCTION            0              6 STORE_NAME               0 (foo)              8 LOAD_CONST               2 (None)             10 RETURN_VALUE&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So the compiled code produced the top-level statements for a module. The &lt;a href=&quot;https://docs.python.org/3/library/dis.html#opcode-MAKE_FUNCTION&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;MAKE_FUNCTION&lt;/code&gt; opcode&lt;/a&gt; uses a stored codeobject (part of the top-level code object constants) to build a function. So we look at that nested code object, at index 0:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dis.dis(codeobj.co_consts[0])  1           0 LOAD_CONST               1 (None)              2 RETURN_VALUE&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here the docstring appears to be &lt;em&gt;gone&lt;/em&gt;. The function does nothing more than return &lt;code&gt;None&lt;/code&gt;. The docstring is instead stored as a constant:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; codeobj.co_consts[0].co_consts(&#x27;docstring&#x27;, None)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When executing the &lt;code&gt;MAKE_FUNCTION&lt;/code&gt; opcode, it is that first constant, provided it is a string, that is turned into the &lt;code&gt;__doc__&lt;/code&gt; attribute for the function object.&lt;/p&gt;&lt;p&gt;Once compiled, we can execute the code object with the &lt;a href=&quot;https://docs.python.org/3/library/functions.html#exec&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;exec()&lt;/code&gt; function&lt;/a&gt; into a given namespace, which adds a function object with a docstring:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; namespace = {}&amp;gt;&amp;gt;&amp;gt; exec(codeobj, namespace)&amp;gt;&amp;gt;&amp;gt; namespace[&#x27;foo&#x27;]&amp;lt;function foo at 0x107c23e18&amp;gt;&amp;gt;&amp;gt;&amp;gt; namespace[&#x27;foo&#x27;].__doc__&#x27;docstring&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So it&#x27;s the job of the compiler to determine when something is a docstring. This is done in C code, in the &lt;a href=&quot;https://github.com/python/cpython/blob/v3.6.1/Python/compile.c#L1323-L1333&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;compiler_isdocstring()&lt;/code&gt; function&lt;/a&gt;:&lt;/p&gt;&lt;pre class=&quot;lang-c prettyprint-override&quot;&gt;&lt;code&gt;static intcompiler_isdocstring(stmt_ty s){    if (s-&amp;gt;kind != Expr_kind)        return 0;    if (s-&amp;gt;v.Expr.value-&amp;gt;kind == Str_kind)        return 1;    if (s-&amp;gt;v.Expr.value-&amp;gt;kind == Constant_kind)        return PyUnicode_CheckExact(s-&amp;gt;v.Expr.value-&amp;gt;v.Constant.value);    return 0;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is called from locations where a docstring makes sense; for modules and classes, in &lt;a href=&quot;https://github.com/python/cpython/blob/v3.6.1/Python/compile.c#L1433-L1465&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;compiler_body()&lt;/code&gt;&lt;/a&gt;, and for functions, in &lt;a href=&quot;https://github.com/python/cpython/blob/v3.6.1/Python/compile.c#L1807-L1906&quot; rel=&quot;noreferrer&quot;&gt;&lt;code&gt;compiler_function()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;TLDR&lt;/strong&gt;: comments are not part of the grammar, because the grammar parser never even sees comments. They are skipped by the tokenizer. Docstrings are not part of the grammar, because to the grammar parser they are just string literals. It is the compilation step (taking the parse tree output of the parser) that interprets those string expressions as docstrings.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;sup&gt;*&lt;/sup&gt; The full grammar rule path is &lt;code&gt;simple_stmt&lt;/code&gt; -&gt; &lt;code&gt;small_stmt&lt;/code&gt; -&gt; &lt;code&gt;expr_stmt&lt;/code&gt; -&gt; &lt;code&gt;testlist_star_expr&lt;/code&gt; -&gt; &lt;code&gt;star_expr&lt;/code&gt; -&gt; &lt;code&gt;expr&lt;/code&gt; -&gt; &lt;code&gt;xor_expr&lt;/code&gt; -&gt; &lt;code&gt;and_expr&lt;/code&gt; -&gt; &lt;code&gt;shift_expr&lt;/code&gt; -&gt; &lt;code&gt;arith_expr&lt;/code&gt; -&gt; &lt;code&gt;term&lt;/code&gt; -&gt; &lt;code&gt;factor&lt;/code&gt; -&gt; &lt;code&gt;power&lt;/code&gt; -&gt; &lt;code&gt;atom_expr&lt;/code&gt; -&gt; &lt;code&gt;atom&lt;/code&gt; -&gt; &lt;code&gt;STRING+&lt;/code&gt;&lt;/p&gt;</Body>
</answer>
</qroot>
