<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Bilinear Interpolation - OSRM Rastersource</Title>
<Body>&lt;p&gt;I&#x27;ve got a question about bilinear interpolation in the OSRM-Project.I understand the &quot;normal&quot; bilinear interpolation. Here the picture from Wikipedia, what is insane:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/rMed9.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/rMed9.png&quot; alt=&quot;Bilinear Interpolation - Wikipedia&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Now I&#x27;m trying to understand the bilinear interpolation which is used in the OSRM-Project for raster source data.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// Query raster source using bilinear interpolationRasterDatum RasterSource::GetRasterInterpolate(const int lon, const int lat) const{if (lon &amp;lt; xmin || lon &amp;gt; xmax || lat &amp;lt; ymin || lat &amp;gt; ymax){    return {};}const auto xthP = (lon - xmin) / xstep;const auto ythP =    (ymax - lat) /    ystep; // the raster texture uses a different coordinate system with y pointing downwardsconst std::size_t top = static_cast&amp;lt;std::size_t&amp;gt;(fmax(floor(ythP), 0));const std::size_t bottom = static_cast&amp;lt;std::size_t&amp;gt;(fmin(ceil(ythP), height - 1));const std::size_t left = static_cast&amp;lt;std::size_t&amp;gt;(fmax(floor(xthP), 0));const std::size_t right = static_cast&amp;lt;std::size_t&amp;gt;(fmin(ceil(xthP), width - 1));// Calculate distances from corners for bilinear interpolationconst float fromLeft = xthP - left; // this is the fraction part of xthPconst float fromTop = ythP - top;   // this is the fraction part of ythPconst float fromRight = 1 - fromLeft;const float fromBottom = 1 - fromTop;return {static_cast&amp;lt;std::int32_t&amp;gt;(raster_data(left, top) * (fromRight * fromBottom) +                                  raster_data(right, top) * (fromLeft * fromBottom) +                                  raster_data(left, bottom) * (fromRight * fromTop) +                                  raster_data(right, bottom) * (fromLeft * fromTop))};}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Project-OSRM/osrm-backend/blob/e413b25cd9e9cf5430ec1e50ab5f319244aa84ad/src/extractor/raster_source.cpp#L51-L79&quot; rel=&quot;nofollow noreferrer&quot;&gt;Original Code here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Can someone explain me how the code works?&lt;/p&gt;&lt;p&gt;The input format are the &lt;em&gt;SRTM&lt;/em&gt; data in ASCII format.&lt;/p&gt;&lt;p&gt;The variables &lt;em&gt;height&lt;/em&gt; and &lt;em&gt;width&lt;/em&gt; are defined as &lt;em&gt;nrows&lt;/em&gt; and &lt;em&gt;ncolumns&lt;/em&gt;.The variables &lt;em&gt;xstep&lt;/em&gt; and &lt;em&gt;ystep&lt;/em&gt; are defined as:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;return (max - min) / (static_cast&amp;lt;float&amp;gt;(count) - 1)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where &lt;em&gt;count&lt;/em&gt; is &lt;em&gt;height&lt;/em&gt; for &lt;em&gt;ystep&lt;/em&gt; and &lt;em&gt;width&lt;/em&gt; for &lt;em&gt;xstep&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt; and &lt;em&gt;min&lt;/em&gt; similar.&lt;/p&gt;&lt;p&gt;And another question:Can I use the same code for data in &lt;em&gt;TIF-format&lt;/em&gt; and the whole world?&lt;/p&gt;</Body>
<Tags>c++,raster,osrm,bilinear-interpolation</Tags>
</question>
<answer>
<Body>&lt;p&gt;Horizontal pixel coordinates are in the range &lt;code&gt;[0, width - 1]&lt;/code&gt;; similarly vertical coordinates are in &lt;code&gt;[0, height - 1]&lt;/code&gt;. (Zero-indexing convention used in many many languages including C++)&lt;/p&gt;&lt;p&gt;The lines&lt;/p&gt;&lt;p&gt;&lt;code&gt;const auto xthP = (lon - xmin) / xstep;&lt;/code&gt; (and for &lt;code&gt;ythP&lt;/code&gt;)&lt;/p&gt;&lt;p&gt;Convert the input &lt;em&gt;image-space&lt;/em&gt; coordinates &lt;code&gt;(long, lat)&lt;/code&gt; into &lt;em&gt;pixel coordinates&lt;/em&gt;. &lt;code&gt;xstep&lt;/code&gt; is the width of each pixel in &lt;em&gt;image-space&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Rounding this down (using &lt;code&gt;floor&lt;/code&gt;) gives pixels intersected by the sample area on one side, and rounding up (&lt;code&gt;ceil&lt;/code&gt;) gives the pixels on the other side. For the X-coordinate these give &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The reason for using &lt;code&gt;fmin&lt;/code&gt; and &lt;code&gt;fmax&lt;/code&gt; are to &lt;em&gt;clamp&lt;/em&gt; the coordinates so that they don&#x27;t exceed the pixel coordinate range.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;EDIT: since you are trying to interpret this picture, I&#x27;ll list the corresponding parts below:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Q11&lt;/code&gt; = &lt;code&gt;(left, top)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Q12&lt;/code&gt; - &lt;code&gt;(left, bottom)&lt;/code&gt;, etc.&lt;/li&gt;&lt;li&gt;&lt;code&gt;P&lt;/code&gt; = &lt;code&gt;(xthP, ythP)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;R1&lt;/code&gt; = &lt;code&gt;fromTop&lt;/code&gt;, &lt;code&gt;R2&lt;/code&gt; = &lt;code&gt;fromBottom&lt;/code&gt; etc.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;A good start point would be &lt;a href=&quot;http://www.cs.uu.nl/docs/vakken/gr/2011/Slides/06-texturing.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://www.cs.uu.nl/docs/vakken/gr/2011/Slides/06-texturing.pdf&lt;/a&gt;, slide 27. In future though, Google is your friend.&lt;/p&gt;</Body>
</answer>
</qroot>
