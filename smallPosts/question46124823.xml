<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Pickling dynamically created types</Title>
<Body>&lt;p&gt;I&#x27;ve been trying to get some dynamically created types (i.e. ones created by calling 3-arg &lt;code&gt;type()&lt;/code&gt;) to pickle and unpickle nicely. I&#x27;ve been using &lt;a href=&quot;https://stackoverflow.com/a/7668273/168175&quot;&gt;this module switching trick&lt;/a&gt; to hide the details from users of the module and give clean semantics.&lt;/p&gt;&lt;p&gt;I&#x27;ve learned several things already:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The type must be findable with &lt;code&gt;getattr&lt;/code&gt; on the module itself&lt;/li&gt;&lt;li&gt;The type must be consistent with what &lt;code&gt;getattr&lt;/code&gt; finds, that is to say if we call &lt;code&gt;pickle.dumps(o)&lt;/code&gt; then it must be true that &lt;code&gt;type(o) == getattr(module, &#x27;name of type&#x27;)&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Where I&#x27;m stuck though is that there still seems to be something odd going on - it seems to be calling &lt;code&gt;__getstate__&lt;/code&gt; on something unexpected. &lt;/p&gt;&lt;p&gt;Here&#x27;s the simplest setup I&#x27;ve got that reproduces the issue, testing with Python 3.5, but I&#x27;d like to target back to 3.3 if possible:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# module.pyimport sysimport functoolsdef dump(self):    return b&#x27;Some data&#x27; # Dummy for testingdef undump(self, data):    print(&#x27;Undump: %r&#x27; % data) # Do nothing for testing# Cheaty demo way to make this consistent@functools.lru_cache(maxsize=None)def make_type(name):    return type(name, (), {        &#x27;__getstate__&#x27;: dump,        &#x27;__setstate__&#x27;: undump,    })class Magic(object):    def __init__(self, path):        self.path = path    def __getattr__(self, name):        print(&#x27;Getting thing: %s (from: %s)&#x27; % (name, self.path))        # for simple testing all calls to make_type must end in last x.y.z.last        if name != &#x27;last&#x27;:            if self.path:                return Magic(self.path + &#x27;.&#x27; + name)            else:                return Magic(name)        return make_type(self.path + &#x27;.&#x27; + name)# Make the switchsys.modules[__name__] = Magic(&#x27;&#x27;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And then a quick way to exercise that:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import moduleimport picklef=module.foo.bar.woof.last()print(f.__getstate__()) # See, *this* worksprint(&#x27;Pickle starts here&#x27;)print(pickle.dumps(f))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Which then gives:&lt;/p&gt;&lt;pre class=&quot;lang-none prettyprint-override&quot;&gt;&lt;code&gt;Getting thing: foo (from: )Getting thing: bar (from: foo)Getting thing: woof (from: foo.bar)Getting thing: last (from: foo.bar.woof)b&#x27;Some data&#x27;Pickle starts hereGetting thing: __spec__ (from: )Getting thing: _initializing (from: __spec__)Getting thing: foo (from: )Getting thing: bar (from: foo)Getting thing: woof (from: foo.bar)Getting thing: last (from: foo.bar.woof)Getting thing: __getstate__ (from: foo.bar.woof)Traceback (most recent call last):  File &quot;test.py&quot;, line 7, in &amp;lt;module&amp;gt;    print(pickle.dumps(f))TypeError: &#x27;Magic&#x27; object is not callable&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I wasn&#x27;t expecting to see anything looking up &lt;code&gt;__getstate__&lt;/code&gt; on &lt;code&gt;module.foo.bar.woof&lt;/code&gt;, but even if we force that lookup to fail by adding:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if name == &#x27;__getstate__&#x27;: raise AttributeError()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;into our &lt;code&gt;__getattr__&lt;/code&gt; it still fails with:&lt;/p&gt;&lt;pre class=&quot;lang-none prettyprint-override&quot;&gt;&lt;code&gt;Traceback (most recent call last):  File &quot;test.py&quot;, line 7, in &amp;lt;module&amp;gt;    print(pickle.dumps(f))_pickle.PicklingError: Can&#x27;t pickle &amp;lt;class &#x27;module.Magic&#x27;&amp;gt;: it&#x27;s not the same object as module.Magic&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What gives? Am I missing something with &lt;code&gt;__spec__&lt;/code&gt;? The &lt;a href=&quot;https://docs.python.org/3/reference/import.html#__spec__&quot; rel=&quot;nofollow noreferrer&quot;&gt;docs for &lt;code&gt;__spec__&lt;/code&gt;&lt;/a&gt; pretty much just stress setting it appropriately, but don&#x27;t seem to actually explain much.&lt;/p&gt;&lt;p&gt;More importantly the bigger question is how am I supposed to go about making types I programatically generated via a pseudo module&#x27;s &lt;code&gt;__getattr__&lt;/code&gt; implementation pickle properly?&lt;/p&gt;&lt;p&gt;(And obviously once I&#x27;ve managed to get &lt;code&gt;pickle.dumps&lt;/code&gt; to produce something I expect &lt;code&gt;pickle.loads&lt;/code&gt; to call &lt;code&gt;undump&lt;/code&gt; with the same thing)&lt;/p&gt;</Body>
<Tags>python,pickle</Tags>
</question>
<answer>
<Body>&lt;p&gt;To pickle &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pickle&lt;/code&gt; needs to pickle &lt;code&gt;f&lt;/code&gt;&#x27;s class, &lt;code&gt;module.foo.bar.woof.last&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;The docs don&#x27;t claim support for pickling arbitrary classes. &lt;a href=&quot;https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled&quot; rel=&quot;nofollow noreferrer&quot;&gt;They claim the following&lt;/a&gt;:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;The following types can be pickled:&lt;/p&gt;    &lt;ul&gt;  &lt;li&gt;...&lt;/li&gt;  &lt;li&gt;classes that are defined at the top level of a module&lt;/li&gt;  &lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;module.foo.bar.woof.last&lt;/code&gt; isn&#x27;t defined at the top level of a module, even a pretend module like &lt;code&gt;module&lt;/code&gt;. In this not-officially-supported case, the pickle logic ends up trying to pickle &lt;code&gt;module.foo.bar.woof&lt;/code&gt;, either &lt;a href=&quot;https://github.com/python/cpython/blob/3410c01d83d70ceef48b735c247aebd2d5bd3411/Lib/pickle.py#L948-L949&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    elif parent is not module:        self.save_reduce(getattr, (parent, lastname))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;or &lt;a href=&quot;https://github.com/python/cpython/blob/2ebc5ce42a8a9e047e790aefbf9a94811569b2b6/Modules/_pickle.c#L3279&quot; rel=&quot;nofollow noreferrer&quot;&gt;here&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    else if (parent != module) {        PickleState *st = _Pickle_GetGlobalState();        PyObject *reduce_value = Py_BuildValue(&quot;(O(OO))&quot;,                                    st-&amp;gt;getattr, parent, lastname);        status = save_reduce(self, reduce_value, NULL);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;module.foo.bar.woof&lt;/code&gt; can&#x27;t be pickled for multiple reasons. It returns a non-callable &lt;code&gt;Magic&lt;/code&gt; instance for all unsupported method lookups, like &lt;code&gt;__getstate__&lt;/code&gt;, which is where your first error comes from. The module-switching thing prevents finding the &lt;code&gt;Magic&lt;/code&gt; class to pickle it, which is where your second error comes from. There are probably more incompatibilities.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;As it seems, and is already proven that making the class &lt;code&gt;callable&lt;/code&gt; is just a drifting out another wrong direction, thankfully to &lt;a href=&quot;https://stackoverflow.com/a/8512365/4571206&quot;&gt;this hack&lt;/a&gt;, I could find a getaround to make the class reiterable by its TYPE. following the context of the error &lt;code&gt;&amp;lt;class &#x27;module.Magic&#x27;&amp;gt;: it&#x27;s not the same object as module.Magic&lt;/code&gt; the pickler doesn&#x27;t iterate through the same call that renders a different type from the other one, this is a major common problem with pickling self instanciating classes, for this instance, an object by its class, there for the solution is patching the class with its type &lt;code&gt;@mock.patch(&#x27;module.Magic&#x27;, type(module.Magic))&lt;/code&gt; this is a short answer for a something.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;com.stackoverflow.Main.py&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import moduleimport pickleimport mockf=module1.foo.bar.woof.lastprint(f().__getstate__()) # See, *this* worksprint(&#x27;Pickle starts here&#x27;)@mock.patch(&#x27;module1.Magic&#x27;, type(module1.Magic))def pickleit():    return pickle.dumps(f())print(pickleit())&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Magic class&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Magic(object):    def __init__(self, value):        self.path = value    __class__: lambda x:x    def __getstate__(self):        print (&quot;Shoot me! i&#x27;m at &quot; +  self.path )        return dump(self)   def __setstate__(self,value):        print (&#x27;something will never occur&#x27;)        return undump(self,value)    def __spec__(self):        print (&quot;Wrong side of the planet &quot;)    def _initializing(self):        print (&quot;Even farther lost &quot;)     def __getattr__(self, name):        print(&#x27;Getting thing: %s (from: %s)&#x27; % (name, self.path))        # for simple testing all calls to make_type must end in last x.y.z.last        if name != &#x27;last&#x27;:            if self.path:                return Magic(self.path + &#x27;.&#x27; + name)            else:                return Magic(name)        print(&#x27;terminal stage&#x27; )        return make_type(self.path + &#x27;.&#x27; + name)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Even assuming this is not more of striking the ball by the edge of the bat, I could see the content dumped into my console.&lt;/p&gt;</Body>
</answer>
</qroot>
