<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Why does shifting 0xff left by 24 bits result in an incorrect value?</Title>
<Body>&lt;p&gt;I would like to shift &lt;code&gt;0xff&lt;/code&gt; left by 3 bytes and store it in a &lt;code&gt;uint64_t&lt;/code&gt;, which should work as such:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;uint64_t temp = 0xff &amp;lt;&amp;lt; 24;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This yields a value of &lt;code&gt;0xffffffffff000000&lt;/code&gt; which is most definitely not the expected &lt;code&gt;0xff000000&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;However, if I shift it by fewer than 3 bytes, it results in the correct answer.&lt;/p&gt;&lt;p&gt;Furthermore, trying to shift 0x01 left by 3 bytes does work.&lt;/p&gt;&lt;p&gt;Here&#x27;s my output:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;0xff shifted by 0 bytes: 0xff0x01 shifted by 0 bytes: 0x10xff shifted by 1 bytes: 0xff000x01 shifted by 1 bytes: 0x1000xff shifted by 2 bytes: 0xff00000x01 shifted by 2 bytes: 0x100000xff shifted by 3 bytes: 0xffffffffff0000000x01 shifted by 3 bytes: 0x1000000&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With some experimentation, left shifting works up to 3 bits for each uint64_t up to 0x7f, which yields 0x7f000000. 0x80 yields 0xffffffff80000000.&lt;/p&gt;&lt;p&gt;Does anyone have an explanation for this bizarre behavior? 0xff000000 certainly falls within the 2&lt;sup&gt;64&lt;/sup&gt; - 1 limits of uint64_t.  &lt;/p&gt;</Body>
<Tags>c++,bit-manipulation,bit-shift</Tags>
</question>
<answer>
<Body>&lt;p&gt;Shifting left creates a negative (32 bit) number which then gets filled to 64 bits.&lt;/p&gt;&lt;p&gt;Try &lt;/p&gt;&lt;pre&gt;&lt;code&gt;0xff &amp;lt;&amp;lt; 24LL;&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;Does anyone have an explanation for this bizarre behavior?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Yes, type of operation always depend on operand types and never on result type:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;double r = 1.0 / 2.0;     // double divided by double and result double assigned to r    // r == 0.5double r = 1.0 / 2;     // 2 converted to double, double divided by double and result double assigned to r    // r == 0.5double r = 1 / 2;     // int divided by int, result int converted to double and assigned to r    // r == 0.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When you understand and remenber this you would not fall on this mistake again.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I suspect the behavior is compiler dependent, but I am seeing the same thing.  &lt;/p&gt;&lt;p&gt;The fix is simple.  Be sure to cast the 0xff to a uint64_t type BEFORE performing the shift.  That way the compiler will handle it as the correct type.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;uint64_t temp = uint64_t(0xff) &amp;lt;&amp;lt; 24&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Let&#x27;s break your problem up into two pieces. The first is the shift operation, and the other is the conversion to &lt;code&gt;uint64_t&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;As far as the left shift is concerned, you are invoking undefined behavior on 32-bit (or smaller) architectures. As others have mentioned, the operands are &lt;code&gt;int&lt;/code&gt;. A 32-bit &lt;code&gt;int&lt;/code&gt; with the given value would be &lt;code&gt;0x000000ff&lt;/code&gt;. Note that this is a signed number, so the left-most bit is the sign. According to the standard, if you the shift affects the sign-bit, the result is undefined. It is up to the whims of the implementation, it is subject to change at any point, and it can even be completely optimized away if the compiler recognizes it at compile-time. The latter is not realistic, but it is actually permitted. While you should never rely on code of this form, this is actually not the root of the behavior that puzzled you.&lt;/p&gt;&lt;p&gt;Now, for the second part. The undefined outcome of the left shift operation has to be converted to a &lt;code&gt;uint64_t&lt;/code&gt;. The standard states for signed to unsigned integral conversions:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;If the destination type is unsigned, the resulting value is the smallest unsigned value equal to the source value modulo 2n where n is the number of bits used to represent the destination type.&lt;/p&gt;    &lt;p&gt;That is, depending on whether the destination type is wider or narrower, signed integers are sign-extended[footnote 1] or truncated and unsigned integers are zero-extended or truncated respectively.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;The footnote clarifies that sign-extension is true only for two&#x27;s-complement representation which is used on every platform with a C++ compiler currently.&lt;/p&gt;&lt;p&gt;Sign-extension means just that everything left of the sign bit on the destination variable will be filled with the sign-bit, which produces all the &lt;code&gt;f&lt;/code&gt;s in your result. As you noted, you could left shift &lt;code&gt;0x7f&lt;/code&gt; by 3-bytes without this occurring, That&#x27;s because &lt;code&gt;0x7f=0b01111111&lt;/code&gt;. After the shift, you get &lt;code&gt;0x7f000000&lt;/code&gt; which is the largest signed int, ie the largest number that doesn&#x27;t affect the sign bit. Therefore, in the conversion, a &lt;code&gt;0&lt;/code&gt; was extended.&lt;/p&gt;&lt;p&gt;Converting the left operand to a large enough type solves this.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;uint64_t temp = uint64_t(0xff) &amp;lt;&amp;lt; 24&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
