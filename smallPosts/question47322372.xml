<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Understanding * (zero or more) operator using re.search()</Title>
<Body>&lt;p&gt;I am new to python and was going through &lt;a href=&quot;https://developers.google.com/edu/python/regular-expressions&quot; rel=&quot;nofollow noreferrer&quot;&gt;&quot;Google for Education&quot;&lt;/a&gt; python course&lt;/p&gt;&lt;p&gt;Now, the line below confuses me:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;* -- 0 or more occurrences of the pattern to its left&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;(all the examples are in python3)&lt;/p&gt;&lt;p&gt;e.g. 1 &lt;/p&gt;&lt;pre&gt;&lt;code&gt;In [1]: re.search(r&quot;pi*&quot;, &quot;piiig!!&quot;).group()Out[1]: &#x27;piii&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is fine since, &quot;pi&quot; has 1 occurrance so it is retured&lt;/p&gt;&lt;p&gt;e.g. 2&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In [2]: re.search(r&quot;i*&quot;, &quot;piiig!!&quot;).group()Out[2]: &#x27;&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Why does it not return &quot;i&quot; in fact - from my understanding, it should be returning &quot;iii&quot;. But the result is an empty string.&lt;/p&gt;&lt;p&gt;Also, What exactly does &quot;0 or more&quot; mean? I searched on google but everywhere it is mentioned * -- 0 or more. But if there is 0 occurrence of an expression, does that not become true even if it&#x27;s not there? What is the point of searching then?&lt;/p&gt;&lt;p&gt;I am so confused with this. Can you please help me with explaining this or point me in the right direction.&lt;/p&gt;&lt;p&gt;i hope the right explanation would also resolve my this issue:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In [3]: re.search(r&quot;i?&quot;, &quot;piiig!!&quot;).group()Out[3]: &#x27;&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have tried the examples in &lt;a href=&quot;https://github.com/spyder-ide/spyder&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spyder 3.2.4&lt;/a&gt;&lt;/p&gt;</Body>
<Tags>python,regex,regex-greedy</Tags>
</question>
<answer>
<Body>&lt;p&gt;You need to use *(0 or more) and +(1 or more) properly to get your desired output&lt;/p&gt;&lt;p&gt;Eg: 1 Matches because you have defined * only for &quot;i&quot;, this patter will capture all the &quot;p&quot; or &quot;pi&quot; combination&lt;/p&gt;&lt;p&gt;Eg: 2 If you need to match only &quot;i&quot; you need to use &quot;+&quot; instead of &quot;*&quot;.&lt;/p&gt;&lt;p&gt;If you use &quot;*&quot;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In: re.search(r&quot;pi*g&quot;, &quot;piiig!!&quot;).group()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will return if you input is (&quot;pig&quot; or &quot;piig&quot; or &quot;pg&quot;)&lt;/p&gt;&lt;p&gt;If you use &quot;+&quot;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In: re.search(r&quot;pi+g&quot;, &quot;piiig!!&quot;).group()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will return if you input is (&quot;pig&quot; or &quot;piig&quot;)&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The special charecter &lt;code&gt;*&lt;/code&gt; means 0 or more occurrence of the preceding character. For eg. &lt;code&gt;a*&lt;/code&gt; matches with 0 or more occurrence of a which could be &lt;code&gt;&#x27;&#x27;&lt;/code&gt;, &lt;code&gt;&#x27;a&#x27;&lt;/code&gt;, &lt;code&gt;&#x27;aa&#x27;&lt;/code&gt; etc. This happens because &lt;code&gt;&#x27;&#x27;&lt;/code&gt; has 0 occurrence of &lt;code&gt;a&lt;/code&gt;. To get &lt;code&gt;iii&lt;/code&gt; you should have used &lt;code&gt;+&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; and thus would have got the first non zero  sequence of &lt;code&gt;&#x27;i&#x27;&lt;/code&gt; which is &lt;code&gt;iii&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;re.search(&quot;i+&quot;, &quot;piiig!!&quot;).group()&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Because &lt;code&gt;&#x27;&#x27;&lt;/code&gt; is the first matched result of &lt;code&gt;r&#x27;i*&#x27;&lt;/code&gt; and &lt;code&gt;&#x27;iii&#x27;&lt;/code&gt; is the second matched result.&lt;/p&gt;&lt;pre class=&quot;lang-py prettyprint-override&quot;&gt;&lt;code&gt;In [1]: import reIn [2]: re.findall(r&#x27;i*&#x27;, &#x27;piiig!!&#x27;)Out[2]: [&#x27;&#x27;, &#x27;iii&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This website will also explain the way how regular expression work.&lt;a href=&quot;https://regex101.com/r/XVPXMv/1&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://regex101.com/r/XVPXMv/1&lt;/a&gt;&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The explanation is a bit more complicated than the answers we have seen so far.&lt;/p&gt;&lt;p&gt;First, unlike &lt;code&gt;re.match()&lt;/code&gt; the primitive operation &lt;a href=&quot;https://docs.python.org/3/library/re.html#search-vs-match&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;code&gt;re.search()&lt;/code&gt;&lt;/a&gt; checks for a match anywhere in the string (this is what Perl does by default) and finds the pattern &lt;strong&gt;once&lt;/strong&gt;:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;Scan through string looking for the first location where the regular  expression pattern produces a match, and return a corresponding  MatchObject instance. Return None if no position in the string matches  the pattern; note that this is different from finding a zero-length  match at some point in the string. See: &lt;a href=&quot;https://docs.python.org/2/library/re.html#re.search&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ref&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;If we follow every step of the regex engine while it tries to find a match, we can observe the following for the pattern &lt;code&gt;i*&lt;/code&gt; and the test string &lt;code&gt;piigg!!&lt;/code&gt;:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/mN3IJ.png&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/mN3IJ.png&quot; alt=&quot;RegExBuddy Debug till End Output&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;As you can see, the first character (at position 0) produces a match because &lt;code&gt;p&lt;/code&gt; is zero times &lt;code&gt;i&lt;/code&gt; and the result is an empty match (and not p - because we do not search for p or any other character).&lt;br&gt;At the second character (position 1) the second match (spanning to position 2) is found since &lt;code&gt;ii&lt;/code&gt; is zero or more times &lt;code&gt;i&lt;/code&gt;... at position 3 there is another empty match, and so far and so forth.&lt;/p&gt;&lt;p&gt;Because &lt;code&gt;re.search&lt;/code&gt; only returns the first match it sticks with the first empty match at position 0. That&#x27;s why you get the (confusing) result you have posted:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;In [2]: re.search(r&quot;i*&quot;, &quot;piiig!!&quot;).group()Out[2]: &#x27;&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In order to match every occurrence, you need &lt;code&gt;re.findall()&lt;/code&gt;:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;Return all non-overlapping matches of pattern in string, as a list of  strings. The string is scanned left-to-right, and matches are returned  in the order found. If one or more groups are present in the pattern,  return a list of groups; this will be a list of tuples if the pattern  has more than one group. Empty matches are included in the result  unless they touch the beginning of another match. See: &lt;a href=&quot;http://docs.python.org/2/library/re.html#re.findall&quot; rel=&quot;nofollow noreferrer&quot;&gt;Ref&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;</Body>
</answer>
</qroot>
