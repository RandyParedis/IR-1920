<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>What does “Autoreleased with no pool in place” mean?</Title>
<Body>&lt;p&gt;My Application structure is as follows, the core part is written in C++ and using thread heavily, and i am developing UI in Objective C on top of it, if i don&#x27;t execute the thread it works fine, but i can&#x27;t disable, stop thread, UI is crashing randomly in the log i could see , following message &lt;/p&gt;&lt;pre&gt;&lt;code&gt;__NSAutoreleaseNoPool(): Object 0x350270 of class NSCFString autoreleased with no pool in place - just leaking&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Similar messages coming more then once, by googling come to know, i need to set NSAutoReleasePool to get rid of it, but how its possible to integrate the same with C++ code. &lt;/p&gt;&lt;p&gt;&lt;strong&gt;Edit:&lt;/strong&gt; Core lib will be activated from UI , hence i suppose, its safe to say UI is running in the main thread, Lib is creating/terminating thread without notifying UI, in this case, can i call AutoReleasePool in the UI &lt;/p&gt;&lt;p&gt;Can anyone guide me?&lt;/p&gt;</Body>
<Tags>multithreading,cocoa,debugging,objective-c++</Tags>
</question>
<answer>
<Body>&lt;p&gt;See these docs for what you should know about multithreading with Cocoa: &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html&quot; rel=&quot;noreferrer&quot;&gt;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;It&#x27;s OK to design your app like you have, but two things should be kept in mind:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Life is simplest (and sometimes necessary) when UI controls like views (AppKit or UIKit) are manipulated on the main thread. You can use Foundation objects and some AppKit/UIKit objects on background threads, and some Foundation objects can be used from multiple threads.&lt;/li&gt;&lt;li&gt;If you&#x27;re using any Cocoa objects at all in background threads, you&#x27;ll need to set up autorelease pools on those threads. &lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Like so:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;- (void)backgroundThreadStart {    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];    // do stuff    [pool release];}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That will fix your console errors, but you might have other issues that led to the actual crashing you were seeing. &lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;It means you autoreleased something without an autorelease pool in place.&lt;/p&gt;&lt;p&gt;Every thread has a stack of autorelease pools. On the main thread, an autorelease pool is created for you before Cocoa calls out to your code, and drained after your code returns. Every object you autorelease (whether explicitly or implicitly) goes into the pool, so that the pool will release it when the pool gets drained. When you create a thread, you have to create and drain an autorelease pool on that thread yourself. (Or just not autorelease anything, but that&#x27;s practically impossible for any meaningful amount of code.)&lt;/p&gt;&lt;p&gt;If you ever decide to run your code under garbage-collection, you&#x27;ll need to send the pool &lt;code&gt;drain&lt;/code&gt;, not &lt;code&gt;release&lt;/code&gt;, when you&#x27;re done with it, for the pool to be useful. When GC is enabled, &lt;code&gt;release&lt;/code&gt; and &lt;code&gt;autorelease&lt;/code&gt; messages do nothing—they don&#x27;t even go through. Your autorelease pool will respond to &lt;code&gt;drain&lt;/code&gt; by poking the garbage collector, which is the nearest equivalent to releasing the objects that would have been in the pool.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/&quot; rel=&quot;nofollow&quot;&gt;The Memory Management Programming Guide for Cocoa&lt;/a&gt; has more information about autorelease pools, among other things.&lt;/p&gt;</Body>
</answer>
</qroot>
