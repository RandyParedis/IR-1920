<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Which shape should have input and output data for a LSTM NN?</Title>
<Body>&lt;p&gt;I have a problem with the way of creating my data for a NN with a LSTM layer. I have &lt;strong&gt;many files&lt;/strong&gt; containing hundreds of lines. &lt;strong&gt;Each file represents a song&lt;/strong&gt; and &lt;strong&gt;each line represents a note with 4 values&lt;/strong&gt;. I want the NN read the notes with &lt;strong&gt;a sequence of 10 notes&lt;/strong&gt; so that it can predict the next note from them. If it is needed, we can fix the number of notes at 5000 per song.&lt;/p&gt;&lt;p&gt;So I just want to know which &lt;strong&gt;shape my input and output data&lt;/strong&gt; should have and how to define the first LSTM layer.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;model = Sequential()model.add(LSTM(32, input_shape=(5000, 4),return_sequences=True))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To sump up:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;One file has 5000 lines and 4 columns and represents 1 song.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;One line in a file represent one note with 4 values. &lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Thank you for your help.&lt;/p&gt;</Body>
<Tags>python,multidimensional-array,neural-network,keras,recurrent-neural-network</Tags>
</question>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;I want the NN read the notes with a sequence of 10 notes so that it can predict the next note from them.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I have never used keras but I think you should convert those notes into ids first. For instance: (aa, bb, cc, dd) as 1 and (ab, bb, cc, dd) as 2 and etc. &lt;/p&gt;&lt;p&gt;Then you read 10 ids/notes for the encoder and then add a projection to project the final state to the 11th note. And if you want to test the model with 10 notes from any note in the song you then train the second to the 11th and put the 12th as the target after the projection. And so on and so forth until the last note being as the target. This is for one song and repeat this for all songs.  &lt;/p&gt;&lt;p&gt;You can absolutely get the notes back via the ids. You can build a vocabulary to transfer it forth and back. &lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The input shape of the first LSTM layer should be &lt;code&gt;(None, 10, 4)&lt;/code&gt;.The output shape of the model would be &lt;code&gt;(None, 4)&lt;/code&gt;. I use &lt;code&gt;None&lt;/code&gt; for the batch size.&lt;/p&gt;&lt;p&gt;I coded a simple LSTM as an example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import numpy as npfrom keras.layers import LSTMfrom keras.models import Sequentialbatch_size = 32window_length = 10note_dim = 4n_samples = 5000# Input data. TODO: Slide window and modify it to use real datax = np.ones(shape=(n_samples, window_length, note_dim))y = np.ones(shape=(n_samples, note_dim))# Define modelmodel = Sequential()model.add(LSTM(note_dim, input_shape=(window_length, note_dim))) # The batch dimension is implicit heremodel.compile(&#x27;sgd&#x27;, &#x27;mse&#x27;)model.fit(x=x, # Batch input shape is: (None, window_length, note_dim)          y=y, # Batch output shape is: (None, note_dim)          batch_size=batch_size)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In case you want a more complex model (i.e. 2 LSTM layers) you could define it this way:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# ...# Define modelhidden_size = 50model = Sequential()model.add(LSTM(hidden_size, input_shape=(window_length, note_dim), return_sequences=True)) # The batch dimension is implicit heremodel.add(LSTM(note_dim))# ...&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&lt;p&gt;&lt;strong&gt;UPDATE:&lt;/strong&gt; Answer to your first comment.&lt;/p&gt;&lt;p&gt;&lt;code&gt;x&lt;/code&gt; should contain all the songs after sliding a window on them. For example, let&#x27;s suppose you have a variable &lt;code&gt;songs&lt;/code&gt; with shape &lt;code&gt;(n_songs, notes_per_song, note_dim)&lt;/code&gt; containing all your songs. Then, you could create &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# ...# Input data    # Suppose that variable ´songs´ is an array with shape: (n_songs, notes_per_song, note_dim). samples_per_song = notes_per_song-window_lengthn_samples = n_songs*samples_per_songx = np.zeros(shape=(n_samples, window_length, note_dim))y = np.zeros(shape=(n_samples, note_dim))for n, song in enumerate(songs):    for i in range(samples_per_song):        x[i+n*samples_per_song, :, :] = song[i:(i+window_length), :]        y[i+n*samples_per_song, :, :] = song[i+window_length, :] # note that you want to predict# ...&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
