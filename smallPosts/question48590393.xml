<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>std::vector as input buffer for MPI nonblocking functions</Title>
<Body>&lt;p&gt;&lt;strong&gt;TLDR&lt;/strong&gt;: If your input buffer to a nonblocking MPI peer-to-peer or RMA function is a vector, then at some point pointers to underlying elements will be invalidated (upon vector insertion), causing memory corruption issues if communication operations are not complete.&lt;/p&gt;&lt;p&gt;Consider this function, where I have to copy the input data into a vector, before passing it to &lt;code&gt;MPI_Issend&lt;/code&gt; (or any nonblocking send):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    void TaggedIssend(int tag, int target, int count, const long* data)    {        // data        const long msgq_size = msgQ_data_.size();        for (int i = 0; i &amp;lt; count; i++)            msgQ_data_.push_back(data[i]);        // request        const long req_size = msgQ_reqs_.size();        msgQ_reqs_.push_back(MPI_REQUEST_NULL);        MPI_Issend(&amp;amp;msgQ_data_[msgq_size], count, MPI_LONG,                 target, tag, comm_, &amp;amp;msgQ_reqs_[req_size]);    }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At one point, &lt;code&gt;msgQ_data_&lt;/code&gt; and &lt;code&gt;msgQ_reqs_&lt;/code&gt; will be moved (copied over to a new location), and at that point if the sends are not complete, then the program will crash (segfaults will appear at seemingly weird places, and &lt;code&gt;MPI_Request&lt;/code&gt; object could be rendered invalid upon testing, to name a few issues). Although I use &lt;code&gt;std::vector&lt;/code&gt; in this particular question, same issues will appear with dynamically resizing arrays. That&#x27;s why the type of input buffer for MPI communication functions is &lt;code&gt;const void*&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: I am interested to know the techniques to safely use a dynamically resizing array as an input buffer to MPI nonblocking functions.  I am currently pushing outgoing data into a fixed-size buffer, and when it is full, I issue all the sends at one go, and complete them before re-using the buffer. Can anyone suggest a better alternative? The reason I used &lt;code&gt;MPI_Issend&lt;/code&gt; here is because my sends are happening inside a while loop, and I can test-all the sends for communication completion (testing a request associated with an &lt;code&gt;MPI_Issend&lt;/code&gt; will return true only if a matching receive was posted), and use it to break out of the loop.&lt;/p&gt;</Body>
<Tags>c++,vector,mpi</Tags>
</question>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;I am interested to know the techniques to safely use a dynamically resizing array as an input buffer to MPI nonblocking functions.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Use &lt;code&gt;std::vector::reserve&lt;/code&gt; to allocate enough memory space. Then, if you &lt;code&gt;push_back&lt;/code&gt; into that &lt;code&gt;vector&lt;/code&gt;, it is guaranteed not to reallocate until the reserved capacity is not full. This solution is kind of fragile, but it will work if you know the maximum vector size in advance.&lt;/p&gt;&lt;p&gt;Alternatively, you can also send with &lt;code&gt;MPI_Bsend&lt;/code&gt;, e.g., with some incrementing &lt;code&gt;tag&lt;/code&gt; argument, and then send this tag back to test that data has been received.&lt;/p&gt;</Body>
</answer>
</qroot>
