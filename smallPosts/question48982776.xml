<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Storing a function in a class without call overhead</Title>
<Body>&lt;p&gt;I want to store a function, or a reference thereto, in a class as member variable. I am aware of both storing a function pointer as well as std::function or boosts equivalent. However, I recently &lt;a href=&quot;https://stackoverflow.com/questions/25848690/should-i-use-stdfunction-or-a-function-pointer-in-c&quot;&gt;read&lt;/a&gt; that using pointers results in a call overhead compared to template parameters. In that search I stumbled upon &lt;a href=&quot;https://stackoverflow.com/questions/9535680/functions-functors-as-template-parameters-can-they-be-stored&quot;&gt;this&lt;/a&gt; post, but I fail to reproduce working code from the answer. Here is what I tried, following some of the answers:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template&amp;lt;typename ftype&amp;gt;class MyClass{private:    ftype func;public:    MyClass(ftype func_)    :func(func_)    {}};double dosth(double x){    return x*x;}int main(){    MyClass&amp;lt;decltype(dosth)&amp;gt; entity(dosth);}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, it results in the error:&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;error: data member instantiated with function type &#x27;double (double)&#x27;&lt;/p&gt;    &lt;p&gt;note: in instantiation of template class &#x27;MyClass&amp;lt; double (double)&gt;&#x27; requested here&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I&#x27;m not sure where the exact problem lies, but I would like the exact function type to be inputted at compile time.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;So my question is&lt;/strong&gt;: Writing a class that somehow needs the information of a function that will repeatedly be called (and only called), what can I do to avoid said overhead?&lt;/p&gt;</Body>
<Tags>c++,templates</Tags>
</question>
<answer>
<Body>&lt;p&gt;I think you are looking at a non-existent problem. From the &lt;a href=&quot;https://stackoverflow.com/a/25848890/434551&quot;&gt;accepted answer&lt;/a&gt; of the question you linked to:&lt;/p&gt;&lt;pre class=&quot;lang-none prettyprint-override&quot;&gt;&lt;code&gt;+-------------------+--------------+---------------+----------------+|                   | function ptr | std::function | template param |+===================+==============+===============+================+| can capture       |    no(1)     |      yes      |       yes      || context variables |              |               |                |+-------------------+--------------+---------------+----------------+| no call overhead  |     yes      |       no      |       yes      || (see comments)    |              |               |                |+-------------------+--------------+---------------+----------------+| can be inlined    |      no      |       no      |       yes      || (see comments)    |              |               |                |+-------------------+--------------+---------------+----------------+  ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If not being able to support inlining is your only problem, I am going to say, you don&#x27;t have much to worry about.&lt;/p&gt;&lt;p&gt;When push comes to shove, you can wrap an inline function in a class template and use the class template.&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;Update, in response to OP&#x27;s commment.&lt;/h3&gt;&lt;p&gt;Let&#x27;s say you wanted to use the function&lt;/p&gt;&lt;pre&gt;&lt;code&gt;double square(double in) { return in*in; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It wan be wrapped in a class template as:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt; struct Square{    T operator() const (T in) { return in*in; }};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can use &lt;code&gt;Square&amp;lt;double&amp;gt;&lt;/code&gt; as a type instead of &lt;code&gt;square&lt;/code&gt; as a function pointer.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The other comments already explained how to make it compile, but be assured that this doesn&#x27;t fix your performance problem.&lt;/p&gt;&lt;p&gt;First of all, you still have a function pointer in your wrapper, and it&#x27;s not much different from a &lt;code&gt;std::function&lt;/code&gt; in it&#x27;s most trivial form. Congratulations on reinventing the wheel.&lt;/p&gt;&lt;p&gt;A template would only improve things, if not just the function signature, but rather the actual function was the template parameter. Only then the compiler would had been able to resolve the function call at compile time and apply optimizations such as inlining or static evaluation.&lt;/p&gt;&lt;p&gt;It&#x27;s the lack of these optimizations which make function pointers so expensive. The actual invocation of the function pointer has no real impact, that is what processors have a branch prediction for.&lt;/p&gt;</Body>
</answer>
</qroot>
