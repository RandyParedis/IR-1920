<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Forward and reverse query to ManyToMany relation Django</Title>
<Body>&lt;p&gt;I have this model:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Task(MPTTModel, TimeStampedModel, StartFinishModel):    name = models.CharField(max_length=256)    start_after_end = models.ManyToManyField(&#x27;self&#x27;,                                                                                 related_name=&#x27;s2e_relation&#x27;,                                             blank=True)     #s2e means that task can&#x27;t start before related tasks end&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How can I get all tasks, which can&#x27;t start before this task ends and all tasks, which have to end before this task can start.   &lt;/p&gt;&lt;pre&gt;&lt;code&gt;Let&#x27;s say 1 -&amp;gt; 2 -&amp;gt; 3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have id &lt;code&gt;2&lt;/code&gt;. I want to find &lt;code&gt;3&lt;/code&gt; and with another query &lt;code&gt;1&lt;/code&gt;.&lt;br&gt;To find 3 I can use &lt;code&gt;Task.objects.get(id = 2).start_after_end.all()&lt;/code&gt;&lt;br&gt;How can I find &lt;code&gt;1&lt;/code&gt;?  &lt;/p&gt;&lt;p&gt;&lt;strong&gt;UPDATE 1&lt;/strong&gt;&lt;br&gt;Actually find out bigger problem - if I select &lt;code&gt;2 related to 1&lt;/code&gt; - 1 immidiately changes relation to &lt;code&gt;1 is related to 2&lt;/code&gt;&lt;/p&gt;</Body>
<Tags>python,django</Tags>
</question>
<answer>
<Body>&lt;p&gt;Idea is to use &lt;code&gt;related_name=&#x27;s2e_relation&#x27;&lt;/code&gt; passed in &lt;code&gt;ManyToManyField&lt;/code&gt;&lt;/p&gt;&lt;p&gt;You can do so by:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Task.objects.get(id=2).s2e_relation.all()&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;If you make a relation with &lt;code&gt;&#x27;self&#x27;&lt;/code&gt;, by default Django will make the relation &lt;em&gt;symmetrical&lt;/em&gt;. This means that if an object &lt;code&gt;a&lt;/code&gt; has as friend &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; automatically has as friend &lt;code&gt;a&lt;/code&gt;. So this means that the relation here will look like:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# symmetrical relation1  &amp;lt;---&amp;gt; 2 &amp;lt;---&amp;gt; 3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It thus means that for:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;task1.start_after_end.all()  # ==&amp;gt; [2]task2.start_after_end.all()  # ==&amp;gt; [1, 3]task3.start_after_end.all()  # ==&amp;gt; [2]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So that here both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; will be seen as &lt;code&gt;Task2.start_after_end.all()&lt;/code&gt;s. You probably do &lt;em&gt;not&lt;/em&gt; want that: you want the relation to be &lt;em&gt;non-symetrical&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;So you should edit the field to:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Task(MPTTModel, TimeStampedModel, StartFinishModel):    name = models.CharField(max_length=256)    start_after_end = models.ManyToManyField(        &#x27;self&#x27;,                                            related_name=&#x27;s2e_relation&#x27;,        &lt;b&gt;symmetrical=False,&lt;/b&gt;        blank=True    )&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the above will look like:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# asymmetrical relation1   ---&amp;gt; 2  ---&amp;gt; 3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that &lt;em&gt;non-symmetrical&lt;/em&gt; relations are &lt;em&gt;not&lt;/em&gt; &lt;em&gt;anti-symmetrical&lt;/em&gt; relations. It is still possible to add &lt;code&gt;task1&lt;/code&gt; to the &lt;code&gt;start_after_end&lt;/code&gt; of &lt;code&gt;task2&lt;/code&gt;, but it will not do this automatically in case you add &lt;code&gt;task2&lt;/code&gt; to the &lt;code&gt;start_after_end&lt;/code&gt; of &lt;code&gt;task1&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;So now if that is done, it means that for &lt;code&gt;some_task&lt;/code&gt;, we get the next tasks with:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;my_task.start_after_end.all()  # the next ones&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and we get the ones before with the &lt;code&gt;related_name&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;my_task.s2e_relation.all()     # the previous ones&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So for example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;task1 = Task.objects.create(name=&#x27;task1&#x27;)task2 = Task.objects.create(name=&#x27;task2&#x27;)task3 = Task.objects.create(name=&#x27;task3&#x27;)task1.start_after_end.add(task2)task2.start_after_end.add(task3)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then if we trigger the relations, we get:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;task1.start_after_end.all()  # ==&amp;gt; [2]task2.start_after_end.all()  # ==&amp;gt; [3]task3.start_after_end.all()  # ==&amp;gt; []task1.s2e_relation.all()  # ==&amp;gt; []task2.s2e_relation.all()  # ==&amp;gt; [1]task3.s2e_relation.all()  # ==&amp;gt; [2]&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
</qroot>
