<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Cache efficiency with static member in thread</Title>
<Body>&lt;p&gt;I&#x27;m currently making an application with multiple worker threads, running in parallel. The main part of the program is executed before the workers, and each workers are put to sleep when they have finished their tasks:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;MainLoop(){    // ...    SoundManager::PlaySound(&quot;sound1.mp3&quot;);  // Add a sound to be played, store the sound in a list in SoundManager    SoundManager::PlaySound(&quot;sound2.mp3&quot;);    SoundManager::PlaySound(&quot;sound3.mp3&quot;);    // ...    SoundThreadWorker.RunJob(); // Wake up thread and play every sound pushed in SoundManager    // Running other threads    SoundThreadWorker.WaitForFinish();  // Wait until the thread have finished its tasks, thread is put to sleep(but not closed)    // Waiting other threads    // ...}// In SoundThreadWorker class, running in a different thread from the main loopRunJob(){    SoundManager::PlayAllSound();   // Play all sound stored in SoundManager}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, the static variable storing all sounds should be safe because no sound are added when the thread is running.&lt;/p&gt;&lt;p&gt;Is this cache efficient?&lt;/p&gt;&lt;p&gt;I have read here that: &lt;a href=&quot;https://www.agner.org/optimize/optimizing_cpp.pdf&quot; rel=&quot;nofollow noreferrer&quot;&gt;https://www.agner.org/optimize/optimizing_cpp.pdf&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;  &lt;p&gt;&quot;The different threads need separate storage. No function or class  that is used by   multiple threads should rely on static or global  variables. (See thread-local storage p.   28) The threads have each  their stack. This can cause cache contentions if the  threads share  the same cache.&quot;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I have a hard time understand how static variable are stored in cache, and how they are used by each thread. Do I have two instance of SoundManager in cache, since thread does not share their stack? Do I need to create a shared memory to avoid this problem?&lt;/p&gt;</Body>
<Tags>c++,multithreading,caching</Tags>
</question>
<answer>
<Body>&lt;p&gt;That passage is about memory that is changed, not about memory that remains constant. Sharing constants between threads is fine.&lt;/p&gt;&lt;p&gt;When you have multiple CPUs each updating the same place, they have to be sending their changes back and forth to each other all the time. This results in contention for &#x27;owning&#x27; a particular piece of memory.&lt;/p&gt;&lt;p&gt;Often the ownership isn&#x27;t explicit. But when one CPU tells all the others that a particular cache line needs to be invalidated because it just changed something there, then all the other CPUs have to evict the value from their caches. This has the effect of the CPU to last modify a piece of memory effectively &#x27;owning&#x27; the cache line it was in.&lt;/p&gt;&lt;p&gt;And, again, this is only an issue for things that are changed.&lt;/p&gt;&lt;p&gt;Also, the view of memory and cache that I gave you is rather simplistic. Please don&#x27;t use it when reasoning about the thread safety of a particular piece of code. It&#x27;s sufficient to understand why multiple CPUs updating the same piece of memory is bad for your cache, but it&#x27;s not sufficient for understanding which CPU&#x27;s version of a particular memory location ends up being used by the others.&lt;/p&gt;&lt;p&gt;A memory location that doesn&#x27;t change during the lifetime of a thread being used by multiple threads will result in that memory location appearing in multiple CPU caches. But this isn&#x27;t a problem. Nor is it a problem for a particular memory location that doesn&#x27;t change to be stored in the L2 and L3 caches that are shared between CPUs.&lt;/p&gt;</Body>
</answer>
</qroot>
