<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Fastest way to search into an almost sorted array</Title>
<Body>&lt;p&gt;I can&#x27;t find the right algorithm for this problem. It&#x27;s given an almost sorted array, like &lt;code&gt;5 12 15 17 20 2 4&lt;/code&gt; (note that the array is in ascending order until one point, then the following numbers are smaller than the first one of the array) and I need to say if an element &lt;code&gt;x&lt;/code&gt; exists or not into that array. The easiest way is to order the whole array in ascending order but it must be done faster. I tried comparing the &lt;code&gt;x&lt;/code&gt;element with the first number and with the middle of the array, &lt;code&gt;(1+n)/2&lt;/code&gt; then if &lt;code&gt;x&lt;/code&gt; is greater than the first number and smaller that the middle number I used binary search from 1 to middle. This one works. But my problem is that I can&#x27;t figure it out if &lt;code&gt;x&lt;/code&gt; appears in the other half of the array, from middle to n. &lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;int main() {    int n, i, v[50001], k, x;    int left, mid, right;    std::cin &amp;gt;&amp;gt; n;    for (i = 1; i &amp;lt;= n; i++)        std::cin &amp;gt;&amp;gt; v[i];    std::cin &amp;gt;&amp;gt; k;    while (k) {        std::cin &amp;gt;&amp;gt; x;        k--;        left = 1;        right = n;        mid = (left + right) / 2;        // this part of the code works when the number is between v[1] and v[mid]        if(v[mid] == x)             std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot; is found\n&quot;;        if (v[left] &amp;lt;= x &amp;amp;&amp;amp; v[mid] &amp;gt;= x) {            right = mid;            while (left &amp;lt; right) {                mid = (left + right) / 2;                if (v[mid] &amp;lt; x)                    left = mid + 1;                else                    right = mid;            }            if (v[right] == x)                std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot; is found\n&quot;;            else                std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot; is not found\n&quot;;        }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;but I don&#x27;t know what to do in the other half because the mid in the 2nd half can be smaller than both the numbers from the left and from the right.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;else if(v[mid] &amp;lt;= x &amp;amp;&amp;amp; v[right] &amp;gt;= x) {            left = mid;            right = n;            while (left &amp;lt; right) {                mid = (left + right) / 2;                if (v[mid] &amp;lt; x)                    // what do to here                else {                    // and here                }            }            if (v[left] == x)                std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot; is found\n&quot;;            else                std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot; is not found\n&quot;;        }    }&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++,algorithm,sorting,search</Tags>
</question>
</qroot>
