<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>How to count pair of peaks indexes including last entry?</Title>
<Body>&lt;p&gt;I have hit a roadblock trying to include the last entry of an index to the output. A pair of peaks is defined by a set of neighbouring values in a list that is higher than 3. How can I include the index of the last entry into the output?&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data_series_1 = [6,4,5,2,2,0,5,4,4,2,0,2,2,1,4,2,2,5,4,6]def paired_peaks(data_series,threshold):    peaks =[]    for k in range(0,len(data_series)-1):        y_b = data_series[k-1]        y= data_series[k]        y_a = data_series[k+1]        if y&amp;gt;threshold:            if y_b&amp;gt;threshold or y_a&amp;gt;threshold:                peaks.append(k)    return peaksprint(paired_peaks(data_series_1,3))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I expected it to be &lt;code&gt;[0, 1, 2, 6, 7, 8, 17, 18, 19]&lt;/code&gt;, however the actual output is &lt;code&gt;[0, 1, 2, 6, 7, 8, 17, 18]&lt;/code&gt;.&lt;/p&gt;</Body>
<Tags>python,python-3.x,list,for-loop,indexing</Tags>
</question>
<answer>
<Body>&lt;p&gt;This would solve your problem:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data_series_1 = [6,4,5,2,2,0,5,4,4,2,0,2,2,1,4,2,2,5,4,6]def paired_peaks(data_series,threshold):    peaks =[]    for k in range(len(data_series)):        y_b = data_series[k-1] if k - 1 in range(len(data_series)) else 0        y= data_series[k]        y_a = data_series[k+1] if k + 1 in range(len(data_series)) else 0        if y&amp;gt;threshold:            if y_b&amp;gt;threshold or y_a&amp;gt;threshold:                peaks.append(k)    return peaksprint(paired_peaks(data_series_1,3))# returns: [0, 1, 2, 6, 7, 8, 17, 18, 19]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The reason your calculations stopped too early was because of: &lt;code&gt;range(0,len(data_series)-1)&lt;/code&gt;. You exited the loop to early. I also added &lt;code&gt;if k +/- 1 in range(len(data_series)) else 0&lt;/code&gt; to your code because the first item and last item of your list have no neighbour so it should be zero I assume. For the last item this would otherwise raise an Error because it&#x27;s out of bounds. For the first item this didn&#x27;t raise an error because &lt;code&gt;data_series_1[-1]&lt;/code&gt; return the &lt;strong&gt;last&lt;/strong&gt; item of your list, but I don&#x27;t think that was intended in your code.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Your problem happens when &lt;code&gt;for&lt;/code&gt; loops comes to the end. When you get to the last element, you are trying to read the element that comes after it, and the element does not exist. &lt;/p&gt;&lt;p&gt;What might tricked you is because &lt;code&gt;data_series[-1]&lt;/code&gt; actually read the last element instead of rising error. &lt;/p&gt;&lt;p&gt;Now, I don&#x27;t know what your intentions are with your program, do you want to read the first element instead of nonexistant element? I assumed you do because first element is compared to the last and second one.&lt;/p&gt;&lt;p&gt;To fix your problem I did:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data_series_1 = [6,4,5,2,2,0,5,4,4,2,0,2,2,1,4,2,2,5,4,6]def paired_peaks(data_series,threshold):    peaks =[]    l = len(data_series)    for k in range(l):        y_b = data_series[k-1]        y= data_series[k]        y_a = data_series[(k+1)%l]    if y &amp;gt; threshold:        if y_b &amp;gt; threshold or y_a &amp;gt; threshold:            peaks.append(k)    return peaksprint(paired_peaks(data_series_1,3))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I added wrote the length of &lt;code&gt;data_series&lt;/code&gt; to variable &lt;code&gt;l&lt;/code&gt; and then instead checked module value with &lt;code&gt;data_series[(k+1)%l]&lt;/code&gt; to ensure your first element is read instead of nonexistant one.&lt;/p&gt;&lt;p&gt;This works as intended, however I advise you to check whether you want your first element to be compared to last element and do you want your last element be compared to the first element.&lt;/p&gt;</Body>
</answer>
</qroot>
