<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Uninitialized pointers in code</Title>
<Body>&lt;p&gt;I am learning C++ and I came to know that pointers if left uninitialized could point to random locations in memory and create problems that memory might be used by some other program.&lt;/p&gt;&lt;p&gt;Now if that is the case we should never have this line in any part of our code: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;int* ptr;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead we should have something like &lt;/p&gt;&lt;pre&gt;&lt;code&gt;int* ptr = NULL; //Is this going to avoid the problem&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please suggest because I have seen the first line(&lt;strong&gt;&lt;code&gt;int* ptr;&lt;/code&gt;&lt;/strong&gt;) in many books so I am getting this doubt. If possible give some examples also.&lt;/p&gt;</Body>
<Tags>c++,pointers,null-pointer</Tags>
</question>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;int* ptr = NULL; //Is this going to avoid the problem&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will cause &lt;code&gt;ptr&lt;/code&gt; to point to &lt;code&gt;NULL&lt;/code&gt; which you can explicitly check for as a default/uninitialized value. It prevents the problem you describe, but a careless programmer can still accidentally dereference a null pointer without checking, causing undefined behaviour.&lt;/p&gt;&lt;p&gt;The main advantage is your convenience for checking whether the &lt;code&gt;ptr&lt;/code&gt; has or has not been initialized to anything, ie:&lt;/p&gt;&lt;pre&gt;&lt;code&gt; if (ptr != NULL) {     // assume it points to something }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since this is pretty idiomatic, its pretty dangerous to not initialize the pointer to &lt;code&gt;NULL&lt;/code&gt;. The pointer would be initialized to a non-NULL garbage value that doesn&#x27;t really point to anything real. Worst of all, the check above would pass, causing even worse problems if it just so happens that the address in the pointer is memory you can legally access. In some Embedded environments, you might be able to access any part of memory, so you might accidentally corrupt random parts of memory or random parts of your executing code.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;It&#x27;s alway better to initialize a pointer to NULL if for any reason you can&#x27;t initialize it while declaration occurs . For example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Object *ptr = new Object();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Typically a function can check the value of the pointer against NULL to verify that the pointer has been initialized before. If you haven&#x27;t set it explicitly to NULL, and it points to a random value, then it could be dereferenced causing a segfault.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;If the pointer is not used, the compiler will simply ignore it. Initializing it to NULL is the safe thing to do, imho.&lt;/p&gt;&lt;p&gt;Are you sure your not confusing with a function declaration? It&#x27;s very common for a function to be declared as&lt;/p&gt;&lt;p&gt;char* do_something(const char* one,const char* two);&lt;/p&gt;&lt;p&gt;In this case, the pointers are used to specify what kind of argument you want to pass.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Always initialize your variables.&lt;/p&gt;&lt;p&gt;Occasionally, you may want to initialize to &lt;code&gt;NULL&lt;/code&gt;, but most of the time, you should be able to initialize the pointer &lt;em&gt;to the value it is supposed to hold&lt;/em&gt;. Declare variables as late as possible, and initialize them at that point, not 15 lines further down in your code.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;In C++, you should generally avoid plain old pointers altogether. Standard library classes, smart pointers (until C++0x only in various libraries like Boost or Loki) and references can and should be used in most places instead.&lt;/p&gt;&lt;p&gt;If you can&#x27;t avoid pointers, it&#x27;s indeed preferable to declare them with initializations, which in most cases should not be NULL, but the actual target value, because in C++ you can mix declarations and expressions freely, so you can and should only declare the variable at the point you have meaningful value for it.&lt;/p&gt;&lt;p&gt;That&#x27;s not the case with C where you have to use pointers a lot and all variables have to (or had to before C99; I am not exactly sure) be declared at the begining of a scope. So many people still have bad habits from C that are not appropriate for C++.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;The line:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int* ptr;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is definitely not guaranteed to initialize the pointer value to anything in particular.The line:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int* ptr = NULL;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Will initialize the pointer to point to address zero, which in practice will never hold anything useful, and which will be conventionally checked for as an invalid pointer value.&lt;/p&gt;&lt;p&gt;Of course, it is still possible, as has been said by Doug T., to attempt to use this pointer without checking it and so it would crash all the same.&lt;/p&gt;&lt;p&gt;Explicitly initializing to NULL has the advantage of ensuring that dereferencing the pointer before setting it to something useful will crash, which is actually a good thing, because it prevents the code from &quot;accidentally&quot; working while masking a serious bug.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;C++ follow on from C in that it is not designed to be a safe; it is designed to be efficient. It is therefore for this reason that automatic variables are not initialized. It is up to you to ensure that no pointer is used before it is initialized (although many compiler will warn you if you don&#x27;t initialize your variables)&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;int a,*ptr;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;now&lt;/p&gt;&lt;pre&gt;&lt;code&gt;print(ptr,*ptr)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the above code two cases can be possible:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;It&#x27;ll execute if default value in ptr is not the address of some used memory of program. &lt;/p&gt;&lt;p&gt;Output:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;       ptr             *ptreg.  0x400730       -1992206795&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;It&#x27;ll give error (segmental fault) if default address in the ptr is the address of some used memory of program. E.g. if the address of variable a in the memory is also 0x400730.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</Body>
</answer>
</qroot>
