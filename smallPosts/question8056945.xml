<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>C++ Convert char array to int representation</Title>
<Body>&lt;p&gt;What is the best way to convert a char array (containing bytes from a file) into an decimal representation so that it can be converted back later? &lt;/p&gt;&lt;p&gt;E.g &quot;test&quot; -&gt; 18951210 -&gt; &quot;test&quot;.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;EDITED&lt;/strong&gt;&lt;/p&gt;</Body>
<Tags>c++,math</Tags>
</question>
<answer>
<Body>&lt;p&gt;You can use a tree similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/Huffman_coding&quot; rel=&quot;nofollow&quot;&gt;Huffman&lt;/a&gt; compression algorithm, and then represent the path in the tree as numbers.&lt;/p&gt;&lt;p&gt;You&#x27;ll have to keep the dictionary somewhere, but you can just create a constant dictionary that covers the whole ASCII table, since the compression is not the goal here.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;I&#x27;m not sure what exactly you mean, but characters are stored in memory as their &quot;representation&quot;, so you don&#x27;t need to convert anything. If you still want to, you have to be more specific.&lt;/p&gt;&lt;p&gt;EDIT: You can&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Try to read byte by byte shifting the result 8 bits left and oring itwith the next byte.&lt;/li&gt;&lt;li&gt;Try to use mpz_inp_raw&lt;/li&gt;&lt;/ul&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;There is no conversion needed. You can just use pointers.&lt;/p&gt;&lt;p&gt;Example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;char array[4 * NUMBER];int *pointer;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Keep in mind that the &quot;length&quot; of &lt;code&gt;pointer&lt;/code&gt; is &lt;code&gt;NUMBER&lt;/code&gt;.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;As mentioned, character strings are already ranges of bytes (and hence easily rendered as decimal numbers) to start with.  Number your bytes from 000 to 255 and string them together and you&#x27;ve got a decimal number, for whatever that is worth.  It would help if you explained exactly why you would want to be using decimal numbers, specifically, as hex would be easier.&lt;/p&gt;&lt;p&gt;If you care about compression of the underlying arrays forming these numbers for Unicode Strings, you might be interested in:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Standard_Compression_Scheme_for_Unicode&quot; rel=&quot;nofollow&quot;&gt;http://en.wikipedia.org/wiki/Standard_Compression_Scheme_for_Unicode&lt;/a&gt;&lt;/p&gt;&lt;p&gt;If you want some benefits of compression but still want fast random-access reads and writes within a &quot;packed&quot; number, you might find my &quot;NSTATE&quot; library to be interesting:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://hostilefork.com/nstate/&quot; rel=&quot;nofollow&quot;&gt;http://hostilefork.com/nstate/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;For instance, if you just wanted a representation that only acommodated 26 english letters...you could store &quot;test&quot; in:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;NstateArray&amp;lt;26&amp;gt; myString (4);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You could read and write the letters without going through a compression or decompression process, in a smaller range of numbers than a conventional string.  Works with any radix.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Assuming you want to store the integers(I&#x27;m reading as ascii codes) in a string. This will add the leading zeros you will need to get it back into original string. character is a byte with a max value of 255 so it will need three digits in numeric form. It can be done without STL fairly easily too. But why not use tools you have?&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;sstream&amp;gt;using namespace std;char array[] = &quot;test&quot;;int main(){   stringstream out;   string s=array;      out.fill(&#x27;0&#x27;);   out.width(3);   for (int i = 0; i &amp;lt; s.size(); ++i)   {      out &amp;lt;&amp;lt; (int)s[i];   }   cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &quot; -&amp;gt; &quot; &amp;lt;&amp;lt; out.str();   return 0; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;output:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;test -&amp;gt; 116101115116&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Added:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;change line to &lt;/p&gt;&lt;pre&gt;&lt;code&gt;out &amp;lt;&amp;lt; (int)s[i] &amp;lt;&amp;lt; &quot;,&quot;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;output &lt;/p&gt;&lt;pre&gt;&lt;code&gt;test -&amp;gt; 116,101,115,116,&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;It can&#x27;t be done without a bignum class, since there&#x27;s more letter combinations possible than integer combinations in an &lt;code&gt;unsigned long long&lt;/code&gt;. (&lt;code&gt;unsigned long long&lt;/code&gt; &lt;em&gt;will&lt;/em&gt; hold about 7-8 characters)&lt;/p&gt;&lt;p&gt;If you have some sort of bignum class:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;biguint string_to_biguint(const std::string&amp;amp; s) {    biguint result(0);    for(int i=0; i&amp;lt;s.length(); ++i) {        result *= UCHAR_MAX;        result += (unsigned char)s[i];    }    return result;}std::string biguint_to_string(const biguint u) {    std::string result;    do {        result.append(u % UCHAR_MAX)        u /= UCHAR_MAX;    } while (u&amp;gt;0);    return result;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note: the string to uint conversion will lose leading NULLs, and the uint to string conversion will lose trailing NULLs.&lt;/p&gt;</Body>
</answer>
</qroot>
