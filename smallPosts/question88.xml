<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>Is gettimeofday() guaranteed to be of microsecond resolution?</Title>
<Body>&lt;p&gt;I am porting a game, that was originally written for the Win32 API, to Linux (well, porting the OS X port of the Win32 port to Linux).&lt;/p&gt;&lt;p&gt;I have implemented &lt;code&gt;QueryPerformanceCounter&lt;/code&gt; by giving the uSeconds since the process start up:     &lt;/p&gt;&lt;pre&gt;&lt;code&gt;BOOL QueryPerformanceCounter(LARGE_INTEGER* performanceCount){    gettimeofday(&amp;amp;currentTimeVal, NULL);    performanceCount-&amp;gt;QuadPart = (currentTimeVal.tv_sec - startTimeVal.tv_sec);    performanceCount-&amp;gt;QuadPart *= (1000 * 1000);    performanceCount-&amp;gt;QuadPart += (currentTimeVal.tv_usec - startTimeVal.tv_usec);    return true;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This, coupled with &lt;code&gt;QueryPerformanceFrequency()&lt;/code&gt; giving a constant 1000000 as the frequency, works well &lt;b&gt;on my machine&lt;/b&gt;, giving me a 64 bit variable that contains &lt;code&gt;uSeconds&lt;/code&gt; since the program&#x27;s start up.&lt;/p&gt;&lt;p&gt;So &lt;em&gt;is this portable?&lt;/em&gt; I don&#x27;t want to discover it works differently if the kernel was compiled in a certain way or anything like that. I am fine with it being non-portable to something other than Linux, however.&lt;/p&gt;</Body>
<Tags>linux,winapi,visual-c++,unix,timer</Tags>
</question>
<answer>
<Body>&lt;p&gt;From my experience, and from what I&#x27;ve read across the internet, the answer is &quot;No,&quot; it is not guaranteed.  It depends on CPU speed, operating system, flavor of Linux, etc.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Maybe. But you have bigger problems. &lt;code&gt;gettimeofday()&lt;/code&gt; can result in incorrect timings if there are processes on your system that change the timer (ie, ntpd). On a &quot;normal&quot; linux, though, I believe the resolution of &lt;code&gt;gettimeofday()&lt;/code&gt; is 10us. It can jump forward and backward and time, consequently, based on the processes running on your system. This effectively makes the answer to your question no.&lt;/p&gt;&lt;p&gt;You should look into &lt;code&gt;clock_gettime(CLOCK_MONOTONIC)&lt;/code&gt; for timing intervals. It suffers from several less issues due to things like multi-core systems and external clock settings.&lt;/p&gt;&lt;p&gt;Also, look into the &lt;code&gt;clock_getres()&lt;/code&gt; function.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;blockquote&gt;  &lt;p&gt;The actual resolution of gettimeofday() depends on the hardware architecture. Intel processors as well as SPARC machines offer high resolution timers that measure microseconds. Other hardware architectures fall back to the systemâ€™s timer, which is typically set to 100 Hz. In such cases, the time resolution will be less accurate. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;I obtained this answer from &lt;a href=&quot;http://web.archive.org/web/20160711223333/http://www.informit.com/guides/content.aspx?g=cplusplus&amp;amp;seqNum=272&quot; rel=&quot;nofollow noreferrer&quot;&gt;High Resolution Time Measurement and Timers, Part I&lt;/a&gt;&lt;/p&gt;</Body>
</answer>
</qroot>
