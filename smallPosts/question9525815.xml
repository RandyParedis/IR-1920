<?xml version="1.0" encoding="utf-8"?>
<qroot>
<question>
<Title>C++ Visual Studio 2010, compile error C3867 when implementing dynamic stack</Title>
<Body>&lt;p&gt;Currently working on an assignment for my datastructures class in university using stacks with dynamic memory allocation. Currently I&#x27;m getting a compile error C3867 saying I&#x27;m missing a function call from an argument list. I&#x27;m not really understanding where this error is coming from / I&#x27;m having trouble identifying what exactly is my error in my code; so I was wondering if someone might be kind enough to explain to me what it is, and maybe a friendly tip to remember so I can not have this happen again. &lt;/p&gt;&lt;p&gt;also, I apologize for the poor formatting, I&#x27;ve never posted here before sorry if its hard to read. :( &lt;/p&gt;&lt;p&gt;code posted below. &lt;/p&gt;&lt;p&gt;Thanks, and regards. :P &lt;/p&gt;&lt;p&gt;&lt;strong&gt;Header File:&lt;/strong&gt; &lt;/p&gt;&lt;pre&gt;&lt;code&gt;#ifndef STACK_H#define STACK_H#include &amp;lt;iostream&amp;gt;#include &amp;lt;iomanip&amp;gt;struct Node{    Node *nextPtr;    int value;};class Stack{public:     //Constructors and Deconstructers Here    Stack(); //Default Constructor    ~Stack(); //Default Deconstructor    //logical methods || functions here    bool isEmpty(void); //prototype checks if stack is empty    //stack operations || function prototypes here    void push(int); //prototype to push values of type int onto the stack    int pop(); //prototype to pop values off of the stack and return a value    int top(); //prototype to return the top valueprivate:    Node *topPtr; //pointer to class Node Object, specifically for the top of the stack};   #endif&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Class File:&lt;/strong&gt; &lt;/p&gt;&lt;pre&gt;&lt;code&gt;#include &quot;CPTN278_A3_Stack_Arsenault.h&quot;using namespace std;Stack::Stack(){    topPtr = 0; //set the top pointer equal to zero.}Stack::~Stack(){    while (!Stack::isEmpty())    {        Stack::pop();    }}bool Stack::isEmpty(){    if(top == 0)    {        return true;    }    else    {        return false;    } }void Stack::push(int valueTMP){    Node *itemPtr = new Node;     itemPtr-&amp;gt;nextPtr = topPtr;     itemPtr-&amp;gt;value = valueTMP;    topPtr = itemPtr;    return;}int Stack::pop(){    int returnValue; //unintialized int    Node *itemPtr; //unintialized pointer to node    returnValue = topPtr-&amp;gt;value;    itemPtr = topPtr;    topPtr = itemPtr-&amp;gt;nextPtr;    delete itemPtr;    return returnValue;}int Stack::top(void){    return topPtr-&amp;gt;value; //**this is where my error is being thrown**}&lt;/code&gt;&lt;/pre&gt;</Body>
<Tags>c++,pointers,compiler-errors,visual-c++-2010</Tags>
</question>
<answer>
<Body>&lt;pre&gt;&lt;code&gt;bool Stack::isEmpty(){    if(top == 0) // &amp;lt;-- here is the problem    {        return true;    }    else    {        return false;    } }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;top&lt;/code&gt; is a function, to check its result you need &lt;code&gt;top()&lt;/code&gt;. But I think you should be testing &lt;code&gt;topPtr&lt;/code&gt; instead.&lt;/p&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;In function &lt;code&gt;Stack::isEmpty()&lt;/code&gt;, something wrong with &lt;code&gt;top&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bool Stack::isEmpty(){  if(top == 0) // here  {    return true;  }  else  {    return false;  } }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I think it should be as below:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  if(topPtr==0)  ...&lt;/code&gt;&lt;/pre&gt;</Body>
</answer>
<answer>
<Body>&lt;p&gt;Before you had:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bool Stack::isEmpty(){    if(top == 0) &amp;lt;-- top is a function, did you mean &#x27;topPtr&#x27;?    {        return true;    }    else    {       return false;    } }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Fix:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;bool Stack::isEmpty(){    return topPtr == 0;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That&#x27;s your only build error. I&#x27;m not sure why you or the compiler thought it was in the top method. That&#x27;s perfectly fine. Also there&#x27;s no need to write:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if (expression_that_is_true_or_false)    return true;else    return false;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just do:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;return expression_that_is_true_or_false;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I might be borderline preaching style here, but try to get used to understanding expressions this way. Expressions involving logical operators like ==, !=, &amp;amp;&amp;amp;, ||, &amp;lt;, &gt;, etc. evaluate to true or false, so there is no need to do conditional branching only to then return what the expression originally evaluated to in the first place.&lt;/p&gt;&lt;p&gt;Oh and I realize this is homework, but check out std::stack later in your free time if you haven&#x27;t already.&lt;/p&gt;</Body>
</answer>
</qroot>
